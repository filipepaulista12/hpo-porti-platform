import { describe, it, expect, beforeAll } from '@jest/globals';

// Note: This test focuses on endpoint availability and response structure
// Full Babelon format validation requires more complex setup
describe('Babelon Export API', () => {
  const API_URL = process.env.API_URL || 'http://localhost:3001';
  let adminToken: string;
  let adminToken: string;
  let adminId: string;
  let translatorToken: string;
  let translatorId: string;
  let testTermId: string;
  let testTranslationId: string;

  beforeAll(async () => {
    // Create admin user
    const admin = await prisma.user.create({
      data: {
        email: 'admin-babelon@test.com',
        name: 'Babelon Admin',
        password: 'hashedpassword',
        role: 'ADMIN',
        orcidId: '0000-0002-1234-5678'
      }
    });
    adminId = admin.id;
    adminToken = generateToken(admin);

    // Create translator with professional profile
    const translator = await prisma.user.create({
      data: {
        email: 'translator-babelon@test.com',
        name: 'Babelon Translator',
        password: 'hashedpassword',
        role: 'TRANSLATOR',
        orcidId: '0000-0003-9876-5432',
        profileJson: {
          academicDegree: 'phd',
          fieldOfStudy: 'Medicina',
          professionalRole: 'researcher',
          medicalSpecialty: 'Geneticista',
          englishProficiency: 'advanced',
          ehealsScore: 35
        }
      }
    });
    translatorId = translator.id;
    translatorToken = generateToken(translator);

    // Create test HPO term
    const term = await prisma.hpoTerm.create({
      data: {
        hpoId: 'HP:9999999',
        labelEn: 'Test Term for Babelon',
        definitionEn: 'This is a test definition for Babelon export',
        category: 'Test',
        synonymsEn: []
      }
    });
    testTermId = term.id;

    // Create approved translation
    const translation = await prisma.translation.create({
      data: {
        termId: testTermId,
        userId: translatorId,
        labelPt: 'Termo de Teste para Babelon',
        definitionPt: 'Esta é uma definição de teste para exportação Babelon',
        confidence: 4,
        status: 'APPROVED',
        source: 'MANUAL'
      }
    });
    testTranslationId = translation.id;

    // Create validation for the translation
    await prisma.validation.create({
      data: {
        translationId: testTranslationId,
        validatorId: adminId,
        rating: 5,
        decision: 'APPROVED',
        comments: 'Excellent translation'
      }
    });
  });

  afterAll(async () => {
    // Cleanup in correct order (due to foreign keys)
    await prisma.validation.deleteMany({
      where: { translationId: testTranslationId }
    });
    await prisma.translation.deleteMany({
      where: { id: testTranslationId }
    });
    await prisma.hpoTerm.deleteMany({
      where: { id: testTermId }
    });
    await prisma.user.deleteMany({
      where: {
        email: {
          in: ['admin-babelon@test.com', 'translator-babelon@test.com']
        }
      }
    });
    await prisma.$disconnect();
  });

  describe('GET /api/export/release/babelon-with-orcid', () => {
    it('should generate valid Babelon TSV file with ORCID', async () => {
      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      // Check response headers
      expect(response.headers['content-type']).toContain('text/tab-separated-values');
      expect(response.headers['content-disposition']).toMatch(/attachment; filename="hp-pt-.*\.babelon\.tsv"/);

      // Parse TSV content
      const lines = response.text.split('\n');
      expect(lines.length).toBeGreaterThan(1); // At least header + 1 data row

      // Check header
      const header = lines[0].split('\t');
      expect(header).toContain('subject_id');
      expect(header).toContain('predicate_id');
      expect(header).toContain('source_language');
      expect(header).toContain('source_value');
      expect(header).toContain('translation_language');
      expect(header).toContain('translation_value');
      expect(header).toContain('translator');
      expect(header).toContain('translator_expertise');
      expect(header).toContain('translation_date');
      expect(header).toContain('translation_confidence');
      expect(header).toContain('translation_precision');
      expect(header).toContain('translation_status');
      expect(header).toContain('source');
      expect(header).toContain('source_version');

      // Check data rows contain our test translation
      const dataRows = lines.slice(1).filter(line => line.trim());
      const labelRow = dataRows.find(row => row.includes('HP:9999999') && row.includes('rdfs:label'));
      expect(labelRow).toBeDefined();

      if (labelRow) {
        const columns = labelRow.split('\t');
        const subjectIdx = header.indexOf('subject_id');
        const predicateIdx = header.indexOf('predicate_id');
        const translatorIdx = header.indexOf('translator');
        const expertiseIdx = header.indexOf('translator_expertise');
        const confidenceIdx = header.indexOf('translation_confidence');
        const statusIdx = header.indexOf('translation_status');

        expect(columns[subjectIdx]).toBe('HP:9999999');
        expect(columns[predicateIdx]).toBe('rdfs:label');
        expect(columns[translatorIdx]).toBe('https://orcid.org/0000-0003-9876-5432');
        expect(columns[expertiseIdx]).toBe('DOMAIN_EXPERT'); // PhD + medical specialty
        expect(parseFloat(columns[confidenceIdx])).toBeGreaterThan(0);
        expect(parseFloat(columns[confidenceIdx])).toBeLessThanOrEqual(1);
        expect(columns[statusIdx]).toBe('OFFICIAL');
      }
    });

    it('should include definition translations', async () => {
      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      const lines = response.text.split('\n');
      const header = lines[0].split('\t');
      const dataRows = lines.slice(1).filter(line => line.trim());
      
      const definitionRow = dataRows.find(row => 
        row.includes('HP:9999999') && row.includes('IAO:0000115')
      );

      expect(definitionRow).toBeDefined();

      if (definitionRow) {
        const columns = definitionRow.split('\t');
        const predicateIdx = header.indexOf('predicate_id');
        const sourceIdx = header.indexOf('source_value');
        const translationIdx = header.indexOf('translation_value');

        expect(columns[predicateIdx]).toBe('IAO:0000115');
        expect(columns[sourceIdx]).toContain('test definition');
        expect(columns[translationIdx]).toContain('definição de teste');
      }
    });

    it('should use internal ID for users without ORCID', async () => {
      // Create user without ORCID
      const userNoOrcid = await prisma.user.create({
        data: {
          email: 'no-orcid@test.com',
          name: 'No ORCID User',
          password: 'hashedpassword',
          role: 'TRANSLATOR'
        }
      });

      // Create translation by this user
      const term2 = await prisma.hpoTerm.create({
        data: {
          hpoId: 'HP:8888888',
          labelEn: 'Another Test Term',
          category: 'Test',
          synonymsEn: []
        }
      });

      const translation2 = await prisma.translation.create({
        data: {
          termId: term2.id,
          userId: userNoOrcid.id,
          labelPt: 'Outro Termo de Teste',
          confidence: 3,
          status: 'APPROVED',
          source: 'MANUAL'
        }
      });

      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      const lines = response.text.split('\n');
      const header = lines[0].split('\t');
      const translatorIdx = header.indexOf('translator');

      const row = lines.find(line => line.includes('HP:8888888'));
      expect(row).toBeDefined();

      if (row) {
        const columns = row.split('\t');
        expect(columns[translatorIdx]).toMatch(/^internal:/);
      }

      // Cleanup
      await prisma.translation.delete({ where: { id: translation2.id } });
      await prisma.hpoTerm.delete({ where: { id: term2.id } });
      await prisma.user.delete({ where: { id: userNoOrcid.id } });
    });

    it('should calculate translator expertise correctly', async () => {
      // Test different profile configurations
      const testCases = [
        {
          profile: { academicDegree: 'phd', medicalSpecialty: 'Cardiologista' },
          expectedExpertise: 'DOMAIN_EXPERT'
        },
        {
          profile: { professionalRole: 'clinician', medicalSpecialty: 'Neurologista' },
          expectedExpertise: 'DOMAIN_EXPERT'
        },
        {
          profile: { academicDegree: 'master' },
          expectedExpertise: 'PROFESSIONAL'
        },
        {
          profile: { professionalRole: 'professor' },
          expectedExpertise: 'PROFESSIONAL'
        },
        {
          profile: { ehealsScore: 35 },
          expectedExpertise: 'LAYPERSON_WITH_EXPERTISE'
        },
        {
          profile: {},
          expectedExpertise: 'LAYPERSON'
        }
      ];

      for (const testCase of testCases) {
        const user = await prisma.user.create({
          data: {
            email: `test-${Date.now()}@test.com`,
            name: 'Test User',
            password: 'hashedpassword',
            role: 'TRANSLATOR',
            orcidId: `0000-0000-${Math.floor(Math.random() * 10000)}-0000`,
            profileJson: testCase.profile
          }
        });

        const term = await prisma.hpoTerm.create({
          data: {
            hpoId: `HP:${Math.floor(Math.random() * 1000000)}`,
            labelEn: 'Test',
            category: 'Test',
            synonymsEn: []
          }
        });

        const translation = await prisma.translation.create({
          data: {
            termId: term.id,
            userId: user.id,
            labelPt: 'Teste',
            confidence: 3,
            status: 'APPROVED',
            source: 'MANUAL'
          }
        });

        const response = await request(app)
          .get('/api/export/release/babelon-with-orcid')
          .set('Authorization', `Bearer ${adminToken}`)
          .expect(200);

        const lines = response.text.split('\n');
        const header = lines[0].split('\t');
        const expertiseIdx = header.indexOf('translator_expertise');

        const row = lines.find(line => line.includes(term.hpoId));
        expect(row).toBeDefined();

        if (row) {
          const columns = row.split('\t');
          expect(columns[expertiseIdx]).toBe(testCase.expectedExpertise);
        }

        // Cleanup
        await prisma.translation.delete({ where: { id: translation.id } });
        await prisma.hpoTerm.delete({ where: { id: term.id } });
        await prisma.user.delete({ where: { id: user.id } });
      }
    });

    it('should require ADMIN role', async () => {
      await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${translatorToken}`)
        .expect(403);
    });

    it('should require authentication', async () => {
      await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .expect(401);
    });

    it('should filter by date range', async () => {
      const startDate = new Date('2025-01-01').toISOString().split('T')[0];
      const endDate = new Date('2025-12-31').toISOString().split('T')[0];

      const response = await request(app)
        .get(`/api/export/release/babelon-with-orcid?startDate=${startDate}&endDate=${endDate}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      expect(response.text).toBeTruthy();
      // Should contain header
      expect(response.text.split('\n')[0]).toContain('subject_id');
    });

    it('should calculate translation confidence correctly', async () => {
      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      const lines = response.text.split('\n');
      const header = lines[0].split('\t');
      const confidenceIdx = header.indexOf('translation_confidence');

      const row = lines.find(line => line.includes('HP:9999999'));
      expect(row).toBeDefined();

      if (row) {
        const columns = row.split('\t');
        const confidence = parseFloat(columns[confidenceIdx]);
        
        // Should be between 0 and 1
        expect(confidence).toBeGreaterThanOrEqual(0);
        expect(confidence).toBeLessThanOrEqual(1);
        
        // Since we have a validation with rating 5, confidence should be high
        expect(confidence).toBeGreaterThan(0.7);
      }
    });
  });

  describe('Babelon Format Validation', () => {
    it('should escape tabs in text values', async () => {
      // Create term with tab in label
      const termWithTab = await prisma.hpoTerm.create({
        data: {
          hpoId: 'HP:7777777',
          labelEn: 'Test\tWith\tTabs',
          category: 'Test',
          synonymsEn: []
        }
      });

      const transWithTab = await prisma.translation.create({
        data: {
          termId: termWithTab.id,
          userId: translatorId,
          labelPt: 'Teste\tCom\tTabs',
          confidence: 3,
          status: 'APPROVED',
          source: 'MANUAL'
        }
      });

      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      const lines = response.text.split('\n');
      const row = lines.find(line => line.includes('HP:7777777'));
      
      // Tabs should be replaced with spaces
      expect(row).not.toContain('\t\t'); // No double tabs
      expect(row).toContain('Test With Tabs');

      // Cleanup
      await prisma.translation.delete({ where: { id: transWithTab.id } });
      await prisma.hpoTerm.delete({ where: { id: termWithTab.id } });
    });

    it('should include all required Babelon columns', async () => {
      const response = await request(app)
        .get('/api/export/release/babelon-with-orcid')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      const header = response.text.split('\n')[0];
      const requiredColumns = [
        'subject_id',
        'predicate_id',
        'source_language',
        'source_value',
        'translation_language',
        'translation_value',
        'translator',
        'translator_expertise',
        'translation_date',
        'translation_confidence',
        'translation_precision',
        'translation_status',
        'source',
        'source_version'
      ];

      for (const column of requiredColumns) {
        expect(header).toContain(column);
      }
    });
  });
});
