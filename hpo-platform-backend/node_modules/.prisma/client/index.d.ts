
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model HpoTerm
 * 
 */
export type HpoTerm = $Result.DefaultSelection<Prisma.$HpoTermPayload>
/**
 * Model Translation
 * 
 */
export type Translation = $Result.DefaultSelection<Prisma.$TranslationPayload>
/**
 * Model Validation
 * 
 */
export type Validation = $Result.DefaultSelection<Prisma.$ValidationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model UserActivity
 * 
 */
export type UserActivity = $Result.DefaultSelection<Prisma.$UserActivityPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model ConflictReview
 * 
 */
export type ConflictReview = $Result.DefaultSelection<Prisma.$ConflictReviewPayload>
/**
 * Model CommitteeVote
 * 
 */
export type CommitteeVote = $Result.DefaultSelection<Prisma.$CommitteeVotePayload>
/**
 * Model Rejection
 * 
 */
export type Rejection = $Result.DefaultSelection<Prisma.$RejectionPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Strike
 * 
 */
export type Strike = $Result.DefaultSelection<Prisma.$StrikePayload>
/**
 * Model SessionLog
 * 
 */
export type SessionLog = $Result.DefaultSelection<Prisma.$SessionLogPayload>
/**
 * Model UserAnalytics
 * 
 */
export type UserAnalytics = $Result.DefaultSelection<Prisma.$UserAnalyticsPayload>
/**
 * Model ApiMetrics
 * 
 */
export type ApiMetrics = $Result.DefaultSelection<Prisma.$ApiMetricsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  TRANSLATOR: 'TRANSLATOR',
  REVIEWER: 'REVIEWER',
  VALIDATOR: 'VALIDATOR',
  MODERATOR: 'MODERATOR',
  COMMITTEE_MEMBER: 'COMMITTEE_MEMBER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TranslationStatus: {
  NOT_TRANSLATED: 'NOT_TRANSLATED',
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  IN_REVIEW: 'IN_REVIEW',
  PENDING_VALIDATION: 'PENDING_VALIDATION',
  LEGACY_PENDING: 'LEGACY_PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  NEEDS_REVISION: 'NEEDS_REVISION'
};

export type TranslationStatus = (typeof TranslationStatus)[keyof typeof TranslationStatus]


export const TranslationSource: {
  MANUAL: 'MANUAL',
  AI_ASSISTED: 'AI_ASSISTED',
  IMPORTED: 'IMPORTED',
  LEGACY: 'LEGACY'
};

export type TranslationSource = (typeof TranslationSource)[keyof typeof TranslationSource]


export const ValidationDecision: {
  APPROVED: 'APPROVED',
  NEEDS_REVISION: 'NEEDS_REVISION',
  REJECTED: 'REJECTED'
};

export type ValidationDecision = (typeof ValidationDecision)[keyof typeof ValidationDecision]


export const BadgeRarity: {
  COMMON: 'COMMON',
  RARE: 'RARE',
  EPIC: 'EPIC',
  LEGENDARY: 'LEGENDARY'
};

export type BadgeRarity = (typeof BadgeRarity)[keyof typeof BadgeRarity]


export const ActivityType: {
  TRANSLATION_CREATED: 'TRANSLATION_CREATED',
  TRANSLATION_APPROVED: 'TRANSLATION_APPROVED',
  TRANSLATION_REJECTED: 'TRANSLATION_REJECTED',
  VALIDATION_COMPLETED: 'VALIDATION_COMPLETED',
  BADGE_EARNED: 'BADGE_EARNED',
  LEVEL_UP: 'LEVEL_UP',
  STREAK_MILESTONE: 'STREAK_MILESTONE',
  COMMENT_ADDED: 'COMMENT_ADDED',
  ROLE_PROMOTION: 'ROLE_PROMOTION'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const ConflictType: {
  MULTIPLE_TRANSLATIONS: 'MULTIPLE_TRANSLATIONS',
  QUALITY_DISPUTE: 'QUALITY_DISPUTE',
  TERMINOLOGY_CONFLICT: 'TERMINOLOGY_CONFLICT'
};

export type ConflictType = (typeof ConflictType)[keyof typeof ConflictType]


export const ConflictStatus: {
  PENDING_COMMITTEE: 'PENDING_COMMITTEE',
  IN_VOTING: 'IN_VOTING',
  RESOLVED: 'RESOLVED',
  ESCALATED: 'ESCALATED'
};

export type ConflictStatus = (typeof ConflictStatus)[keyof typeof ConflictStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const VoteType: {
  APPROVE_THIS: 'APPROVE_THIS',
  CREATE_NEW: 'CREATE_NEW',
  ABSTAIN: 'ABSTAIN'
};

export type VoteType = (typeof VoteType)[keyof typeof VoteType]


export const RejectionReason: {
  INCORRECT_TRANSLATION: 'INCORRECT_TRANSLATION',
  POOR_GRAMMAR: 'POOR_GRAMMAR',
  NOT_MEDICAL_TERM: 'NOT_MEDICAL_TERM',
  DUPLICATE: 'DUPLICATE',
  OFFENSIVE_CONTENT: 'OFFENSIVE_CONTENT',
  SPAM: 'SPAM',
  INCONSISTENT: 'INCONSISTENT',
  OTHER: 'OTHER'
};

export type RejectionReason = (typeof RejectionReason)[keyof typeof RejectionReason]


export const AdminAction: {
  APPROVE_TRANSLATION: 'APPROVE_TRANSLATION',
  REJECT_TRANSLATION: 'REJECT_TRANSLATION',
  DELETE_TRANSLATION: 'DELETE_TRANSLATION',
  BAN_USER: 'BAN_USER',
  UNBAN_USER: 'UNBAN_USER',
  PROMOTE_USER: 'PROMOTE_USER',
  DEMOTE_USER: 'DEMOTE_USER',
  SYNC_TO_HPO: 'SYNC_TO_HPO',
  RESOLVE_CONFLICT: 'RESOLVE_CONFLICT',
  EDIT_TERM: 'EDIT_TERM',
  SYSTEM_CONFIG: 'SYSTEM_CONFIG',
  BULK_APPROVE: 'BULK_APPROVE',
  BULK_REJECT: 'BULK_REJECT',
  VOTE_ON_CONFLICT: 'VOTE_ON_CONFLICT',
  DEACTIVATE_STRIKE: 'DEACTIVATE_STRIKE'
};

export type AdminAction = (typeof AdminAction)[keyof typeof AdminAction]


export const SyncStatus: {
  PENDING: 'PENDING',
  GENERATING_FILE: 'GENERATING_FILE',
  CREATING_PR: 'CREATING_PR',
  PR_CREATED: 'PR_CREATED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const NotificationType: {
  TRANSLATION_APPROVED: 'TRANSLATION_APPROVED',
  TRANSLATION_REJECTED: 'TRANSLATION_REJECTED',
  VALIDATION_RECEIVED: 'VALIDATION_RECEIVED',
  CONFLICT_VOTE_NEEDED: 'CONFLICT_VOTE_NEEDED',
  LEVEL_UP: 'LEVEL_UP',
  BADGE_EARNED: 'BADGE_EARNED',
  COMMENT_RECEIVED: 'COMMENT_RECEIVED',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT',
  CONFLICT_RESOLVED: 'CONFLICT_RESOLVED',
  SYNC_COMPLETED: 'SYNC_COMPLETED',
  USER_SUSPENDED: 'USER_SUSPENDED',
  USER_PROMOTED: 'USER_PROMOTED',
  STRIKE_RECEIVED: 'STRIKE_RECEIVED',
  STRIKE_WARNING: 'STRIKE_WARNING',
  ACCOUNT_SUSPENDED: 'ACCOUNT_SUSPENDED',
  ACCOUNT_RESTORED: 'ACCOUNT_RESTORED',
  ROLE_PROMOTION: 'ROLE_PROMOTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const StrikeReason: {
  LOW_QUALITY_TRANSLATION: 'LOW_QUALITY_TRANSLATION',
  SPAM_SUBMISSIONS: 'SPAM_SUBMISSIONS',
  INAPPROPRIATE_CONTENT: 'INAPPROPRIATE_CONTENT',
  PLAGIARISM: 'PLAGIARISM',
  MANIPULATION_SYSTEM: 'MANIPULATION_SYSTEM',
  DISRESPECTFUL_BEHAVIOR: 'DISRESPECTFUL_BEHAVIOR',
  VIOLATION_GUIDELINES: 'VIOLATION_GUIDELINES',
  OTHER: 'OTHER'
};

export type StrikeReason = (typeof StrikeReason)[keyof typeof StrikeReason]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TranslationStatus = $Enums.TranslationStatus

export const TranslationStatus: typeof $Enums.TranslationStatus

export type TranslationSource = $Enums.TranslationSource

export const TranslationSource: typeof $Enums.TranslationSource

export type ValidationDecision = $Enums.ValidationDecision

export const ValidationDecision: typeof $Enums.ValidationDecision

export type BadgeRarity = $Enums.BadgeRarity

export const BadgeRarity: typeof $Enums.BadgeRarity

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type ConflictType = $Enums.ConflictType

export const ConflictType: typeof $Enums.ConflictType

export type ConflictStatus = $Enums.ConflictStatus

export const ConflictStatus: typeof $Enums.ConflictStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type VoteType = $Enums.VoteType

export const VoteType: typeof $Enums.VoteType

export type RejectionReason = $Enums.RejectionReason

export const RejectionReason: typeof $Enums.RejectionReason

export type AdminAction = $Enums.AdminAction

export const AdminAction: typeof $Enums.AdminAction

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type StrikeReason = $Enums.StrikeReason

export const StrikeReason: typeof $Enums.StrikeReason

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.hpoTerm`: Exposes CRUD operations for the **HpoTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HpoTerms
    * const hpoTerms = await prisma.hpoTerm.findMany()
    * ```
    */
  get hpoTerm(): Prisma.HpoTermDelegate<ExtArgs>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **Translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.TranslationDelegate<ExtArgs>;

  /**
   * `prisma.validation`: Exposes CRUD operations for the **Validation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Validations
    * const validations = await prisma.validation.findMany()
    * ```
    */
  get validation(): Prisma.ValidationDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.userActivity`: Exposes CRUD operations for the **UserActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivities
    * const userActivities = await prisma.userActivity.findMany()
    * ```
    */
  get userActivity(): Prisma.UserActivityDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.conflictReview`: Exposes CRUD operations for the **ConflictReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConflictReviews
    * const conflictReviews = await prisma.conflictReview.findMany()
    * ```
    */
  get conflictReview(): Prisma.ConflictReviewDelegate<ExtArgs>;

  /**
   * `prisma.committeeVote`: Exposes CRUD operations for the **CommitteeVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommitteeVotes
    * const committeeVotes = await prisma.committeeVote.findMany()
    * ```
    */
  get committeeVote(): Prisma.CommitteeVoteDelegate<ExtArgs>;

  /**
   * `prisma.rejection`: Exposes CRUD operations for the **Rejection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rejections
    * const rejections = await prisma.rejection.findMany()
    * ```
    */
  get rejection(): Prisma.RejectionDelegate<ExtArgs>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.strike`: Exposes CRUD operations for the **Strike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strikes
    * const strikes = await prisma.strike.findMany()
    * ```
    */
  get strike(): Prisma.StrikeDelegate<ExtArgs>;

  /**
   * `prisma.sessionLog`: Exposes CRUD operations for the **SessionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionLogs
    * const sessionLogs = await prisma.sessionLog.findMany()
    * ```
    */
  get sessionLog(): Prisma.SessionLogDelegate<ExtArgs>;

  /**
   * `prisma.userAnalytics`: Exposes CRUD operations for the **UserAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnalytics
    * const userAnalytics = await prisma.userAnalytics.findMany()
    * ```
    */
  get userAnalytics(): Prisma.UserAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.apiMetrics`: Exposes CRUD operations for the **ApiMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiMetrics
    * const apiMetrics = await prisma.apiMetrics.findMany()
    * ```
    */
  get apiMetrics(): Prisma.ApiMetricsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    HpoTerm: 'HpoTerm',
    Translation: 'Translation',
    Validation: 'Validation',
    Comment: 'Comment',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    UserActivity: 'UserActivity',
    SystemConfig: 'SystemConfig',
    ConflictReview: 'ConflictReview',
    CommitteeVote: 'CommitteeVote',
    Rejection: 'Rejection',
    AdminAuditLog: 'AdminAuditLog',
    SyncLog: 'SyncLog',
    Notification: 'Notification',
    Strike: 'Strike',
    SessionLog: 'SessionLog',
    UserAnalytics: 'UserAnalytics',
    ApiMetrics: 'ApiMetrics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "hpoTerm" | "translation" | "validation" | "comment" | "badge" | "userBadge" | "userActivity" | "systemConfig" | "conflictReview" | "committeeVote" | "rejection" | "adminAuditLog" | "syncLog" | "notification" | "strike" | "sessionLog" | "userAnalytics" | "apiMetrics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      HpoTerm: {
        payload: Prisma.$HpoTermPayload<ExtArgs>
        fields: Prisma.HpoTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HpoTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HpoTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          findFirst: {
            args: Prisma.HpoTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HpoTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          findMany: {
            args: Prisma.HpoTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>[]
          }
          create: {
            args: Prisma.HpoTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          createMany: {
            args: Prisma.HpoTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HpoTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>[]
          }
          delete: {
            args: Prisma.HpoTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          update: {
            args: Prisma.HpoTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          deleteMany: {
            args: Prisma.HpoTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HpoTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HpoTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HpoTermPayload>
          }
          aggregate: {
            args: Prisma.HpoTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHpoTerm>
          }
          groupBy: {
            args: Prisma.HpoTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<HpoTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.HpoTermCountArgs<ExtArgs>
            result: $Utils.Optional<HpoTermCountAggregateOutputType> | number
          }
        }
      }
      Translation: {
        payload: Prisma.$TranslationPayload<ExtArgs>
        fields: Prisma.TranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findFirst: {
            args: Prisma.TranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findMany: {
            args: Prisma.TranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          create: {
            args: Prisma.TranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          createMany: {
            args: Prisma.TranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          delete: {
            args: Prisma.TranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          update: {
            args: Prisma.TranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          deleteMany: {
            args: Prisma.TranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.TranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
      Validation: {
        payload: Prisma.$ValidationPayload<ExtArgs>
        fields: Prisma.ValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          findFirst: {
            args: Prisma.ValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          findMany: {
            args: Prisma.ValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>[]
          }
          create: {
            args: Prisma.ValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          createMany: {
            args: Prisma.ValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>[]
          }
          delete: {
            args: Prisma.ValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          update: {
            args: Prisma.ValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          deleteMany: {
            args: Prisma.ValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          aggregate: {
            args: Prisma.ValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidation>
          }
          groupBy: {
            args: Prisma.ValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValidationCountArgs<ExtArgs>
            result: $Utils.Optional<ValidationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      UserActivity: {
        payload: Prisma.$UserActivityPayload<ExtArgs>
        fields: Prisma.UserActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findFirst: {
            args: Prisma.UserActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          findMany: {
            args: Prisma.UserActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          create: {
            args: Prisma.UserActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          createMany: {
            args: Prisma.UserActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>[]
          }
          delete: {
            args: Prisma.UserActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          update: {
            args: Prisma.UserActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityPayload>
          }
          aggregate: {
            args: Prisma.UserActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivity>
          }
          groupBy: {
            args: Prisma.UserActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      ConflictReview: {
        payload: Prisma.$ConflictReviewPayload<ExtArgs>
        fields: Prisma.ConflictReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConflictReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConflictReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          findFirst: {
            args: Prisma.ConflictReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConflictReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          findMany: {
            args: Prisma.ConflictReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>[]
          }
          create: {
            args: Prisma.ConflictReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          createMany: {
            args: Prisma.ConflictReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConflictReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>[]
          }
          delete: {
            args: Prisma.ConflictReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          update: {
            args: Prisma.ConflictReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          deleteMany: {
            args: Prisma.ConflictReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConflictReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConflictReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflictReviewPayload>
          }
          aggregate: {
            args: Prisma.ConflictReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConflictReview>
          }
          groupBy: {
            args: Prisma.ConflictReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConflictReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConflictReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ConflictReviewCountAggregateOutputType> | number
          }
        }
      }
      CommitteeVote: {
        payload: Prisma.$CommitteeVotePayload<ExtArgs>
        fields: Prisma.CommitteeVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommitteeVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommitteeVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          findFirst: {
            args: Prisma.CommitteeVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommitteeVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          findMany: {
            args: Prisma.CommitteeVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>[]
          }
          create: {
            args: Prisma.CommitteeVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          createMany: {
            args: Prisma.CommitteeVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommitteeVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>[]
          }
          delete: {
            args: Prisma.CommitteeVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          update: {
            args: Prisma.CommitteeVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          deleteMany: {
            args: Prisma.CommitteeVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommitteeVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommitteeVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitteeVotePayload>
          }
          aggregate: {
            args: Prisma.CommitteeVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommitteeVote>
          }
          groupBy: {
            args: Prisma.CommitteeVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommitteeVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommitteeVoteCountArgs<ExtArgs>
            result: $Utils.Optional<CommitteeVoteCountAggregateOutputType> | number
          }
        }
      }
      Rejection: {
        payload: Prisma.$RejectionPayload<ExtArgs>
        fields: Prisma.RejectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RejectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RejectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          findFirst: {
            args: Prisma.RejectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RejectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          findMany: {
            args: Prisma.RejectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>[]
          }
          create: {
            args: Prisma.RejectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          createMany: {
            args: Prisma.RejectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RejectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>[]
          }
          delete: {
            args: Prisma.RejectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          update: {
            args: Prisma.RejectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          deleteMany: {
            args: Prisma.RejectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RejectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RejectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RejectionPayload>
          }
          aggregate: {
            args: Prisma.RejectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRejection>
          }
          groupBy: {
            args: Prisma.RejectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RejectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RejectionCountArgs<ExtArgs>
            result: $Utils.Optional<RejectionCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Strike: {
        payload: Prisma.$StrikePayload<ExtArgs>
        fields: Prisma.StrikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          findFirst: {
            args: Prisma.StrikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          findMany: {
            args: Prisma.StrikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>[]
          }
          create: {
            args: Prisma.StrikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          createMany: {
            args: Prisma.StrikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>[]
          }
          delete: {
            args: Prisma.StrikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          update: {
            args: Prisma.StrikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          deleteMany: {
            args: Prisma.StrikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrikePayload>
          }
          aggregate: {
            args: Prisma.StrikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrike>
          }
          groupBy: {
            args: Prisma.StrikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrikeCountArgs<ExtArgs>
            result: $Utils.Optional<StrikeCountAggregateOutputType> | number
          }
        }
      }
      SessionLog: {
        payload: Prisma.$SessionLogPayload<ExtArgs>
        fields: Prisma.SessionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          findFirst: {
            args: Prisma.SessionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          findMany: {
            args: Prisma.SessionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>[]
          }
          create: {
            args: Prisma.SessionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          createMany: {
            args: Prisma.SessionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>[]
          }
          delete: {
            args: Prisma.SessionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          update: {
            args: Prisma.SessionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          deleteMany: {
            args: Prisma.SessionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          aggregate: {
            args: Prisma.SessionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionLog>
          }
          groupBy: {
            args: Prisma.SessionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionLogCountArgs<ExtArgs>
            result: $Utils.Optional<SessionLogCountAggregateOutputType> | number
          }
        }
      }
      UserAnalytics: {
        payload: Prisma.$UserAnalyticsPayload<ExtArgs>
        fields: Prisma.UserAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.UserAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          findMany: {
            args: Prisma.UserAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          create: {
            args: Prisma.UserAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          createMany: {
            args: Prisma.UserAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.UserAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          update: {
            args: Prisma.UserAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.UserAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.UserAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAnalytics>
          }
          groupBy: {
            args: Prisma.UserAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<UserAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      ApiMetrics: {
        payload: Prisma.$ApiMetricsPayload<ExtArgs>
        fields: Prisma.ApiMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          findFirst: {
            args: Prisma.ApiMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          findMany: {
            args: Prisma.ApiMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>[]
          }
          create: {
            args: Prisma.ApiMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          createMany: {
            args: Prisma.ApiMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>[]
          }
          delete: {
            args: Prisma.ApiMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          update: {
            args: Prisma.ApiMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          deleteMany: {
            args: Prisma.ApiMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiMetricsPayload>
          }
          aggregate: {
            args: Prisma.ApiMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiMetrics>
          }
          groupBy: {
            args: Prisma.ApiMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<ApiMetricsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    translations: number
    validations: number
    comments: number
    badges: number
    activities: number
    conflictVotes: number
    rejectionsMade: number
    auditLogs: number
    syncLogs: number
    notificationsSent: number
    conflictsResolved: number
    strikes: number
    strikesGiven: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | UserCountOutputTypeCountTranslationsArgs
    validations?: boolean | UserCountOutputTypeCountValidationsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    conflictVotes?: boolean | UserCountOutputTypeCountConflictVotesArgs
    rejectionsMade?: boolean | UserCountOutputTypeCountRejectionsMadeArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    syncLogs?: boolean | UserCountOutputTypeCountSyncLogsArgs
    notificationsSent?: boolean | UserCountOutputTypeCountNotificationsSentArgs
    conflictsResolved?: boolean | UserCountOutputTypeCountConflictsResolvedArgs
    strikes?: boolean | UserCountOutputTypeCountStrikesArgs
    strikesGiven?: boolean | UserCountOutputTypeCountStrikesGivenArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConflictVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitteeVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRejectionsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RejectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConflictsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflictReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStrikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStrikesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLogWhereInput
  }


  /**
   * Count Type HpoTermCountOutputType
   */

  export type HpoTermCountOutputType = {
    translations: number
    children: number
    conflictReviews: number
  }

  export type HpoTermCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HpoTermCountOutputTypeCountTranslationsArgs
    children?: boolean | HpoTermCountOutputTypeCountChildrenArgs
    conflictReviews?: boolean | HpoTermCountOutputTypeCountConflictReviewsArgs
  }

  // Custom InputTypes
  /**
   * HpoTermCountOutputType without action
   */
  export type HpoTermCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTermCountOutputType
     */
    select?: HpoTermCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HpoTermCountOutputType without action
   */
  export type HpoTermCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }

  /**
   * HpoTermCountOutputType without action
   */
  export type HpoTermCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HpoTermWhereInput
  }

  /**
   * HpoTermCountOutputType without action
   */
  export type HpoTermCountOutputTypeCountConflictReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflictReviewWhereInput
  }


  /**
   * Count Type TranslationCountOutputType
   */

  export type TranslationCountOutputType = {
    validations: number
    comments: number
    strikes: number
    conflictReviews: number
    committeeVotes: number
  }

  export type TranslationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validations?: boolean | TranslationCountOutputTypeCountValidationsArgs
    comments?: boolean | TranslationCountOutputTypeCountCommentsArgs
    strikes?: boolean | TranslationCountOutputTypeCountStrikesArgs
    conflictReviews?: boolean | TranslationCountOutputTypeCountConflictReviewsArgs
    committeeVotes?: boolean | TranslationCountOutputTypeCountCommitteeVotesArgs
  }

  // Custom InputTypes
  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationCountOutputType
     */
    select?: TranslationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeCountValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationWhereInput
  }

  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeCountStrikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrikeWhereInput
  }

  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeCountConflictReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflictReviewWhereInput
  }

  /**
   * TranslationCountOutputType without action
   */
  export type TranslationCountOutputTypeCountCommitteeVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitteeVoteWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type ConflictReviewCountOutputType
   */

  export type ConflictReviewCountOutputType = {
    translations: number
    committeeVotes: number
  }

  export type ConflictReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | ConflictReviewCountOutputTypeCountTranslationsArgs
    committeeVotes?: boolean | ConflictReviewCountOutputTypeCountCommitteeVotesArgs
  }

  // Custom InputTypes
  /**
   * ConflictReviewCountOutputType without action
   */
  export type ConflictReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReviewCountOutputType
     */
    select?: ConflictReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConflictReviewCountOutputType without action
   */
  export type ConflictReviewCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }

  /**
   * ConflictReviewCountOutputType without action
   */
  export type ConflictReviewCountOutputTypeCountCommitteeVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitteeVoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
    level: number | null
    streak: number | null
    approvedCount: number | null
    warningCount: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
    level: number | null
    streak: number | null
    approvedCount: number | null
    warningCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    username: string | null
    password: string | null
    orcidId: string | null
    role: $Enums.UserRole | null
    institution: string | null
    specialty: string | null
    country: string | null
    bio: string | null
    avatarUrl: string | null
    points: number | null
    level: number | null
    streak: number | null
    lastActiveAt: Date | null
    lastLoginAt: Date | null
    approvedCount: number | null
    hasCompletedOnboarding: boolean | null
    warningCount: number | null
    lastWarningAt: Date | null
    bannedBy: string | null
    promotedAt: Date | null
    isActive: boolean | null
    isBanned: boolean | null
    bannedAt: Date | null
    bannedReason: string | null
    isVerified: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    username: string | null
    password: string | null
    orcidId: string | null
    role: $Enums.UserRole | null
    institution: string | null
    specialty: string | null
    country: string | null
    bio: string | null
    avatarUrl: string | null
    points: number | null
    level: number | null
    streak: number | null
    lastActiveAt: Date | null
    lastLoginAt: Date | null
    approvedCount: number | null
    hasCompletedOnboarding: boolean | null
    warningCount: number | null
    lastWarningAt: Date | null
    bannedBy: string | null
    promotedAt: Date | null
    isActive: boolean | null
    isBanned: boolean | null
    bannedAt: Date | null
    bannedReason: string | null
    isVerified: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    username: number
    password: number
    orcidId: number
    role: number
    institution: number
    specialty: number
    country: number
    bio: number
    avatarUrl: number
    profileJson: number
    points: number
    level: number
    streak: number
    lastActiveAt: number
    lastLoginAt: number
    approvedCount: number
    hasCompletedOnboarding: number
    warningCount: number
    lastWarningAt: number
    bannedBy: number
    promotedAt: number
    isActive: number
    isBanned: number
    bannedAt: number
    bannedReason: number
    isVerified: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
    level?: true
    streak?: true
    approvedCount?: true
    warningCount?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
    level?: true
    streak?: true
    approvedCount?: true
    warningCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    password?: true
    orcidId?: true
    role?: true
    institution?: true
    specialty?: true
    country?: true
    bio?: true
    avatarUrl?: true
    points?: true
    level?: true
    streak?: true
    lastActiveAt?: true
    lastLoginAt?: true
    approvedCount?: true
    hasCompletedOnboarding?: true
    warningCount?: true
    lastWarningAt?: true
    bannedBy?: true
    promotedAt?: true
    isActive?: true
    isBanned?: true
    bannedAt?: true
    bannedReason?: true
    isVerified?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    password?: true
    orcidId?: true
    role?: true
    institution?: true
    specialty?: true
    country?: true
    bio?: true
    avatarUrl?: true
    points?: true
    level?: true
    streak?: true
    lastActiveAt?: true
    lastLoginAt?: true
    approvedCount?: true
    hasCompletedOnboarding?: true
    warningCount?: true
    lastWarningAt?: true
    bannedBy?: true
    promotedAt?: true
    isActive?: true
    isBanned?: true
    bannedAt?: true
    bannedReason?: true
    isVerified?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    password?: true
    orcidId?: true
    role?: true
    institution?: true
    specialty?: true
    country?: true
    bio?: true
    avatarUrl?: true
    profileJson?: true
    points?: true
    level?: true
    streak?: true
    lastActiveAt?: true
    lastLoginAt?: true
    approvedCount?: true
    hasCompletedOnboarding?: true
    warningCount?: true
    lastWarningAt?: true
    bannedBy?: true
    promotedAt?: true
    isActive?: true
    isBanned?: true
    bannedAt?: true
    bannedReason?: true
    isVerified?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    username: string | null
    password: string | null
    orcidId: string | null
    role: $Enums.UserRole
    institution: string | null
    specialty: string | null
    country: string | null
    bio: string | null
    avatarUrl: string | null
    profileJson: JsonValue | null
    points: number
    level: number
    streak: number
    lastActiveAt: Date | null
    lastLoginAt: Date | null
    approvedCount: number
    hasCompletedOnboarding: boolean
    warningCount: number
    lastWarningAt: Date | null
    bannedBy: string | null
    promotedAt: Date | null
    isActive: boolean
    isBanned: boolean
    bannedAt: Date | null
    bannedReason: string | null
    isVerified: boolean
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    orcidId?: boolean
    role?: boolean
    institution?: boolean
    specialty?: boolean
    country?: boolean
    bio?: boolean
    avatarUrl?: boolean
    profileJson?: boolean
    points?: boolean
    level?: boolean
    streak?: boolean
    lastActiveAt?: boolean
    lastLoginAt?: boolean
    approvedCount?: boolean
    hasCompletedOnboarding?: boolean
    warningCount?: boolean
    lastWarningAt?: boolean
    bannedBy?: boolean
    promotedAt?: boolean
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    bannedReason?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | User$translationsArgs<ExtArgs>
    validations?: boolean | User$validationsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    conflictVotes?: boolean | User$conflictVotesArgs<ExtArgs>
    rejectionsMade?: boolean | User$rejectionsMadeArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    syncLogs?: boolean | User$syncLogsArgs<ExtArgs>
    notificationsSent?: boolean | User$notificationsSentArgs<ExtArgs>
    conflictsResolved?: boolean | User$conflictsResolvedArgs<ExtArgs>
    strikes?: boolean | User$strikesArgs<ExtArgs>
    strikesGiven?: boolean | User$strikesGivenArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    orcidId?: boolean
    role?: boolean
    institution?: boolean
    specialty?: boolean
    country?: boolean
    bio?: boolean
    avatarUrl?: boolean
    profileJson?: boolean
    points?: boolean
    level?: boolean
    streak?: boolean
    lastActiveAt?: boolean
    lastLoginAt?: boolean
    approvedCount?: boolean
    hasCompletedOnboarding?: boolean
    warningCount?: boolean
    lastWarningAt?: boolean
    bannedBy?: boolean
    promotedAt?: boolean
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    bannedReason?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    password?: boolean
    orcidId?: boolean
    role?: boolean
    institution?: boolean
    specialty?: boolean
    country?: boolean
    bio?: boolean
    avatarUrl?: boolean
    profileJson?: boolean
    points?: boolean
    level?: boolean
    streak?: boolean
    lastActiveAt?: boolean
    lastLoginAt?: boolean
    approvedCount?: boolean
    hasCompletedOnboarding?: boolean
    warningCount?: boolean
    lastWarningAt?: boolean
    bannedBy?: boolean
    promotedAt?: boolean
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    bannedReason?: boolean
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | User$translationsArgs<ExtArgs>
    validations?: boolean | User$validationsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    conflictVotes?: boolean | User$conflictVotesArgs<ExtArgs>
    rejectionsMade?: boolean | User$rejectionsMadeArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    syncLogs?: boolean | User$syncLogsArgs<ExtArgs>
    notificationsSent?: boolean | User$notificationsSentArgs<ExtArgs>
    conflictsResolved?: boolean | User$conflictsResolvedArgs<ExtArgs>
    strikes?: boolean | User$strikesArgs<ExtArgs>
    strikesGiven?: boolean | User$strikesGivenArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      translations: Prisma.$TranslationPayload<ExtArgs>[]
      validations: Prisma.$ValidationPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      activities: Prisma.$UserActivityPayload<ExtArgs>[]
      conflictVotes: Prisma.$CommitteeVotePayload<ExtArgs>[]
      rejectionsMade: Prisma.$RejectionPayload<ExtArgs>[]
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      syncLogs: Prisma.$SyncLogPayload<ExtArgs>[]
      notificationsSent: Prisma.$NotificationPayload<ExtArgs>[]
      conflictsResolved: Prisma.$ConflictReviewPayload<ExtArgs>[]
      strikes: Prisma.$StrikePayload<ExtArgs>[]
      strikesGiven: Prisma.$StrikePayload<ExtArgs>[]
      sessions: Prisma.$SessionLogPayload<ExtArgs>[]
      analytics: Prisma.$UserAnalyticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      username: string | null
      password: string | null
      orcidId: string | null
      role: $Enums.UserRole
      institution: string | null
      specialty: string | null
      country: string | null
      bio: string | null
      avatarUrl: string | null
      profileJson: Prisma.JsonValue | null
      points: number
      level: number
      streak: number
      lastActiveAt: Date | null
      lastLoginAt: Date | null
      approvedCount: number
      hasCompletedOnboarding: boolean
      warningCount: number
      lastWarningAt: Date | null
      bannedBy: string | null
      promotedAt: Date | null
      isActive: boolean
      isBanned: boolean
      bannedAt: Date | null
      bannedReason: string | null
      isVerified: boolean
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends User$translationsArgs<ExtArgs> = {}>(args?: Subset<T, User$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    validations<T extends User$validationsArgs<ExtArgs> = {}>(args?: Subset<T, User$validationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany"> | Null>
    conflictVotes<T extends User$conflictVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$conflictVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findMany"> | Null>
    rejectionsMade<T extends User$rejectionsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$rejectionsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    syncLogs<T extends User$syncLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$syncLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany"> | Null>
    notificationsSent<T extends User$notificationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    conflictsResolved<T extends User$conflictsResolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$conflictsResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findMany"> | Null>
    strikes<T extends User$strikesArgs<ExtArgs> = {}>(args?: Subset<T, User$strikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findMany"> | Null>
    strikesGiven<T extends User$strikesGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$strikesGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends User$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly orcidId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly institution: FieldRef<"User", 'String'>
    readonly specialty: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly profileJson: FieldRef<"User", 'Json'>
    readonly points: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'Int'>
    readonly streak: FieldRef<"User", 'Int'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly approvedCount: FieldRef<"User", 'Int'>
    readonly hasCompletedOnboarding: FieldRef<"User", 'Boolean'>
    readonly warningCount: FieldRef<"User", 'Int'>
    readonly lastWarningAt: FieldRef<"User", 'DateTime'>
    readonly bannedBy: FieldRef<"User", 'String'>
    readonly promotedAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly bannedAt: FieldRef<"User", 'DateTime'>
    readonly bannedReason: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.translations
   */
  export type User$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * User.validations
   */
  export type User$validationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    where?: ValidationWhereInput
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    cursor?: ValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    cursor?: UserActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * User.conflictVotes
   */
  export type User$conflictVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    where?: CommitteeVoteWhereInput
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    cursor?: CommitteeVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * User.rejectionsMade
   */
  export type User$rejectionsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    where?: RejectionWhereInput
    orderBy?: RejectionOrderByWithRelationInput | RejectionOrderByWithRelationInput[]
    cursor?: RejectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RejectionScalarFieldEnum | RejectionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * User.syncLogs
   */
  export type User$syncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    cursor?: SyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * User.notificationsSent
   */
  export type User$notificationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.conflictsResolved
   */
  export type User$conflictsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    where?: ConflictReviewWhereInput
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    cursor?: ConflictReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * User.strikes
   */
  export type User$strikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    where?: StrikeWhereInput
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    cursor?: StrikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * User.strikesGiven
   */
  export type User$strikesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    where?: StrikeWhereInput
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    cursor?: StrikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    where?: SessionLogWhereInput
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    cursor?: SessionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * User.analytics
   */
  export type User$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    where?: UserAnalyticsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model HpoTerm
   */

  export type AggregateHpoTerm = {
    _count: HpoTermCountAggregateOutputType | null
    _avg: HpoTermAvgAggregateOutputType | null
    _sum: HpoTermSumAggregateOutputType | null
    _min: HpoTermMinAggregateOutputType | null
    _max: HpoTermMaxAggregateOutputType | null
  }

  export type HpoTermAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type HpoTermSumAggregateOutputType = {
    difficulty: number | null
  }

  export type HpoTermMinAggregateOutputType = {
    id: string | null
    hpoId: string | null
    labelEn: string | null
    definitionEn: string | null
    category: string | null
    parentId: string | null
    difficulty: number | null
    translationStatus: $Enums.TranslationStatus | null
    hpoVersion: string | null
    isObsolete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HpoTermMaxAggregateOutputType = {
    id: string | null
    hpoId: string | null
    labelEn: string | null
    definitionEn: string | null
    category: string | null
    parentId: string | null
    difficulty: number | null
    translationStatus: $Enums.TranslationStatus | null
    hpoVersion: string | null
    isObsolete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HpoTermCountAggregateOutputType = {
    id: number
    hpoId: number
    labelEn: number
    definitionEn: number
    synonymsEn: number
    category: number
    parentId: number
    difficulty: number
    translationStatus: number
    hpoVersion: number
    isObsolete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HpoTermAvgAggregateInputType = {
    difficulty?: true
  }

  export type HpoTermSumAggregateInputType = {
    difficulty?: true
  }

  export type HpoTermMinAggregateInputType = {
    id?: true
    hpoId?: true
    labelEn?: true
    definitionEn?: true
    category?: true
    parentId?: true
    difficulty?: true
    translationStatus?: true
    hpoVersion?: true
    isObsolete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HpoTermMaxAggregateInputType = {
    id?: true
    hpoId?: true
    labelEn?: true
    definitionEn?: true
    category?: true
    parentId?: true
    difficulty?: true
    translationStatus?: true
    hpoVersion?: true
    isObsolete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HpoTermCountAggregateInputType = {
    id?: true
    hpoId?: true
    labelEn?: true
    definitionEn?: true
    synonymsEn?: true
    category?: true
    parentId?: true
    difficulty?: true
    translationStatus?: true
    hpoVersion?: true
    isObsolete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HpoTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HpoTerm to aggregate.
     */
    where?: HpoTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HpoTerms to fetch.
     */
    orderBy?: HpoTermOrderByWithRelationInput | HpoTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HpoTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HpoTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HpoTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HpoTerms
    **/
    _count?: true | HpoTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HpoTermAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HpoTermSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HpoTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HpoTermMaxAggregateInputType
  }

  export type GetHpoTermAggregateType<T extends HpoTermAggregateArgs> = {
        [P in keyof T & keyof AggregateHpoTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHpoTerm[P]>
      : GetScalarType<T[P], AggregateHpoTerm[P]>
  }




  export type HpoTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HpoTermWhereInput
    orderBy?: HpoTermOrderByWithAggregationInput | HpoTermOrderByWithAggregationInput[]
    by: HpoTermScalarFieldEnum[] | HpoTermScalarFieldEnum
    having?: HpoTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HpoTermCountAggregateInputType | true
    _avg?: HpoTermAvgAggregateInputType
    _sum?: HpoTermSumAggregateInputType
    _min?: HpoTermMinAggregateInputType
    _max?: HpoTermMaxAggregateInputType
  }

  export type HpoTermGroupByOutputType = {
    id: string
    hpoId: string
    labelEn: string
    definitionEn: string | null
    synonymsEn: string[]
    category: string | null
    parentId: string | null
    difficulty: number
    translationStatus: $Enums.TranslationStatus
    hpoVersion: string | null
    isObsolete: boolean
    createdAt: Date
    updatedAt: Date
    _count: HpoTermCountAggregateOutputType | null
    _avg: HpoTermAvgAggregateOutputType | null
    _sum: HpoTermSumAggregateOutputType | null
    _min: HpoTermMinAggregateOutputType | null
    _max: HpoTermMaxAggregateOutputType | null
  }

  type GetHpoTermGroupByPayload<T extends HpoTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HpoTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HpoTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HpoTermGroupByOutputType[P]>
            : GetScalarType<T[P], HpoTermGroupByOutputType[P]>
        }
      >
    >


  export type HpoTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hpoId?: boolean
    labelEn?: boolean
    definitionEn?: boolean
    synonymsEn?: boolean
    category?: boolean
    parentId?: boolean
    difficulty?: boolean
    translationStatus?: boolean
    hpoVersion?: boolean
    isObsolete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | HpoTerm$translationsArgs<ExtArgs>
    parent?: boolean | HpoTerm$parentArgs<ExtArgs>
    children?: boolean | HpoTerm$childrenArgs<ExtArgs>
    conflictReviews?: boolean | HpoTerm$conflictReviewsArgs<ExtArgs>
    _count?: boolean | HpoTermCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hpoTerm"]>

  export type HpoTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hpoId?: boolean
    labelEn?: boolean
    definitionEn?: boolean
    synonymsEn?: boolean
    category?: boolean
    parentId?: boolean
    difficulty?: boolean
    translationStatus?: boolean
    hpoVersion?: boolean
    isObsolete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | HpoTerm$parentArgs<ExtArgs>
  }, ExtArgs["result"]["hpoTerm"]>

  export type HpoTermSelectScalar = {
    id?: boolean
    hpoId?: boolean
    labelEn?: boolean
    definitionEn?: boolean
    synonymsEn?: boolean
    category?: boolean
    parentId?: boolean
    difficulty?: boolean
    translationStatus?: boolean
    hpoVersion?: boolean
    isObsolete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HpoTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HpoTerm$translationsArgs<ExtArgs>
    parent?: boolean | HpoTerm$parentArgs<ExtArgs>
    children?: boolean | HpoTerm$childrenArgs<ExtArgs>
    conflictReviews?: boolean | HpoTerm$conflictReviewsArgs<ExtArgs>
    _count?: boolean | HpoTermCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HpoTermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | HpoTerm$parentArgs<ExtArgs>
  }

  export type $HpoTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HpoTerm"
    objects: {
      translations: Prisma.$TranslationPayload<ExtArgs>[]
      parent: Prisma.$HpoTermPayload<ExtArgs> | null
      children: Prisma.$HpoTermPayload<ExtArgs>[]
      conflictReviews: Prisma.$ConflictReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hpoId: string
      labelEn: string
      definitionEn: string | null
      synonymsEn: string[]
      category: string | null
      parentId: string | null
      difficulty: number
      translationStatus: $Enums.TranslationStatus
      hpoVersion: string | null
      isObsolete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hpoTerm"]>
    composites: {}
  }

  type HpoTermGetPayload<S extends boolean | null | undefined | HpoTermDefaultArgs> = $Result.GetResult<Prisma.$HpoTermPayload, S>

  type HpoTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HpoTermFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HpoTermCountAggregateInputType | true
    }

  export interface HpoTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HpoTerm'], meta: { name: 'HpoTerm' } }
    /**
     * Find zero or one HpoTerm that matches the filter.
     * @param {HpoTermFindUniqueArgs} args - Arguments to find a HpoTerm
     * @example
     * // Get one HpoTerm
     * const hpoTerm = await prisma.hpoTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HpoTermFindUniqueArgs>(args: SelectSubset<T, HpoTermFindUniqueArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HpoTerm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HpoTermFindUniqueOrThrowArgs} args - Arguments to find a HpoTerm
     * @example
     * // Get one HpoTerm
     * const hpoTerm = await prisma.hpoTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HpoTermFindUniqueOrThrowArgs>(args: SelectSubset<T, HpoTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HpoTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermFindFirstArgs} args - Arguments to find a HpoTerm
     * @example
     * // Get one HpoTerm
     * const hpoTerm = await prisma.hpoTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HpoTermFindFirstArgs>(args?: SelectSubset<T, HpoTermFindFirstArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HpoTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermFindFirstOrThrowArgs} args - Arguments to find a HpoTerm
     * @example
     * // Get one HpoTerm
     * const hpoTerm = await prisma.hpoTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HpoTermFindFirstOrThrowArgs>(args?: SelectSubset<T, HpoTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HpoTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HpoTerms
     * const hpoTerms = await prisma.hpoTerm.findMany()
     * 
     * // Get first 10 HpoTerms
     * const hpoTerms = await prisma.hpoTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hpoTermWithIdOnly = await prisma.hpoTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HpoTermFindManyArgs>(args?: SelectSubset<T, HpoTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HpoTerm.
     * @param {HpoTermCreateArgs} args - Arguments to create a HpoTerm.
     * @example
     * // Create one HpoTerm
     * const HpoTerm = await prisma.hpoTerm.create({
     *   data: {
     *     // ... data to create a HpoTerm
     *   }
     * })
     * 
     */
    create<T extends HpoTermCreateArgs>(args: SelectSubset<T, HpoTermCreateArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HpoTerms.
     * @param {HpoTermCreateManyArgs} args - Arguments to create many HpoTerms.
     * @example
     * // Create many HpoTerms
     * const hpoTerm = await prisma.hpoTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HpoTermCreateManyArgs>(args?: SelectSubset<T, HpoTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HpoTerms and returns the data saved in the database.
     * @param {HpoTermCreateManyAndReturnArgs} args - Arguments to create many HpoTerms.
     * @example
     * // Create many HpoTerms
     * const hpoTerm = await prisma.hpoTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HpoTerms and only return the `id`
     * const hpoTermWithIdOnly = await prisma.hpoTerm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HpoTermCreateManyAndReturnArgs>(args?: SelectSubset<T, HpoTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HpoTerm.
     * @param {HpoTermDeleteArgs} args - Arguments to delete one HpoTerm.
     * @example
     * // Delete one HpoTerm
     * const HpoTerm = await prisma.hpoTerm.delete({
     *   where: {
     *     // ... filter to delete one HpoTerm
     *   }
     * })
     * 
     */
    delete<T extends HpoTermDeleteArgs>(args: SelectSubset<T, HpoTermDeleteArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HpoTerm.
     * @param {HpoTermUpdateArgs} args - Arguments to update one HpoTerm.
     * @example
     * // Update one HpoTerm
     * const hpoTerm = await prisma.hpoTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HpoTermUpdateArgs>(args: SelectSubset<T, HpoTermUpdateArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HpoTerms.
     * @param {HpoTermDeleteManyArgs} args - Arguments to filter HpoTerms to delete.
     * @example
     * // Delete a few HpoTerms
     * const { count } = await prisma.hpoTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HpoTermDeleteManyArgs>(args?: SelectSubset<T, HpoTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HpoTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HpoTerms
     * const hpoTerm = await prisma.hpoTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HpoTermUpdateManyArgs>(args: SelectSubset<T, HpoTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HpoTerm.
     * @param {HpoTermUpsertArgs} args - Arguments to update or create a HpoTerm.
     * @example
     * // Update or create a HpoTerm
     * const hpoTerm = await prisma.hpoTerm.upsert({
     *   create: {
     *     // ... data to create a HpoTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HpoTerm we want to update
     *   }
     * })
     */
    upsert<T extends HpoTermUpsertArgs>(args: SelectSubset<T, HpoTermUpsertArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HpoTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermCountArgs} args - Arguments to filter HpoTerms to count.
     * @example
     * // Count the number of HpoTerms
     * const count = await prisma.hpoTerm.count({
     *   where: {
     *     // ... the filter for the HpoTerms we want to count
     *   }
     * })
    **/
    count<T extends HpoTermCountArgs>(
      args?: Subset<T, HpoTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HpoTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HpoTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HpoTermAggregateArgs>(args: Subset<T, HpoTermAggregateArgs>): Prisma.PrismaPromise<GetHpoTermAggregateType<T>>

    /**
     * Group by HpoTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HpoTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HpoTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HpoTermGroupByArgs['orderBy'] }
        : { orderBy?: HpoTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HpoTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHpoTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HpoTerm model
   */
  readonly fields: HpoTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HpoTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HpoTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends HpoTerm$translationsArgs<ExtArgs> = {}>(args?: Subset<T, HpoTerm$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    parent<T extends HpoTerm$parentArgs<ExtArgs> = {}>(args?: Subset<T, HpoTerm$parentArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends HpoTerm$childrenArgs<ExtArgs> = {}>(args?: Subset<T, HpoTerm$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findMany"> | Null>
    conflictReviews<T extends HpoTerm$conflictReviewsArgs<ExtArgs> = {}>(args?: Subset<T, HpoTerm$conflictReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HpoTerm model
   */ 
  interface HpoTermFieldRefs {
    readonly id: FieldRef<"HpoTerm", 'String'>
    readonly hpoId: FieldRef<"HpoTerm", 'String'>
    readonly labelEn: FieldRef<"HpoTerm", 'String'>
    readonly definitionEn: FieldRef<"HpoTerm", 'String'>
    readonly synonymsEn: FieldRef<"HpoTerm", 'String[]'>
    readonly category: FieldRef<"HpoTerm", 'String'>
    readonly parentId: FieldRef<"HpoTerm", 'String'>
    readonly difficulty: FieldRef<"HpoTerm", 'Int'>
    readonly translationStatus: FieldRef<"HpoTerm", 'TranslationStatus'>
    readonly hpoVersion: FieldRef<"HpoTerm", 'String'>
    readonly isObsolete: FieldRef<"HpoTerm", 'Boolean'>
    readonly createdAt: FieldRef<"HpoTerm", 'DateTime'>
    readonly updatedAt: FieldRef<"HpoTerm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HpoTerm findUnique
   */
  export type HpoTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter, which HpoTerm to fetch.
     */
    where: HpoTermWhereUniqueInput
  }

  /**
   * HpoTerm findUniqueOrThrow
   */
  export type HpoTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter, which HpoTerm to fetch.
     */
    where: HpoTermWhereUniqueInput
  }

  /**
   * HpoTerm findFirst
   */
  export type HpoTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter, which HpoTerm to fetch.
     */
    where?: HpoTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HpoTerms to fetch.
     */
    orderBy?: HpoTermOrderByWithRelationInput | HpoTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HpoTerms.
     */
    cursor?: HpoTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HpoTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HpoTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HpoTerms.
     */
    distinct?: HpoTermScalarFieldEnum | HpoTermScalarFieldEnum[]
  }

  /**
   * HpoTerm findFirstOrThrow
   */
  export type HpoTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter, which HpoTerm to fetch.
     */
    where?: HpoTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HpoTerms to fetch.
     */
    orderBy?: HpoTermOrderByWithRelationInput | HpoTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HpoTerms.
     */
    cursor?: HpoTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HpoTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HpoTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HpoTerms.
     */
    distinct?: HpoTermScalarFieldEnum | HpoTermScalarFieldEnum[]
  }

  /**
   * HpoTerm findMany
   */
  export type HpoTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter, which HpoTerms to fetch.
     */
    where?: HpoTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HpoTerms to fetch.
     */
    orderBy?: HpoTermOrderByWithRelationInput | HpoTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HpoTerms.
     */
    cursor?: HpoTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HpoTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HpoTerms.
     */
    skip?: number
    distinct?: HpoTermScalarFieldEnum | HpoTermScalarFieldEnum[]
  }

  /**
   * HpoTerm create
   */
  export type HpoTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * The data needed to create a HpoTerm.
     */
    data: XOR<HpoTermCreateInput, HpoTermUncheckedCreateInput>
  }

  /**
   * HpoTerm createMany
   */
  export type HpoTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HpoTerms.
     */
    data: HpoTermCreateManyInput | HpoTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HpoTerm createManyAndReturn
   */
  export type HpoTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HpoTerms.
     */
    data: HpoTermCreateManyInput | HpoTermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HpoTerm update
   */
  export type HpoTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * The data needed to update a HpoTerm.
     */
    data: XOR<HpoTermUpdateInput, HpoTermUncheckedUpdateInput>
    /**
     * Choose, which HpoTerm to update.
     */
    where: HpoTermWhereUniqueInput
  }

  /**
   * HpoTerm updateMany
   */
  export type HpoTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HpoTerms.
     */
    data: XOR<HpoTermUpdateManyMutationInput, HpoTermUncheckedUpdateManyInput>
    /**
     * Filter which HpoTerms to update
     */
    where?: HpoTermWhereInput
  }

  /**
   * HpoTerm upsert
   */
  export type HpoTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * The filter to search for the HpoTerm to update in case it exists.
     */
    where: HpoTermWhereUniqueInput
    /**
     * In case the HpoTerm found by the `where` argument doesn't exist, create a new HpoTerm with this data.
     */
    create: XOR<HpoTermCreateInput, HpoTermUncheckedCreateInput>
    /**
     * In case the HpoTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HpoTermUpdateInput, HpoTermUncheckedUpdateInput>
  }

  /**
   * HpoTerm delete
   */
  export type HpoTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    /**
     * Filter which HpoTerm to delete.
     */
    where: HpoTermWhereUniqueInput
  }

  /**
   * HpoTerm deleteMany
   */
  export type HpoTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HpoTerms to delete
     */
    where?: HpoTermWhereInput
  }

  /**
   * HpoTerm.translations
   */
  export type HpoTerm$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * HpoTerm.parent
   */
  export type HpoTerm$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    where?: HpoTermWhereInput
  }

  /**
   * HpoTerm.children
   */
  export type HpoTerm$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
    where?: HpoTermWhereInput
    orderBy?: HpoTermOrderByWithRelationInput | HpoTermOrderByWithRelationInput[]
    cursor?: HpoTermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HpoTermScalarFieldEnum | HpoTermScalarFieldEnum[]
  }

  /**
   * HpoTerm.conflictReviews
   */
  export type HpoTerm$conflictReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    where?: ConflictReviewWhereInput
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    cursor?: ConflictReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * HpoTerm without action
   */
  export type HpoTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HpoTerm
     */
    select?: HpoTermSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HpoTermInclude<ExtArgs> | null
  }


  /**
   * Model Translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationAvgAggregateOutputType = {
    confidence: number | null
    aiConfidence: number | null
    approvalCount: number | null
    rejectionCount: number | null
    averageRating: number | null
  }

  export type TranslationSumAggregateOutputType = {
    confidence: number | null
    aiConfidence: number | null
    approvalCount: number | null
    rejectionCount: number | null
    averageRating: number | null
  }

  export type TranslationMinAggregateOutputType = {
    id: string | null
    termId: string | null
    userId: string | null
    labelPt: string | null
    definitionPt: string | null
    notes: string | null
    status: $Enums.TranslationStatus | null
    confidence: number | null
    source: $Enums.TranslationSource | null
    isLegacy: boolean | null
    aiSuggestion: string | null
    aiConfidence: number | null
    approvalCount: number | null
    rejectionCount: number | null
    averageRating: number | null
    syncedToHpo: boolean | null
    syncedAt: Date | null
    approvedBy: string | null
    rejectedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
  }

  export type TranslationMaxAggregateOutputType = {
    id: string | null
    termId: string | null
    userId: string | null
    labelPt: string | null
    definitionPt: string | null
    notes: string | null
    status: $Enums.TranslationStatus | null
    confidence: number | null
    source: $Enums.TranslationSource | null
    isLegacy: boolean | null
    aiSuggestion: string | null
    aiConfidence: number | null
    approvalCount: number | null
    rejectionCount: number | null
    averageRating: number | null
    syncedToHpo: boolean | null
    syncedAt: Date | null
    approvedBy: string | null
    rejectedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedAt: Date | null
  }

  export type TranslationCountAggregateOutputType = {
    id: number
    termId: number
    userId: number
    labelPt: number
    definitionPt: number
    synonymsPt: number
    notes: number
    status: number
    confidence: number
    source: number
    isLegacy: number
    aiSuggestion: number
    aiConfidence: number
    approvalCount: number
    rejectionCount: number
    averageRating: number
    syncedToHpo: number
    syncedAt: number
    approvedBy: number
    rejectedBy: number
    createdAt: number
    updatedAt: number
    approvedAt: number
    _all: number
  }


  export type TranslationAvgAggregateInputType = {
    confidence?: true
    aiConfidence?: true
    approvalCount?: true
    rejectionCount?: true
    averageRating?: true
  }

  export type TranslationSumAggregateInputType = {
    confidence?: true
    aiConfidence?: true
    approvalCount?: true
    rejectionCount?: true
    averageRating?: true
  }

  export type TranslationMinAggregateInputType = {
    id?: true
    termId?: true
    userId?: true
    labelPt?: true
    definitionPt?: true
    notes?: true
    status?: true
    confidence?: true
    source?: true
    isLegacy?: true
    aiSuggestion?: true
    aiConfidence?: true
    approvalCount?: true
    rejectionCount?: true
    averageRating?: true
    syncedToHpo?: true
    syncedAt?: true
    approvedBy?: true
    rejectedBy?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
  }

  export type TranslationMaxAggregateInputType = {
    id?: true
    termId?: true
    userId?: true
    labelPt?: true
    definitionPt?: true
    notes?: true
    status?: true
    confidence?: true
    source?: true
    isLegacy?: true
    aiSuggestion?: true
    aiConfidence?: true
    approvalCount?: true
    rejectionCount?: true
    averageRating?: true
    syncedToHpo?: true
    syncedAt?: true
    approvedBy?: true
    rejectedBy?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
  }

  export type TranslationCountAggregateInputType = {
    id?: true
    termId?: true
    userId?: true
    labelPt?: true
    definitionPt?: true
    synonymsPt?: true
    notes?: true
    status?: true
    confidence?: true
    source?: true
    isLegacy?: true
    aiSuggestion?: true
    aiConfidence?: true
    approvalCount?: true
    rejectionCount?: true
    averageRating?: true
    syncedToHpo?: true
    syncedAt?: true
    approvedBy?: true
    rejectedBy?: true
    createdAt?: true
    updatedAt?: true
    approvedAt?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translation to aggregate.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithAggregationInput | TranslationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: TranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _avg?: TranslationAvgAggregateInputType
    _sum?: TranslationSumAggregateInputType
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    id: string
    termId: string
    userId: string
    labelPt: string
    definitionPt: string | null
    synonymsPt: string[]
    notes: string | null
    status: $Enums.TranslationStatus
    confidence: number
    source: $Enums.TranslationSource
    isLegacy: boolean
    aiSuggestion: string | null
    aiConfidence: number | null
    approvalCount: number
    rejectionCount: number
    averageRating: number | null
    syncedToHpo: boolean
    syncedAt: Date | null
    approvedBy: string | null
    rejectedBy: string | null
    createdAt: Date
    updatedAt: Date
    approvedAt: Date | null
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type TranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    termId?: boolean
    userId?: boolean
    labelPt?: boolean
    definitionPt?: boolean
    synonymsPt?: boolean
    notes?: boolean
    status?: boolean
    confidence?: boolean
    source?: boolean
    isLegacy?: boolean
    aiSuggestion?: boolean
    aiConfidence?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    averageRating?: boolean
    syncedToHpo?: boolean
    syncedAt?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    term?: boolean | HpoTermDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    validations?: boolean | Translation$validationsArgs<ExtArgs>
    comments?: boolean | Translation$commentsArgs<ExtArgs>
    strikes?: boolean | Translation$strikesArgs<ExtArgs>
    rejection?: boolean | Translation$rejectionArgs<ExtArgs>
    conflictReviews?: boolean | Translation$conflictReviewsArgs<ExtArgs>
    committeeVotes?: boolean | Translation$committeeVotesArgs<ExtArgs>
    _count?: boolean | TranslationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    termId?: boolean
    userId?: boolean
    labelPt?: boolean
    definitionPt?: boolean
    synonymsPt?: boolean
    notes?: boolean
    status?: boolean
    confidence?: boolean
    source?: boolean
    isLegacy?: boolean
    aiSuggestion?: boolean
    aiConfidence?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    averageRating?: boolean
    syncedToHpo?: boolean
    syncedAt?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
    term?: boolean | HpoTermDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectScalar = {
    id?: boolean
    termId?: boolean
    userId?: boolean
    labelPt?: boolean
    definitionPt?: boolean
    synonymsPt?: boolean
    notes?: boolean
    status?: boolean
    confidence?: boolean
    source?: boolean
    isLegacy?: boolean
    aiSuggestion?: boolean
    aiConfidence?: boolean
    approvalCount?: boolean
    rejectionCount?: boolean
    averageRating?: boolean
    syncedToHpo?: boolean
    syncedAt?: boolean
    approvedBy?: boolean
    rejectedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedAt?: boolean
  }

  export type TranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    term?: boolean | HpoTermDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    validations?: boolean | Translation$validationsArgs<ExtArgs>
    comments?: boolean | Translation$commentsArgs<ExtArgs>
    strikes?: boolean | Translation$strikesArgs<ExtArgs>
    rejection?: boolean | Translation$rejectionArgs<ExtArgs>
    conflictReviews?: boolean | Translation$conflictReviewsArgs<ExtArgs>
    committeeVotes?: boolean | Translation$committeeVotesArgs<ExtArgs>
    _count?: boolean | TranslationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    term?: boolean | HpoTermDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Translation"
    objects: {
      term: Prisma.$HpoTermPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      validations: Prisma.$ValidationPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      strikes: Prisma.$StrikePayload<ExtArgs>[]
      rejection: Prisma.$RejectionPayload<ExtArgs> | null
      conflictReviews: Prisma.$ConflictReviewPayload<ExtArgs>[]
      committeeVotes: Prisma.$CommitteeVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      termId: string
      userId: string
      labelPt: string
      definitionPt: string | null
      synonymsPt: string[]
      notes: string | null
      status: $Enums.TranslationStatus
      confidence: number
      source: $Enums.TranslationSource
      isLegacy: boolean
      aiSuggestion: string | null
      aiConfidence: number | null
      approvalCount: number
      rejectionCount: number
      averageRating: number | null
      syncedToHpo: boolean
      syncedAt: Date | null
      approvedBy: string | null
      rejectedBy: string | null
      createdAt: Date
      updatedAt: Date
      approvedAt: Date | null
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type TranslationGetPayload<S extends boolean | null | undefined | TranslationDefaultArgs> = $Result.GetResult<Prisma.$TranslationPayload, S>

  type TranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface TranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Translation'], meta: { name: 'Translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {TranslationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationFindUniqueArgs>(args: SelectSubset<T, TranslationFindUniqueArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationFindFirstArgs>(args?: SelectSubset<T, TranslationFindFirstArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationWithIdOnly = await prisma.translation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationFindManyArgs>(args?: SelectSubset<T, TranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Translation.
     * @param {TranslationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends TranslationCreateArgs>(args: SelectSubset<T, TranslationCreateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Translations.
     * @param {TranslationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationCreateManyArgs>(args?: SelectSubset<T, TranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Translations and returns the data saved in the database.
     * @param {TranslationCreateManyAndReturnArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Translations and only return the `id`
     * const translationWithIdOnly = await prisma.translation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Translation.
     * @param {TranslationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends TranslationDeleteArgs>(args: SelectSubset<T, TranslationDeleteArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Translation.
     * @param {TranslationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationUpdateArgs>(args: SelectSubset<T, TranslationUpdateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Translations.
     * @param {TranslationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationDeleteManyArgs>(args?: SelectSubset<T, TranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationUpdateManyArgs>(args: SelectSubset<T, TranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {TranslationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends TranslationUpsertArgs>(args: SelectSubset<T, TranslationUpsertArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends TranslationCountArgs>(
      args?: Subset<T, TranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Translation model
   */
  readonly fields: TranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    term<T extends HpoTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HpoTermDefaultArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validations<T extends Translation$validationsArgs<ExtArgs> = {}>(args?: Subset<T, Translation$validationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Translation$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Translation$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    strikes<T extends Translation$strikesArgs<ExtArgs> = {}>(args?: Subset<T, Translation$strikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findMany"> | Null>
    rejection<T extends Translation$rejectionArgs<ExtArgs> = {}>(args?: Subset<T, Translation$rejectionArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    conflictReviews<T extends Translation$conflictReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Translation$conflictReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findMany"> | Null>
    committeeVotes<T extends Translation$committeeVotesArgs<ExtArgs> = {}>(args?: Subset<T, Translation$committeeVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Translation model
   */ 
  interface TranslationFieldRefs {
    readonly id: FieldRef<"Translation", 'String'>
    readonly termId: FieldRef<"Translation", 'String'>
    readonly userId: FieldRef<"Translation", 'String'>
    readonly labelPt: FieldRef<"Translation", 'String'>
    readonly definitionPt: FieldRef<"Translation", 'String'>
    readonly synonymsPt: FieldRef<"Translation", 'String[]'>
    readonly notes: FieldRef<"Translation", 'String'>
    readonly status: FieldRef<"Translation", 'TranslationStatus'>
    readonly confidence: FieldRef<"Translation", 'Int'>
    readonly source: FieldRef<"Translation", 'TranslationSource'>
    readonly isLegacy: FieldRef<"Translation", 'Boolean'>
    readonly aiSuggestion: FieldRef<"Translation", 'String'>
    readonly aiConfidence: FieldRef<"Translation", 'Float'>
    readonly approvalCount: FieldRef<"Translation", 'Int'>
    readonly rejectionCount: FieldRef<"Translation", 'Int'>
    readonly averageRating: FieldRef<"Translation", 'Float'>
    readonly syncedToHpo: FieldRef<"Translation", 'Boolean'>
    readonly syncedAt: FieldRef<"Translation", 'DateTime'>
    readonly approvedBy: FieldRef<"Translation", 'String'>
    readonly rejectedBy: FieldRef<"Translation", 'String'>
    readonly createdAt: FieldRef<"Translation", 'DateTime'>
    readonly updatedAt: FieldRef<"Translation", 'DateTime'>
    readonly approvedAt: FieldRef<"Translation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Translation findUnique
   */
  export type TranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findUniqueOrThrow
   */
  export type TranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findFirst
   */
  export type TranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findFirstOrThrow
   */
  export type TranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findMany
   */
  export type TranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translations to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation create
   */
  export type TranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a Translation.
     */
    data: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
  }

  /**
   * Translation createMany
   */
  export type TranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Translation createManyAndReturn
   */
  export type TranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Translation update
   */
  export type TranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a Translation.
     */
    data: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
    /**
     * Choose, which Translation to update.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation updateMany
   */
  export type TranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Translations.
     */
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyInput>
    /**
     * Filter which Translations to update
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation upsert
   */
  export type TranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the Translation to update in case it exists.
     */
    where: TranslationWhereUniqueInput
    /**
     * In case the Translation found by the `where` argument doesn't exist, create a new Translation with this data.
     */
    create: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
    /**
     * In case the Translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
  }

  /**
   * Translation delete
   */
  export type TranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter which Translation to delete.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation deleteMany
   */
  export type TranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translations to delete
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation.validations
   */
  export type Translation$validationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    where?: ValidationWhereInput
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    cursor?: ValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Translation.comments
   */
  export type Translation$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Translation.strikes
   */
  export type Translation$strikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    where?: StrikeWhereInput
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    cursor?: StrikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * Translation.rejection
   */
  export type Translation$rejectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    where?: RejectionWhereInput
  }

  /**
   * Translation.conflictReviews
   */
  export type Translation$conflictReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    where?: ConflictReviewWhereInput
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    cursor?: ConflictReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * Translation.committeeVotes
   */
  export type Translation$committeeVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    where?: CommitteeVoteWhereInput
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    cursor?: CommitteeVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * Translation without action
   */
  export type TranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
  }


  /**
   * Model Validation
   */

  export type AggregateValidation = {
    _count: ValidationCountAggregateOutputType | null
    _avg: ValidationAvgAggregateOutputType | null
    _sum: ValidationSumAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  export type ValidationAvgAggregateOutputType = {
    rating: number | null
    accuracyScore: number | null
    clarityScore: number | null
    consistencyScore: number | null
    timeSpentSeconds: number | null
  }

  export type ValidationSumAggregateOutputType = {
    rating: number | null
    accuracyScore: number | null
    clarityScore: number | null
    consistencyScore: number | null
    timeSpentSeconds: number | null
  }

  export type ValidationMinAggregateOutputType = {
    id: string | null
    translationId: string | null
    validatorId: string | null
    rating: number | null
    decision: $Enums.ValidationDecision | null
    comments: string | null
    suggestions: string | null
    accuracyScore: number | null
    clarityScore: number | null
    consistencyScore: number | null
    timeSpentSeconds: number | null
    createdAt: Date | null
  }

  export type ValidationMaxAggregateOutputType = {
    id: string | null
    translationId: string | null
    validatorId: string | null
    rating: number | null
    decision: $Enums.ValidationDecision | null
    comments: string | null
    suggestions: string | null
    accuracyScore: number | null
    clarityScore: number | null
    consistencyScore: number | null
    timeSpentSeconds: number | null
    createdAt: Date | null
  }

  export type ValidationCountAggregateOutputType = {
    id: number
    translationId: number
    validatorId: number
    rating: number
    decision: number
    comments: number
    suggestions: number
    accuracyScore: number
    clarityScore: number
    consistencyScore: number
    timeSpentSeconds: number
    createdAt: number
    _all: number
  }


  export type ValidationAvgAggregateInputType = {
    rating?: true
    accuracyScore?: true
    clarityScore?: true
    consistencyScore?: true
    timeSpentSeconds?: true
  }

  export type ValidationSumAggregateInputType = {
    rating?: true
    accuracyScore?: true
    clarityScore?: true
    consistencyScore?: true
    timeSpentSeconds?: true
  }

  export type ValidationMinAggregateInputType = {
    id?: true
    translationId?: true
    validatorId?: true
    rating?: true
    decision?: true
    comments?: true
    suggestions?: true
    accuracyScore?: true
    clarityScore?: true
    consistencyScore?: true
    timeSpentSeconds?: true
    createdAt?: true
  }

  export type ValidationMaxAggregateInputType = {
    id?: true
    translationId?: true
    validatorId?: true
    rating?: true
    decision?: true
    comments?: true
    suggestions?: true
    accuracyScore?: true
    clarityScore?: true
    consistencyScore?: true
    timeSpentSeconds?: true
    createdAt?: true
  }

  export type ValidationCountAggregateInputType = {
    id?: true
    translationId?: true
    validatorId?: true
    rating?: true
    decision?: true
    comments?: true
    suggestions?: true
    accuracyScore?: true
    clarityScore?: true
    consistencyScore?: true
    timeSpentSeconds?: true
    createdAt?: true
    _all?: true
  }

  export type ValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Validation to aggregate.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Validations
    **/
    _count?: true | ValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ValidationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ValidationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValidationMaxAggregateInputType
  }

  export type GetValidationAggregateType<T extends ValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidation[P]>
      : GetScalarType<T[P], AggregateValidation[P]>
  }




  export type ValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationWhereInput
    orderBy?: ValidationOrderByWithAggregationInput | ValidationOrderByWithAggregationInput[]
    by: ValidationScalarFieldEnum[] | ValidationScalarFieldEnum
    having?: ValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValidationCountAggregateInputType | true
    _avg?: ValidationAvgAggregateInputType
    _sum?: ValidationSumAggregateInputType
    _min?: ValidationMinAggregateInputType
    _max?: ValidationMaxAggregateInputType
  }

  export type ValidationGroupByOutputType = {
    id: string
    translationId: string
    validatorId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments: string | null
    suggestions: string | null
    accuracyScore: number | null
    clarityScore: number | null
    consistencyScore: number | null
    timeSpentSeconds: number | null
    createdAt: Date
    _count: ValidationCountAggregateOutputType | null
    _avg: ValidationAvgAggregateOutputType | null
    _sum: ValidationSumAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  type GetValidationGroupByPayload<T extends ValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValidationGroupByOutputType[P]>
            : GetScalarType<T[P], ValidationGroupByOutputType[P]>
        }
      >
    >


  export type ValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    validatorId?: boolean
    rating?: boolean
    decision?: boolean
    comments?: boolean
    suggestions?: boolean
    accuracyScore?: boolean
    clarityScore?: boolean
    consistencyScore?: boolean
    timeSpentSeconds?: boolean
    createdAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    validator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["validation"]>

  export type ValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    validatorId?: boolean
    rating?: boolean
    decision?: boolean
    comments?: boolean
    suggestions?: boolean
    accuracyScore?: boolean
    clarityScore?: boolean
    consistencyScore?: boolean
    timeSpentSeconds?: boolean
    createdAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    validator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["validation"]>

  export type ValidationSelectScalar = {
    id?: boolean
    translationId?: boolean
    validatorId?: boolean
    rating?: boolean
    decision?: boolean
    comments?: boolean
    suggestions?: boolean
    accuracyScore?: boolean
    clarityScore?: boolean
    consistencyScore?: boolean
    timeSpentSeconds?: boolean
    createdAt?: boolean
  }

  export type ValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    validator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ValidationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    validator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Validation"
    objects: {
      translation: Prisma.$TranslationPayload<ExtArgs>
      validator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      translationId: string
      validatorId: string
      rating: number
      decision: $Enums.ValidationDecision
      comments: string | null
      suggestions: string | null
      accuracyScore: number | null
      clarityScore: number | null
      consistencyScore: number | null
      timeSpentSeconds: number | null
      createdAt: Date
    }, ExtArgs["result"]["validation"]>
    composites: {}
  }

  type ValidationGetPayload<S extends boolean | null | undefined | ValidationDefaultArgs> = $Result.GetResult<Prisma.$ValidationPayload, S>

  type ValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ValidationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ValidationCountAggregateInputType | true
    }

  export interface ValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Validation'], meta: { name: 'Validation' } }
    /**
     * Find zero or one Validation that matches the filter.
     * @param {ValidationFindUniqueArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValidationFindUniqueArgs>(args: SelectSubset<T, ValidationFindUniqueArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Validation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ValidationFindUniqueOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, ValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Validation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindFirstArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValidationFindFirstArgs>(args?: SelectSubset<T, ValidationFindFirstArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Validation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindFirstOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, ValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Validations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Validations
     * const validations = await prisma.validation.findMany()
     * 
     * // Get first 10 Validations
     * const validations = await prisma.validation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validationWithIdOnly = await prisma.validation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ValidationFindManyArgs>(args?: SelectSubset<T, ValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Validation.
     * @param {ValidationCreateArgs} args - Arguments to create a Validation.
     * @example
     * // Create one Validation
     * const Validation = await prisma.validation.create({
     *   data: {
     *     // ... data to create a Validation
     *   }
     * })
     * 
     */
    create<T extends ValidationCreateArgs>(args: SelectSubset<T, ValidationCreateArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Validations.
     * @param {ValidationCreateManyArgs} args - Arguments to create many Validations.
     * @example
     * // Create many Validations
     * const validation = await prisma.validation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValidationCreateManyArgs>(args?: SelectSubset<T, ValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Validations and returns the data saved in the database.
     * @param {ValidationCreateManyAndReturnArgs} args - Arguments to create many Validations.
     * @example
     * // Create many Validations
     * const validation = await prisma.validation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Validations and only return the `id`
     * const validationWithIdOnly = await prisma.validation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, ValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Validation.
     * @param {ValidationDeleteArgs} args - Arguments to delete one Validation.
     * @example
     * // Delete one Validation
     * const Validation = await prisma.validation.delete({
     *   where: {
     *     // ... filter to delete one Validation
     *   }
     * })
     * 
     */
    delete<T extends ValidationDeleteArgs>(args: SelectSubset<T, ValidationDeleteArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Validation.
     * @param {ValidationUpdateArgs} args - Arguments to update one Validation.
     * @example
     * // Update one Validation
     * const validation = await prisma.validation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValidationUpdateArgs>(args: SelectSubset<T, ValidationUpdateArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Validations.
     * @param {ValidationDeleteManyArgs} args - Arguments to filter Validations to delete.
     * @example
     * // Delete a few Validations
     * const { count } = await prisma.validation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValidationDeleteManyArgs>(args?: SelectSubset<T, ValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Validations
     * const validation = await prisma.validation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValidationUpdateManyArgs>(args: SelectSubset<T, ValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Validation.
     * @param {ValidationUpsertArgs} args - Arguments to update or create a Validation.
     * @example
     * // Update or create a Validation
     * const validation = await prisma.validation.upsert({
     *   create: {
     *     // ... data to create a Validation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Validation we want to update
     *   }
     * })
     */
    upsert<T extends ValidationUpsertArgs>(args: SelectSubset<T, ValidationUpsertArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationCountArgs} args - Arguments to filter Validations to count.
     * @example
     * // Count the number of Validations
     * const count = await prisma.validation.count({
     *   where: {
     *     // ... the filter for the Validations we want to count
     *   }
     * })
    **/
    count<T extends ValidationCountArgs>(
      args?: Subset<T, ValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValidationAggregateArgs>(args: Subset<T, ValidationAggregateArgs>): Prisma.PrismaPromise<GetValidationAggregateType<T>>

    /**
     * Group by Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValidationGroupByArgs['orderBy'] }
        : { orderBy?: ValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Validation model
   */
  readonly fields: ValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Validation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translation<T extends TranslationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranslationDefaultArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Validation model
   */ 
  interface ValidationFieldRefs {
    readonly id: FieldRef<"Validation", 'String'>
    readonly translationId: FieldRef<"Validation", 'String'>
    readonly validatorId: FieldRef<"Validation", 'String'>
    readonly rating: FieldRef<"Validation", 'Int'>
    readonly decision: FieldRef<"Validation", 'ValidationDecision'>
    readonly comments: FieldRef<"Validation", 'String'>
    readonly suggestions: FieldRef<"Validation", 'String'>
    readonly accuracyScore: FieldRef<"Validation", 'Int'>
    readonly clarityScore: FieldRef<"Validation", 'Int'>
    readonly consistencyScore: FieldRef<"Validation", 'Int'>
    readonly timeSpentSeconds: FieldRef<"Validation", 'Int'>
    readonly createdAt: FieldRef<"Validation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Validation findUnique
   */
  export type ValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation findUniqueOrThrow
   */
  export type ValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation findFirst
   */
  export type ValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation findFirstOrThrow
   */
  export type ValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation findMany
   */
  export type ValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validations to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation create
   */
  export type ValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The data needed to create a Validation.
     */
    data: XOR<ValidationCreateInput, ValidationUncheckedCreateInput>
  }

  /**
   * Validation createMany
   */
  export type ValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Validations.
     */
    data: ValidationCreateManyInput | ValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Validation createManyAndReturn
   */
  export type ValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Validations.
     */
    data: ValidationCreateManyInput | ValidationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Validation update
   */
  export type ValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The data needed to update a Validation.
     */
    data: XOR<ValidationUpdateInput, ValidationUncheckedUpdateInput>
    /**
     * Choose, which Validation to update.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation updateMany
   */
  export type ValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Validations.
     */
    data: XOR<ValidationUpdateManyMutationInput, ValidationUncheckedUpdateManyInput>
    /**
     * Filter which Validations to update
     */
    where?: ValidationWhereInput
  }

  /**
   * Validation upsert
   */
  export type ValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The filter to search for the Validation to update in case it exists.
     */
    where: ValidationWhereUniqueInput
    /**
     * In case the Validation found by the `where` argument doesn't exist, create a new Validation with this data.
     */
    create: XOR<ValidationCreateInput, ValidationUncheckedCreateInput>
    /**
     * In case the Validation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValidationUpdateInput, ValidationUncheckedUpdateInput>
  }

  /**
   * Validation delete
   */
  export type ValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter which Validation to delete.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation deleteMany
   */
  export type ValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Validations to delete
     */
    where?: ValidationWhereInput
  }

  /**
   * Validation without action
   */
  export type ValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    translationId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    translationId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    translationId: number
    userId: number
    content: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    translationId?: true
    userId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    translationId?: true
    userId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    translationId?: true
    userId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    translationId: string
    userId: string
    content: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    translationId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      translation: Prisma.$TranslationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      translationId: string
      userId: string
      content: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translation<T extends TranslationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranslationDefaultArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly translationId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    points: number | null
  }

  export type BadgeSumAggregateOutputType = {
    points: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    points: number | null
    rarity: $Enums.BadgeRarity | null
    createdAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    points: number | null
    rarity: $Enums.BadgeRarity | null
    createdAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    iconUrl: number
    points: number
    rarity: number
    createdAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    points?: true
  }

  export type BadgeSumAggregateInputType = {
    points?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    points?: true
    rarity?: true
    createdAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    points?: true
    rarity?: true
    createdAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    points?: true
    rarity?: true
    createdAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string
    iconUrl: string | null
    points: number
    rarity: $Enums.BadgeRarity
    createdAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    points?: boolean
    rarity?: boolean
    createdAt?: boolean
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    points?: boolean
    rarity?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    points?: boolean
    rarity?: boolean
    createdAt?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string
      iconUrl: string | null
      points: number
      rarity: $Enums.BadgeRarity
      createdAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly code: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly iconUrl: FieldRef<"Badge", 'String'>
    readonly points: FieldRef<"Badge", 'Int'>
    readonly rarity: FieldRef<"Badge", 'BadgeRarity'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    earnedAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    earnedAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      earnedAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserActivity
   */

  export type AggregateUserActivity = {
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  export type UserActivityAvgAggregateOutputType = {
    points: number | null
  }

  export type UserActivitySumAggregateOutputType = {
    points: number | null
  }

  export type UserActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    points: number | null
    createdAt: Date | null
  }

  export type UserActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    points: number | null
    createdAt: Date | null
  }

  export type UserActivityCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    points: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UserActivityAvgAggregateInputType = {
    points?: true
  }

  export type UserActivitySumAggregateInputType = {
    points?: true
  }

  export type UserActivityMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    points?: true
    createdAt?: true
  }

  export type UserActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    points?: true
    createdAt?: true
  }

  export type UserActivityCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    points?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UserActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivity to aggregate.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivities
    **/
    _count?: true | UserActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityMaxAggregateInputType
  }

  export type GetUserActivityAggregateType<T extends UserActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivity[P]>
      : GetScalarType<T[P], AggregateUserActivity[P]>
  }




  export type UserActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityWhereInput
    orderBy?: UserActivityOrderByWithAggregationInput | UserActivityOrderByWithAggregationInput[]
    by: UserActivityScalarFieldEnum[] | UserActivityScalarFieldEnum
    having?: UserActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityCountAggregateInputType | true
    _avg?: UserActivityAvgAggregateInputType
    _sum?: UserActivitySumAggregateInputType
    _min?: UserActivityMinAggregateInputType
    _max?: UserActivityMaxAggregateInputType
  }

  export type UserActivityGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ActivityType
    points: number
    metadata: JsonValue | null
    createdAt: Date
    _count: UserActivityCountAggregateOutputType | null
    _avg: UserActivityAvgAggregateOutputType | null
    _sum: UserActivitySumAggregateOutputType | null
    _min: UserActivityMinAggregateOutputType | null
    _max: UserActivityMaxAggregateOutputType | null
  }

  type GetUserActivityGroupByPayload<T extends UserActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityGroupByOutputType[P]>
        }
      >
    >


  export type UserActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    points?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    points?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivity"]>

  export type UserActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    points?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UserActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ActivityType
      points: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["userActivity"]>
    composites: {}
  }

  type UserActivityGetPayload<S extends boolean | null | undefined | UserActivityDefaultArgs> = $Result.GetResult<Prisma.$UserActivityPayload, S>

  type UserActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserActivityCountAggregateInputType | true
    }

  export interface UserActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivity'], meta: { name: 'UserActivity' } }
    /**
     * Find zero or one UserActivity that matches the filter.
     * @param {UserActivityFindUniqueArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityFindUniqueArgs>(args: SelectSubset<T, UserActivityFindUniqueArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserActivityFindUniqueOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityFindFirstArgs>(args?: SelectSubset<T, UserActivityFindFirstArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindFirstOrThrowArgs} args - Arguments to find a UserActivity
     * @example
     * // Get one UserActivity
     * const userActivity = await prisma.userActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivities
     * const userActivities = await prisma.userActivity.findMany()
     * 
     * // Get first 10 UserActivities
     * const userActivities = await prisma.userActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivityFindManyArgs>(args?: SelectSubset<T, UserActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserActivity.
     * @param {UserActivityCreateArgs} args - Arguments to create a UserActivity.
     * @example
     * // Create one UserActivity
     * const UserActivity = await prisma.userActivity.create({
     *   data: {
     *     // ... data to create a UserActivity
     *   }
     * })
     * 
     */
    create<T extends UserActivityCreateArgs>(args: SelectSubset<T, UserActivityCreateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserActivities.
     * @param {UserActivityCreateManyArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityCreateManyArgs>(args?: SelectSubset<T, UserActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivities and returns the data saved in the database.
     * @param {UserActivityCreateManyAndReturnArgs} args - Arguments to create many UserActivities.
     * @example
     * // Create many UserActivities
     * const userActivity = await prisma.userActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivities and only return the `id`
     * const userActivityWithIdOnly = await prisma.userActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserActivity.
     * @param {UserActivityDeleteArgs} args - Arguments to delete one UserActivity.
     * @example
     * // Delete one UserActivity
     * const UserActivity = await prisma.userActivity.delete({
     *   where: {
     *     // ... filter to delete one UserActivity
     *   }
     * })
     * 
     */
    delete<T extends UserActivityDeleteArgs>(args: SelectSubset<T, UserActivityDeleteArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserActivity.
     * @param {UserActivityUpdateArgs} args - Arguments to update one UserActivity.
     * @example
     * // Update one UserActivity
     * const userActivity = await prisma.userActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityUpdateArgs>(args: SelectSubset<T, UserActivityUpdateArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserActivities.
     * @param {UserActivityDeleteManyArgs} args - Arguments to filter UserActivities to delete.
     * @example
     * // Delete a few UserActivities
     * const { count } = await prisma.userActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityDeleteManyArgs>(args?: SelectSubset<T, UserActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivities
     * const userActivity = await prisma.userActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityUpdateManyArgs>(args: SelectSubset<T, UserActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActivity.
     * @param {UserActivityUpsertArgs} args - Arguments to update or create a UserActivity.
     * @example
     * // Update or create a UserActivity
     * const userActivity = await prisma.userActivity.upsert({
     *   create: {
     *     // ... data to create a UserActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivity we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityUpsertArgs>(args: SelectSubset<T, UserActivityUpsertArgs<ExtArgs>>): Prisma__UserActivityClient<$Result.GetResult<Prisma.$UserActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityCountArgs} args - Arguments to filter UserActivities to count.
     * @example
     * // Count the number of UserActivities
     * const count = await prisma.userActivity.count({
     *   where: {
     *     // ... the filter for the UserActivities we want to count
     *   }
     * })
    **/
    count<T extends UserActivityCountArgs>(
      args?: Subset<T, UserActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityAggregateArgs>(args: Subset<T, UserActivityAggregateArgs>): Prisma.PrismaPromise<GetUserActivityAggregateType<T>>

    /**
     * Group by UserActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivity model
   */
  readonly fields: UserActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivity model
   */ 
  interface UserActivityFieldRefs {
    readonly id: FieldRef<"UserActivity", 'String'>
    readonly userId: FieldRef<"UserActivity", 'String'>
    readonly type: FieldRef<"UserActivity", 'ActivityType'>
    readonly points: FieldRef<"UserActivity", 'Int'>
    readonly metadata: FieldRef<"UserActivity", 'Json'>
    readonly createdAt: FieldRef<"UserActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivity findUnique
   */
  export type UserActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findUniqueOrThrow
   */
  export type UserActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity findFirst
   */
  export type UserActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findFirstOrThrow
   */
  export type UserActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivity to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivities.
     */
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity findMany
   */
  export type UserActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter, which UserActivities to fetch.
     */
    where?: UserActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivities to fetch.
     */
    orderBy?: UserActivityOrderByWithRelationInput | UserActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivities.
     */
    cursor?: UserActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivities.
     */
    skip?: number
    distinct?: UserActivityScalarFieldEnum | UserActivityScalarFieldEnum[]
  }

  /**
   * UserActivity create
   */
  export type UserActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a UserActivity.
     */
    data: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
  }

  /**
   * UserActivity createMany
   */
  export type UserActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivity createManyAndReturn
   */
  export type UserActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserActivities.
     */
    data: UserActivityCreateManyInput | UserActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivity update
   */
  export type UserActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a UserActivity.
     */
    data: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
    /**
     * Choose, which UserActivity to update.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity updateMany
   */
  export type UserActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivities.
     */
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyInput>
    /**
     * Filter which UserActivities to update
     */
    where?: UserActivityWhereInput
  }

  /**
   * UserActivity upsert
   */
  export type UserActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the UserActivity to update in case it exists.
     */
    where: UserActivityWhereUniqueInput
    /**
     * In case the UserActivity found by the `where` argument doesn't exist, create a new UserActivity with this data.
     */
    create: XOR<UserActivityCreateInput, UserActivityUncheckedCreateInput>
    /**
     * In case the UserActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityUpdateInput, UserActivityUncheckedUpdateInput>
  }

  /**
   * UserActivity delete
   */
  export type UserActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
    /**
     * Filter which UserActivity to delete.
     */
    where: UserActivityWhereUniqueInput
  }

  /**
   * UserActivity deleteMany
   */
  export type UserActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivities to delete
     */
    where?: UserActivityWhereInput
  }

  /**
   * UserActivity without action
   */
  export type UserActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivity
     */
    select?: UserActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivityInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model ConflictReview
   */

  export type AggregateConflictReview = {
    _count: ConflictReviewCountAggregateOutputType | null
    _min: ConflictReviewMinAggregateOutputType | null
    _max: ConflictReviewMaxAggregateOutputType | null
  }

  export type ConflictReviewMinAggregateOutputType = {
    id: string | null
    hpoTermId: string | null
    type: $Enums.ConflictType | null
    status: $Enums.ConflictStatus | null
    priority: $Enums.Priority | null
    winningTranslationId: string | null
    resolution: string | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConflictReviewMaxAggregateOutputType = {
    id: string | null
    hpoTermId: string | null
    type: $Enums.ConflictType | null
    status: $Enums.ConflictStatus | null
    priority: $Enums.Priority | null
    winningTranslationId: string | null
    resolution: string | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConflictReviewCountAggregateOutputType = {
    id: number
    hpoTermId: number
    type: number
    status: number
    priority: number
    winningTranslationId: number
    resolution: number
    resolvedBy: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConflictReviewMinAggregateInputType = {
    id?: true
    hpoTermId?: true
    type?: true
    status?: true
    priority?: true
    winningTranslationId?: true
    resolution?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConflictReviewMaxAggregateInputType = {
    id?: true
    hpoTermId?: true
    type?: true
    status?: true
    priority?: true
    winningTranslationId?: true
    resolution?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConflictReviewCountAggregateInputType = {
    id?: true
    hpoTermId?: true
    type?: true
    status?: true
    priority?: true
    winningTranslationId?: true
    resolution?: true
    resolvedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConflictReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConflictReview to aggregate.
     */
    where?: ConflictReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConflictReviews to fetch.
     */
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConflictReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConflictReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConflictReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConflictReviews
    **/
    _count?: true | ConflictReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConflictReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConflictReviewMaxAggregateInputType
  }

  export type GetConflictReviewAggregateType<T extends ConflictReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateConflictReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConflictReview[P]>
      : GetScalarType<T[P], AggregateConflictReview[P]>
  }




  export type ConflictReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflictReviewWhereInput
    orderBy?: ConflictReviewOrderByWithAggregationInput | ConflictReviewOrderByWithAggregationInput[]
    by: ConflictReviewScalarFieldEnum[] | ConflictReviewScalarFieldEnum
    having?: ConflictReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConflictReviewCountAggregateInputType | true
    _min?: ConflictReviewMinAggregateInputType
    _max?: ConflictReviewMaxAggregateInputType
  }

  export type ConflictReviewGroupByOutputType = {
    id: string
    hpoTermId: string
    type: $Enums.ConflictType
    status: $Enums.ConflictStatus
    priority: $Enums.Priority
    winningTranslationId: string | null
    resolution: string | null
    resolvedBy: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConflictReviewCountAggregateOutputType | null
    _min: ConflictReviewMinAggregateOutputType | null
    _max: ConflictReviewMaxAggregateOutputType | null
  }

  type GetConflictReviewGroupByPayload<T extends ConflictReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConflictReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConflictReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConflictReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ConflictReviewGroupByOutputType[P]>
        }
      >
    >


  export type ConflictReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hpoTermId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    winningTranslationId?: boolean
    resolution?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hpoTerm?: boolean | HpoTermDefaultArgs<ExtArgs>
    translations?: boolean | ConflictReview$translationsArgs<ExtArgs>
    committeeVotes?: boolean | ConflictReview$committeeVotesArgs<ExtArgs>
    resolver?: boolean | ConflictReview$resolverArgs<ExtArgs>
    _count?: boolean | ConflictReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conflictReview"]>

  export type ConflictReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hpoTermId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    winningTranslationId?: boolean
    resolution?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hpoTerm?: boolean | HpoTermDefaultArgs<ExtArgs>
    resolver?: boolean | ConflictReview$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["conflictReview"]>

  export type ConflictReviewSelectScalar = {
    id?: boolean
    hpoTermId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    winningTranslationId?: boolean
    resolution?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConflictReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hpoTerm?: boolean | HpoTermDefaultArgs<ExtArgs>
    translations?: boolean | ConflictReview$translationsArgs<ExtArgs>
    committeeVotes?: boolean | ConflictReview$committeeVotesArgs<ExtArgs>
    resolver?: boolean | ConflictReview$resolverArgs<ExtArgs>
    _count?: boolean | ConflictReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConflictReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hpoTerm?: boolean | HpoTermDefaultArgs<ExtArgs>
    resolver?: boolean | ConflictReview$resolverArgs<ExtArgs>
  }

  export type $ConflictReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConflictReview"
    objects: {
      hpoTerm: Prisma.$HpoTermPayload<ExtArgs>
      translations: Prisma.$TranslationPayload<ExtArgs>[]
      committeeVotes: Prisma.$CommitteeVotePayload<ExtArgs>[]
      resolver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hpoTermId: string
      type: $Enums.ConflictType
      status: $Enums.ConflictStatus
      priority: $Enums.Priority
      winningTranslationId: string | null
      resolution: string | null
      resolvedBy: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conflictReview"]>
    composites: {}
  }

  type ConflictReviewGetPayload<S extends boolean | null | undefined | ConflictReviewDefaultArgs> = $Result.GetResult<Prisma.$ConflictReviewPayload, S>

  type ConflictReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConflictReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConflictReviewCountAggregateInputType | true
    }

  export interface ConflictReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConflictReview'], meta: { name: 'ConflictReview' } }
    /**
     * Find zero or one ConflictReview that matches the filter.
     * @param {ConflictReviewFindUniqueArgs} args - Arguments to find a ConflictReview
     * @example
     * // Get one ConflictReview
     * const conflictReview = await prisma.conflictReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConflictReviewFindUniqueArgs>(args: SelectSubset<T, ConflictReviewFindUniqueArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConflictReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConflictReviewFindUniqueOrThrowArgs} args - Arguments to find a ConflictReview
     * @example
     * // Get one ConflictReview
     * const conflictReview = await prisma.conflictReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConflictReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ConflictReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConflictReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewFindFirstArgs} args - Arguments to find a ConflictReview
     * @example
     * // Get one ConflictReview
     * const conflictReview = await prisma.conflictReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConflictReviewFindFirstArgs>(args?: SelectSubset<T, ConflictReviewFindFirstArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConflictReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewFindFirstOrThrowArgs} args - Arguments to find a ConflictReview
     * @example
     * // Get one ConflictReview
     * const conflictReview = await prisma.conflictReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConflictReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ConflictReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConflictReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConflictReviews
     * const conflictReviews = await prisma.conflictReview.findMany()
     * 
     * // Get first 10 ConflictReviews
     * const conflictReviews = await prisma.conflictReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conflictReviewWithIdOnly = await prisma.conflictReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConflictReviewFindManyArgs>(args?: SelectSubset<T, ConflictReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConflictReview.
     * @param {ConflictReviewCreateArgs} args - Arguments to create a ConflictReview.
     * @example
     * // Create one ConflictReview
     * const ConflictReview = await prisma.conflictReview.create({
     *   data: {
     *     // ... data to create a ConflictReview
     *   }
     * })
     * 
     */
    create<T extends ConflictReviewCreateArgs>(args: SelectSubset<T, ConflictReviewCreateArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConflictReviews.
     * @param {ConflictReviewCreateManyArgs} args - Arguments to create many ConflictReviews.
     * @example
     * // Create many ConflictReviews
     * const conflictReview = await prisma.conflictReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConflictReviewCreateManyArgs>(args?: SelectSubset<T, ConflictReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConflictReviews and returns the data saved in the database.
     * @param {ConflictReviewCreateManyAndReturnArgs} args - Arguments to create many ConflictReviews.
     * @example
     * // Create many ConflictReviews
     * const conflictReview = await prisma.conflictReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConflictReviews and only return the `id`
     * const conflictReviewWithIdOnly = await prisma.conflictReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConflictReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ConflictReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConflictReview.
     * @param {ConflictReviewDeleteArgs} args - Arguments to delete one ConflictReview.
     * @example
     * // Delete one ConflictReview
     * const ConflictReview = await prisma.conflictReview.delete({
     *   where: {
     *     // ... filter to delete one ConflictReview
     *   }
     * })
     * 
     */
    delete<T extends ConflictReviewDeleteArgs>(args: SelectSubset<T, ConflictReviewDeleteArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConflictReview.
     * @param {ConflictReviewUpdateArgs} args - Arguments to update one ConflictReview.
     * @example
     * // Update one ConflictReview
     * const conflictReview = await prisma.conflictReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConflictReviewUpdateArgs>(args: SelectSubset<T, ConflictReviewUpdateArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConflictReviews.
     * @param {ConflictReviewDeleteManyArgs} args - Arguments to filter ConflictReviews to delete.
     * @example
     * // Delete a few ConflictReviews
     * const { count } = await prisma.conflictReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConflictReviewDeleteManyArgs>(args?: SelectSubset<T, ConflictReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConflictReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConflictReviews
     * const conflictReview = await prisma.conflictReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConflictReviewUpdateManyArgs>(args: SelectSubset<T, ConflictReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConflictReview.
     * @param {ConflictReviewUpsertArgs} args - Arguments to update or create a ConflictReview.
     * @example
     * // Update or create a ConflictReview
     * const conflictReview = await prisma.conflictReview.upsert({
     *   create: {
     *     // ... data to create a ConflictReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConflictReview we want to update
     *   }
     * })
     */
    upsert<T extends ConflictReviewUpsertArgs>(args: SelectSubset<T, ConflictReviewUpsertArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConflictReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewCountArgs} args - Arguments to filter ConflictReviews to count.
     * @example
     * // Count the number of ConflictReviews
     * const count = await prisma.conflictReview.count({
     *   where: {
     *     // ... the filter for the ConflictReviews we want to count
     *   }
     * })
    **/
    count<T extends ConflictReviewCountArgs>(
      args?: Subset<T, ConflictReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConflictReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConflictReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConflictReviewAggregateArgs>(args: Subset<T, ConflictReviewAggregateArgs>): Prisma.PrismaPromise<GetConflictReviewAggregateType<T>>

    /**
     * Group by ConflictReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflictReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConflictReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConflictReviewGroupByArgs['orderBy'] }
        : { orderBy?: ConflictReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConflictReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConflictReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConflictReview model
   */
  readonly fields: ConflictReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConflictReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConflictReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hpoTerm<T extends HpoTermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HpoTermDefaultArgs<ExtArgs>>): Prisma__HpoTermClient<$Result.GetResult<Prisma.$HpoTermPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translations<T extends ConflictReview$translationsArgs<ExtArgs> = {}>(args?: Subset<T, ConflictReview$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    committeeVotes<T extends ConflictReview$committeeVotesArgs<ExtArgs> = {}>(args?: Subset<T, ConflictReview$committeeVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findMany"> | Null>
    resolver<T extends ConflictReview$resolverArgs<ExtArgs> = {}>(args?: Subset<T, ConflictReview$resolverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConflictReview model
   */ 
  interface ConflictReviewFieldRefs {
    readonly id: FieldRef<"ConflictReview", 'String'>
    readonly hpoTermId: FieldRef<"ConflictReview", 'String'>
    readonly type: FieldRef<"ConflictReview", 'ConflictType'>
    readonly status: FieldRef<"ConflictReview", 'ConflictStatus'>
    readonly priority: FieldRef<"ConflictReview", 'Priority'>
    readonly winningTranslationId: FieldRef<"ConflictReview", 'String'>
    readonly resolution: FieldRef<"ConflictReview", 'String'>
    readonly resolvedBy: FieldRef<"ConflictReview", 'String'>
    readonly resolvedAt: FieldRef<"ConflictReview", 'DateTime'>
    readonly createdAt: FieldRef<"ConflictReview", 'DateTime'>
    readonly updatedAt: FieldRef<"ConflictReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConflictReview findUnique
   */
  export type ConflictReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter, which ConflictReview to fetch.
     */
    where: ConflictReviewWhereUniqueInput
  }

  /**
   * ConflictReview findUniqueOrThrow
   */
  export type ConflictReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter, which ConflictReview to fetch.
     */
    where: ConflictReviewWhereUniqueInput
  }

  /**
   * ConflictReview findFirst
   */
  export type ConflictReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter, which ConflictReview to fetch.
     */
    where?: ConflictReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConflictReviews to fetch.
     */
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConflictReviews.
     */
    cursor?: ConflictReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConflictReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConflictReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConflictReviews.
     */
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * ConflictReview findFirstOrThrow
   */
  export type ConflictReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter, which ConflictReview to fetch.
     */
    where?: ConflictReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConflictReviews to fetch.
     */
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConflictReviews.
     */
    cursor?: ConflictReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConflictReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConflictReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConflictReviews.
     */
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * ConflictReview findMany
   */
  export type ConflictReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter, which ConflictReviews to fetch.
     */
    where?: ConflictReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConflictReviews to fetch.
     */
    orderBy?: ConflictReviewOrderByWithRelationInput | ConflictReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConflictReviews.
     */
    cursor?: ConflictReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConflictReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConflictReviews.
     */
    skip?: number
    distinct?: ConflictReviewScalarFieldEnum | ConflictReviewScalarFieldEnum[]
  }

  /**
   * ConflictReview create
   */
  export type ConflictReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ConflictReview.
     */
    data: XOR<ConflictReviewCreateInput, ConflictReviewUncheckedCreateInput>
  }

  /**
   * ConflictReview createMany
   */
  export type ConflictReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConflictReviews.
     */
    data: ConflictReviewCreateManyInput | ConflictReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConflictReview createManyAndReturn
   */
  export type ConflictReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConflictReviews.
     */
    data: ConflictReviewCreateManyInput | ConflictReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConflictReview update
   */
  export type ConflictReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ConflictReview.
     */
    data: XOR<ConflictReviewUpdateInput, ConflictReviewUncheckedUpdateInput>
    /**
     * Choose, which ConflictReview to update.
     */
    where: ConflictReviewWhereUniqueInput
  }

  /**
   * ConflictReview updateMany
   */
  export type ConflictReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConflictReviews.
     */
    data: XOR<ConflictReviewUpdateManyMutationInput, ConflictReviewUncheckedUpdateManyInput>
    /**
     * Filter which ConflictReviews to update
     */
    where?: ConflictReviewWhereInput
  }

  /**
   * ConflictReview upsert
   */
  export type ConflictReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ConflictReview to update in case it exists.
     */
    where: ConflictReviewWhereUniqueInput
    /**
     * In case the ConflictReview found by the `where` argument doesn't exist, create a new ConflictReview with this data.
     */
    create: XOR<ConflictReviewCreateInput, ConflictReviewUncheckedCreateInput>
    /**
     * In case the ConflictReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConflictReviewUpdateInput, ConflictReviewUncheckedUpdateInput>
  }

  /**
   * ConflictReview delete
   */
  export type ConflictReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
    /**
     * Filter which ConflictReview to delete.
     */
    where: ConflictReviewWhereUniqueInput
  }

  /**
   * ConflictReview deleteMany
   */
  export type ConflictReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConflictReviews to delete
     */
    where?: ConflictReviewWhereInput
  }

  /**
   * ConflictReview.translations
   */
  export type ConflictReview$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * ConflictReview.committeeVotes
   */
  export type ConflictReview$committeeVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    where?: CommitteeVoteWhereInput
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    cursor?: CommitteeVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * ConflictReview.resolver
   */
  export type ConflictReview$resolverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ConflictReview without action
   */
  export type ConflictReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConflictReview
     */
    select?: ConflictReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflictReviewInclude<ExtArgs> | null
  }


  /**
   * Model CommitteeVote
   */

  export type AggregateCommitteeVote = {
    _count: CommitteeVoteCountAggregateOutputType | null
    _min: CommitteeVoteMinAggregateOutputType | null
    _max: CommitteeVoteMaxAggregateOutputType | null
  }

  export type CommitteeVoteMinAggregateOutputType = {
    id: string | null
    conflictReviewId: string | null
    voterId: string | null
    translationId: string | null
    voteType: $Enums.VoteType | null
    comment: string | null
    votedAt: Date | null
  }

  export type CommitteeVoteMaxAggregateOutputType = {
    id: string | null
    conflictReviewId: string | null
    voterId: string | null
    translationId: string | null
    voteType: $Enums.VoteType | null
    comment: string | null
    votedAt: Date | null
  }

  export type CommitteeVoteCountAggregateOutputType = {
    id: number
    conflictReviewId: number
    voterId: number
    translationId: number
    voteType: number
    comment: number
    votedAt: number
    _all: number
  }


  export type CommitteeVoteMinAggregateInputType = {
    id?: true
    conflictReviewId?: true
    voterId?: true
    translationId?: true
    voteType?: true
    comment?: true
    votedAt?: true
  }

  export type CommitteeVoteMaxAggregateInputType = {
    id?: true
    conflictReviewId?: true
    voterId?: true
    translationId?: true
    voteType?: true
    comment?: true
    votedAt?: true
  }

  export type CommitteeVoteCountAggregateInputType = {
    id?: true
    conflictReviewId?: true
    voterId?: true
    translationId?: true
    voteType?: true
    comment?: true
    votedAt?: true
    _all?: true
  }

  export type CommitteeVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommitteeVote to aggregate.
     */
    where?: CommitteeVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommitteeVotes to fetch.
     */
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommitteeVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommitteeVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommitteeVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommitteeVotes
    **/
    _count?: true | CommitteeVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommitteeVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommitteeVoteMaxAggregateInputType
  }

  export type GetCommitteeVoteAggregateType<T extends CommitteeVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCommitteeVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommitteeVote[P]>
      : GetScalarType<T[P], AggregateCommitteeVote[P]>
  }




  export type CommitteeVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitteeVoteWhereInput
    orderBy?: CommitteeVoteOrderByWithAggregationInput | CommitteeVoteOrderByWithAggregationInput[]
    by: CommitteeVoteScalarFieldEnum[] | CommitteeVoteScalarFieldEnum
    having?: CommitteeVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommitteeVoteCountAggregateInputType | true
    _min?: CommitteeVoteMinAggregateInputType
    _max?: CommitteeVoteMaxAggregateInputType
  }

  export type CommitteeVoteGroupByOutputType = {
    id: string
    conflictReviewId: string
    voterId: string
    translationId: string | null
    voteType: $Enums.VoteType
    comment: string | null
    votedAt: Date
    _count: CommitteeVoteCountAggregateOutputType | null
    _min: CommitteeVoteMinAggregateOutputType | null
    _max: CommitteeVoteMaxAggregateOutputType | null
  }

  type GetCommitteeVoteGroupByPayload<T extends CommitteeVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommitteeVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommitteeVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommitteeVoteGroupByOutputType[P]>
            : GetScalarType<T[P], CommitteeVoteGroupByOutputType[P]>
        }
      >
    >


  export type CommitteeVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conflictReviewId?: boolean
    voterId?: boolean
    translationId?: boolean
    voteType?: boolean
    comment?: boolean
    votedAt?: boolean
    conflictReview?: boolean | ConflictReviewDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | CommitteeVote$translationArgs<ExtArgs>
  }, ExtArgs["result"]["committeeVote"]>

  export type CommitteeVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conflictReviewId?: boolean
    voterId?: boolean
    translationId?: boolean
    voteType?: boolean
    comment?: boolean
    votedAt?: boolean
    conflictReview?: boolean | ConflictReviewDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | CommitteeVote$translationArgs<ExtArgs>
  }, ExtArgs["result"]["committeeVote"]>

  export type CommitteeVoteSelectScalar = {
    id?: boolean
    conflictReviewId?: boolean
    voterId?: boolean
    translationId?: boolean
    voteType?: boolean
    comment?: boolean
    votedAt?: boolean
  }

  export type CommitteeVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conflictReview?: boolean | ConflictReviewDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | CommitteeVote$translationArgs<ExtArgs>
  }
  export type CommitteeVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conflictReview?: boolean | ConflictReviewDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | CommitteeVote$translationArgs<ExtArgs>
  }

  export type $CommitteeVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommitteeVote"
    objects: {
      conflictReview: Prisma.$ConflictReviewPayload<ExtArgs>
      voter: Prisma.$UserPayload<ExtArgs>
      translation: Prisma.$TranslationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conflictReviewId: string
      voterId: string
      translationId: string | null
      voteType: $Enums.VoteType
      comment: string | null
      votedAt: Date
    }, ExtArgs["result"]["committeeVote"]>
    composites: {}
  }

  type CommitteeVoteGetPayload<S extends boolean | null | undefined | CommitteeVoteDefaultArgs> = $Result.GetResult<Prisma.$CommitteeVotePayload, S>

  type CommitteeVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommitteeVoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommitteeVoteCountAggregateInputType | true
    }

  export interface CommitteeVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommitteeVote'], meta: { name: 'CommitteeVote' } }
    /**
     * Find zero or one CommitteeVote that matches the filter.
     * @param {CommitteeVoteFindUniqueArgs} args - Arguments to find a CommitteeVote
     * @example
     * // Get one CommitteeVote
     * const committeeVote = await prisma.committeeVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommitteeVoteFindUniqueArgs>(args: SelectSubset<T, CommitteeVoteFindUniqueArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommitteeVote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommitteeVoteFindUniqueOrThrowArgs} args - Arguments to find a CommitteeVote
     * @example
     * // Get one CommitteeVote
     * const committeeVote = await prisma.committeeVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommitteeVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CommitteeVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommitteeVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteFindFirstArgs} args - Arguments to find a CommitteeVote
     * @example
     * // Get one CommitteeVote
     * const committeeVote = await prisma.committeeVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommitteeVoteFindFirstArgs>(args?: SelectSubset<T, CommitteeVoteFindFirstArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommitteeVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteFindFirstOrThrowArgs} args - Arguments to find a CommitteeVote
     * @example
     * // Get one CommitteeVote
     * const committeeVote = await prisma.committeeVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommitteeVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CommitteeVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommitteeVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommitteeVotes
     * const committeeVotes = await prisma.committeeVote.findMany()
     * 
     * // Get first 10 CommitteeVotes
     * const committeeVotes = await prisma.committeeVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committeeVoteWithIdOnly = await prisma.committeeVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommitteeVoteFindManyArgs>(args?: SelectSubset<T, CommitteeVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommitteeVote.
     * @param {CommitteeVoteCreateArgs} args - Arguments to create a CommitteeVote.
     * @example
     * // Create one CommitteeVote
     * const CommitteeVote = await prisma.committeeVote.create({
     *   data: {
     *     // ... data to create a CommitteeVote
     *   }
     * })
     * 
     */
    create<T extends CommitteeVoteCreateArgs>(args: SelectSubset<T, CommitteeVoteCreateArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommitteeVotes.
     * @param {CommitteeVoteCreateManyArgs} args - Arguments to create many CommitteeVotes.
     * @example
     * // Create many CommitteeVotes
     * const committeeVote = await prisma.committeeVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommitteeVoteCreateManyArgs>(args?: SelectSubset<T, CommitteeVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommitteeVotes and returns the data saved in the database.
     * @param {CommitteeVoteCreateManyAndReturnArgs} args - Arguments to create many CommitteeVotes.
     * @example
     * // Create many CommitteeVotes
     * const committeeVote = await prisma.committeeVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommitteeVotes and only return the `id`
     * const committeeVoteWithIdOnly = await prisma.committeeVote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommitteeVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CommitteeVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommitteeVote.
     * @param {CommitteeVoteDeleteArgs} args - Arguments to delete one CommitteeVote.
     * @example
     * // Delete one CommitteeVote
     * const CommitteeVote = await prisma.committeeVote.delete({
     *   where: {
     *     // ... filter to delete one CommitteeVote
     *   }
     * })
     * 
     */
    delete<T extends CommitteeVoteDeleteArgs>(args: SelectSubset<T, CommitteeVoteDeleteArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommitteeVote.
     * @param {CommitteeVoteUpdateArgs} args - Arguments to update one CommitteeVote.
     * @example
     * // Update one CommitteeVote
     * const committeeVote = await prisma.committeeVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommitteeVoteUpdateArgs>(args: SelectSubset<T, CommitteeVoteUpdateArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommitteeVotes.
     * @param {CommitteeVoteDeleteManyArgs} args - Arguments to filter CommitteeVotes to delete.
     * @example
     * // Delete a few CommitteeVotes
     * const { count } = await prisma.committeeVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommitteeVoteDeleteManyArgs>(args?: SelectSubset<T, CommitteeVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommitteeVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommitteeVotes
     * const committeeVote = await prisma.committeeVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommitteeVoteUpdateManyArgs>(args: SelectSubset<T, CommitteeVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommitteeVote.
     * @param {CommitteeVoteUpsertArgs} args - Arguments to update or create a CommitteeVote.
     * @example
     * // Update or create a CommitteeVote
     * const committeeVote = await prisma.committeeVote.upsert({
     *   create: {
     *     // ... data to create a CommitteeVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommitteeVote we want to update
     *   }
     * })
     */
    upsert<T extends CommitteeVoteUpsertArgs>(args: SelectSubset<T, CommitteeVoteUpsertArgs<ExtArgs>>): Prisma__CommitteeVoteClient<$Result.GetResult<Prisma.$CommitteeVotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommitteeVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteCountArgs} args - Arguments to filter CommitteeVotes to count.
     * @example
     * // Count the number of CommitteeVotes
     * const count = await prisma.committeeVote.count({
     *   where: {
     *     // ... the filter for the CommitteeVotes we want to count
     *   }
     * })
    **/
    count<T extends CommitteeVoteCountArgs>(
      args?: Subset<T, CommitteeVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommitteeVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommitteeVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommitteeVoteAggregateArgs>(args: Subset<T, CommitteeVoteAggregateArgs>): Prisma.PrismaPromise<GetCommitteeVoteAggregateType<T>>

    /**
     * Group by CommitteeVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommitteeVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommitteeVoteGroupByArgs['orderBy'] }
        : { orderBy?: CommitteeVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommitteeVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommitteeVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommitteeVote model
   */
  readonly fields: CommitteeVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommitteeVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommitteeVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conflictReview<T extends ConflictReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConflictReviewDefaultArgs<ExtArgs>>): Prisma__ConflictReviewClient<$Result.GetResult<Prisma.$ConflictReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translation<T extends CommitteeVote$translationArgs<ExtArgs> = {}>(args?: Subset<T, CommitteeVote$translationArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommitteeVote model
   */ 
  interface CommitteeVoteFieldRefs {
    readonly id: FieldRef<"CommitteeVote", 'String'>
    readonly conflictReviewId: FieldRef<"CommitteeVote", 'String'>
    readonly voterId: FieldRef<"CommitteeVote", 'String'>
    readonly translationId: FieldRef<"CommitteeVote", 'String'>
    readonly voteType: FieldRef<"CommitteeVote", 'VoteType'>
    readonly comment: FieldRef<"CommitteeVote", 'String'>
    readonly votedAt: FieldRef<"CommitteeVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommitteeVote findUnique
   */
  export type CommitteeVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommitteeVote to fetch.
     */
    where: CommitteeVoteWhereUniqueInput
  }

  /**
   * CommitteeVote findUniqueOrThrow
   */
  export type CommitteeVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommitteeVote to fetch.
     */
    where: CommitteeVoteWhereUniqueInput
  }

  /**
   * CommitteeVote findFirst
   */
  export type CommitteeVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommitteeVote to fetch.
     */
    where?: CommitteeVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommitteeVotes to fetch.
     */
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommitteeVotes.
     */
    cursor?: CommitteeVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommitteeVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommitteeVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommitteeVotes.
     */
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * CommitteeVote findFirstOrThrow
   */
  export type CommitteeVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommitteeVote to fetch.
     */
    where?: CommitteeVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommitteeVotes to fetch.
     */
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommitteeVotes.
     */
    cursor?: CommitteeVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommitteeVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommitteeVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommitteeVotes.
     */
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * CommitteeVote findMany
   */
  export type CommitteeVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommitteeVotes to fetch.
     */
    where?: CommitteeVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommitteeVotes to fetch.
     */
    orderBy?: CommitteeVoteOrderByWithRelationInput | CommitteeVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommitteeVotes.
     */
    cursor?: CommitteeVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommitteeVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommitteeVotes.
     */
    skip?: number
    distinct?: CommitteeVoteScalarFieldEnum | CommitteeVoteScalarFieldEnum[]
  }

  /**
   * CommitteeVote create
   */
  export type CommitteeVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CommitteeVote.
     */
    data: XOR<CommitteeVoteCreateInput, CommitteeVoteUncheckedCreateInput>
  }

  /**
   * CommitteeVote createMany
   */
  export type CommitteeVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommitteeVotes.
     */
    data: CommitteeVoteCreateManyInput | CommitteeVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommitteeVote createManyAndReturn
   */
  export type CommitteeVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommitteeVotes.
     */
    data: CommitteeVoteCreateManyInput | CommitteeVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommitteeVote update
   */
  export type CommitteeVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CommitteeVote.
     */
    data: XOR<CommitteeVoteUpdateInput, CommitteeVoteUncheckedUpdateInput>
    /**
     * Choose, which CommitteeVote to update.
     */
    where: CommitteeVoteWhereUniqueInput
  }

  /**
   * CommitteeVote updateMany
   */
  export type CommitteeVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommitteeVotes.
     */
    data: XOR<CommitteeVoteUpdateManyMutationInput, CommitteeVoteUncheckedUpdateManyInput>
    /**
     * Filter which CommitteeVotes to update
     */
    where?: CommitteeVoteWhereInput
  }

  /**
   * CommitteeVote upsert
   */
  export type CommitteeVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CommitteeVote to update in case it exists.
     */
    where: CommitteeVoteWhereUniqueInput
    /**
     * In case the CommitteeVote found by the `where` argument doesn't exist, create a new CommitteeVote with this data.
     */
    create: XOR<CommitteeVoteCreateInput, CommitteeVoteUncheckedCreateInput>
    /**
     * In case the CommitteeVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommitteeVoteUpdateInput, CommitteeVoteUncheckedUpdateInput>
  }

  /**
   * CommitteeVote delete
   */
  export type CommitteeVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
    /**
     * Filter which CommitteeVote to delete.
     */
    where: CommitteeVoteWhereUniqueInput
  }

  /**
   * CommitteeVote deleteMany
   */
  export type CommitteeVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommitteeVotes to delete
     */
    where?: CommitteeVoteWhereInput
  }

  /**
   * CommitteeVote.translation
   */
  export type CommitteeVote$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
  }

  /**
   * CommitteeVote without action
   */
  export type CommitteeVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeVote
     */
    select?: CommitteeVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitteeVoteInclude<ExtArgs> | null
  }


  /**
   * Model Rejection
   */

  export type AggregateRejection = {
    _count: RejectionCountAggregateOutputType | null
    _min: RejectionMinAggregateOutputType | null
    _max: RejectionMaxAggregateOutputType | null
  }

  export type RejectionMinAggregateOutputType = {
    id: string | null
    translationId: string | null
    rejectedBy: string | null
    reasonCode: $Enums.RejectionReason | null
    detailedReason: string | null
    suggestions: string | null
    canResubmit: boolean | null
    createdAt: Date | null
  }

  export type RejectionMaxAggregateOutputType = {
    id: string | null
    translationId: string | null
    rejectedBy: string | null
    reasonCode: $Enums.RejectionReason | null
    detailedReason: string | null
    suggestions: string | null
    canResubmit: boolean | null
    createdAt: Date | null
  }

  export type RejectionCountAggregateOutputType = {
    id: number
    translationId: number
    rejectedBy: number
    reasonCode: number
    detailedReason: number
    suggestions: number
    canResubmit: number
    createdAt: number
    _all: number
  }


  export type RejectionMinAggregateInputType = {
    id?: true
    translationId?: true
    rejectedBy?: true
    reasonCode?: true
    detailedReason?: true
    suggestions?: true
    canResubmit?: true
    createdAt?: true
  }

  export type RejectionMaxAggregateInputType = {
    id?: true
    translationId?: true
    rejectedBy?: true
    reasonCode?: true
    detailedReason?: true
    suggestions?: true
    canResubmit?: true
    createdAt?: true
  }

  export type RejectionCountAggregateInputType = {
    id?: true
    translationId?: true
    rejectedBy?: true
    reasonCode?: true
    detailedReason?: true
    suggestions?: true
    canResubmit?: true
    createdAt?: true
    _all?: true
  }

  export type RejectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rejection to aggregate.
     */
    where?: RejectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rejections to fetch.
     */
    orderBy?: RejectionOrderByWithRelationInput | RejectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RejectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rejections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rejections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rejections
    **/
    _count?: true | RejectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RejectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RejectionMaxAggregateInputType
  }

  export type GetRejectionAggregateType<T extends RejectionAggregateArgs> = {
        [P in keyof T & keyof AggregateRejection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRejection[P]>
      : GetScalarType<T[P], AggregateRejection[P]>
  }




  export type RejectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RejectionWhereInput
    orderBy?: RejectionOrderByWithAggregationInput | RejectionOrderByWithAggregationInput[]
    by: RejectionScalarFieldEnum[] | RejectionScalarFieldEnum
    having?: RejectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RejectionCountAggregateInputType | true
    _min?: RejectionMinAggregateInputType
    _max?: RejectionMaxAggregateInputType
  }

  export type RejectionGroupByOutputType = {
    id: string
    translationId: string
    rejectedBy: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions: string | null
    canResubmit: boolean
    createdAt: Date
    _count: RejectionCountAggregateOutputType | null
    _min: RejectionMinAggregateOutputType | null
    _max: RejectionMaxAggregateOutputType | null
  }

  type GetRejectionGroupByPayload<T extends RejectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RejectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RejectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RejectionGroupByOutputType[P]>
            : GetScalarType<T[P], RejectionGroupByOutputType[P]>
        }
      >
    >


  export type RejectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    rejectedBy?: boolean
    reasonCode?: boolean
    detailedReason?: boolean
    suggestions?: boolean
    canResubmit?: boolean
    createdAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejection"]>

  export type RejectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationId?: boolean
    rejectedBy?: boolean
    reasonCode?: boolean
    detailedReason?: boolean
    suggestions?: boolean
    canResubmit?: boolean
    createdAt?: boolean
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejection"]>

  export type RejectionSelectScalar = {
    id?: boolean
    translationId?: boolean
    rejectedBy?: boolean
    reasonCode?: boolean
    detailedReason?: boolean
    suggestions?: boolean
    canResubmit?: boolean
    createdAt?: boolean
  }

  export type RejectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RejectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | TranslationDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RejectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rejection"
    objects: {
      translation: Prisma.$TranslationPayload<ExtArgs>
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      translationId: string
      rejectedBy: string
      reasonCode: $Enums.RejectionReason
      detailedReason: string
      suggestions: string | null
      canResubmit: boolean
      createdAt: Date
    }, ExtArgs["result"]["rejection"]>
    composites: {}
  }

  type RejectionGetPayload<S extends boolean | null | undefined | RejectionDefaultArgs> = $Result.GetResult<Prisma.$RejectionPayload, S>

  type RejectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RejectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RejectionCountAggregateInputType | true
    }

  export interface RejectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rejection'], meta: { name: 'Rejection' } }
    /**
     * Find zero or one Rejection that matches the filter.
     * @param {RejectionFindUniqueArgs} args - Arguments to find a Rejection
     * @example
     * // Get one Rejection
     * const rejection = await prisma.rejection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RejectionFindUniqueArgs>(args: SelectSubset<T, RejectionFindUniqueArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rejection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RejectionFindUniqueOrThrowArgs} args - Arguments to find a Rejection
     * @example
     * // Get one Rejection
     * const rejection = await prisma.rejection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RejectionFindUniqueOrThrowArgs>(args: SelectSubset<T, RejectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rejection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionFindFirstArgs} args - Arguments to find a Rejection
     * @example
     * // Get one Rejection
     * const rejection = await prisma.rejection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RejectionFindFirstArgs>(args?: SelectSubset<T, RejectionFindFirstArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rejection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionFindFirstOrThrowArgs} args - Arguments to find a Rejection
     * @example
     * // Get one Rejection
     * const rejection = await prisma.rejection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RejectionFindFirstOrThrowArgs>(args?: SelectSubset<T, RejectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rejections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rejections
     * const rejections = await prisma.rejection.findMany()
     * 
     * // Get first 10 Rejections
     * const rejections = await prisma.rejection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rejectionWithIdOnly = await prisma.rejection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RejectionFindManyArgs>(args?: SelectSubset<T, RejectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rejection.
     * @param {RejectionCreateArgs} args - Arguments to create a Rejection.
     * @example
     * // Create one Rejection
     * const Rejection = await prisma.rejection.create({
     *   data: {
     *     // ... data to create a Rejection
     *   }
     * })
     * 
     */
    create<T extends RejectionCreateArgs>(args: SelectSubset<T, RejectionCreateArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rejections.
     * @param {RejectionCreateManyArgs} args - Arguments to create many Rejections.
     * @example
     * // Create many Rejections
     * const rejection = await prisma.rejection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RejectionCreateManyArgs>(args?: SelectSubset<T, RejectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rejections and returns the data saved in the database.
     * @param {RejectionCreateManyAndReturnArgs} args - Arguments to create many Rejections.
     * @example
     * // Create many Rejections
     * const rejection = await prisma.rejection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rejections and only return the `id`
     * const rejectionWithIdOnly = await prisma.rejection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RejectionCreateManyAndReturnArgs>(args?: SelectSubset<T, RejectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rejection.
     * @param {RejectionDeleteArgs} args - Arguments to delete one Rejection.
     * @example
     * // Delete one Rejection
     * const Rejection = await prisma.rejection.delete({
     *   where: {
     *     // ... filter to delete one Rejection
     *   }
     * })
     * 
     */
    delete<T extends RejectionDeleteArgs>(args: SelectSubset<T, RejectionDeleteArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rejection.
     * @param {RejectionUpdateArgs} args - Arguments to update one Rejection.
     * @example
     * // Update one Rejection
     * const rejection = await prisma.rejection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RejectionUpdateArgs>(args: SelectSubset<T, RejectionUpdateArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rejections.
     * @param {RejectionDeleteManyArgs} args - Arguments to filter Rejections to delete.
     * @example
     * // Delete a few Rejections
     * const { count } = await prisma.rejection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RejectionDeleteManyArgs>(args?: SelectSubset<T, RejectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rejections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rejections
     * const rejection = await prisma.rejection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RejectionUpdateManyArgs>(args: SelectSubset<T, RejectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rejection.
     * @param {RejectionUpsertArgs} args - Arguments to update or create a Rejection.
     * @example
     * // Update or create a Rejection
     * const rejection = await prisma.rejection.upsert({
     *   create: {
     *     // ... data to create a Rejection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rejection we want to update
     *   }
     * })
     */
    upsert<T extends RejectionUpsertArgs>(args: SelectSubset<T, RejectionUpsertArgs<ExtArgs>>): Prisma__RejectionClient<$Result.GetResult<Prisma.$RejectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rejections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionCountArgs} args - Arguments to filter Rejections to count.
     * @example
     * // Count the number of Rejections
     * const count = await prisma.rejection.count({
     *   where: {
     *     // ... the filter for the Rejections we want to count
     *   }
     * })
    **/
    count<T extends RejectionCountArgs>(
      args?: Subset<T, RejectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RejectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rejection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RejectionAggregateArgs>(args: Subset<T, RejectionAggregateArgs>): Prisma.PrismaPromise<GetRejectionAggregateType<T>>

    /**
     * Group by Rejection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RejectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RejectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RejectionGroupByArgs['orderBy'] }
        : { orderBy?: RejectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RejectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRejectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rejection model
   */
  readonly fields: RejectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rejection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RejectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translation<T extends TranslationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranslationDefaultArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rejection model
   */ 
  interface RejectionFieldRefs {
    readonly id: FieldRef<"Rejection", 'String'>
    readonly translationId: FieldRef<"Rejection", 'String'>
    readonly rejectedBy: FieldRef<"Rejection", 'String'>
    readonly reasonCode: FieldRef<"Rejection", 'RejectionReason'>
    readonly detailedReason: FieldRef<"Rejection", 'String'>
    readonly suggestions: FieldRef<"Rejection", 'String'>
    readonly canResubmit: FieldRef<"Rejection", 'Boolean'>
    readonly createdAt: FieldRef<"Rejection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rejection findUnique
   */
  export type RejectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter, which Rejection to fetch.
     */
    where: RejectionWhereUniqueInput
  }

  /**
   * Rejection findUniqueOrThrow
   */
  export type RejectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter, which Rejection to fetch.
     */
    where: RejectionWhereUniqueInput
  }

  /**
   * Rejection findFirst
   */
  export type RejectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter, which Rejection to fetch.
     */
    where?: RejectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rejections to fetch.
     */
    orderBy?: RejectionOrderByWithRelationInput | RejectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rejections.
     */
    cursor?: RejectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rejections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rejections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rejections.
     */
    distinct?: RejectionScalarFieldEnum | RejectionScalarFieldEnum[]
  }

  /**
   * Rejection findFirstOrThrow
   */
  export type RejectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter, which Rejection to fetch.
     */
    where?: RejectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rejections to fetch.
     */
    orderBy?: RejectionOrderByWithRelationInput | RejectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rejections.
     */
    cursor?: RejectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rejections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rejections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rejections.
     */
    distinct?: RejectionScalarFieldEnum | RejectionScalarFieldEnum[]
  }

  /**
   * Rejection findMany
   */
  export type RejectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter, which Rejections to fetch.
     */
    where?: RejectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rejections to fetch.
     */
    orderBy?: RejectionOrderByWithRelationInput | RejectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rejections.
     */
    cursor?: RejectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rejections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rejections.
     */
    skip?: number
    distinct?: RejectionScalarFieldEnum | RejectionScalarFieldEnum[]
  }

  /**
   * Rejection create
   */
  export type RejectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Rejection.
     */
    data: XOR<RejectionCreateInput, RejectionUncheckedCreateInput>
  }

  /**
   * Rejection createMany
   */
  export type RejectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rejections.
     */
    data: RejectionCreateManyInput | RejectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rejection createManyAndReturn
   */
  export type RejectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rejections.
     */
    data: RejectionCreateManyInput | RejectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rejection update
   */
  export type RejectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Rejection.
     */
    data: XOR<RejectionUpdateInput, RejectionUncheckedUpdateInput>
    /**
     * Choose, which Rejection to update.
     */
    where: RejectionWhereUniqueInput
  }

  /**
   * Rejection updateMany
   */
  export type RejectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rejections.
     */
    data: XOR<RejectionUpdateManyMutationInput, RejectionUncheckedUpdateManyInput>
    /**
     * Filter which Rejections to update
     */
    where?: RejectionWhereInput
  }

  /**
   * Rejection upsert
   */
  export type RejectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Rejection to update in case it exists.
     */
    where: RejectionWhereUniqueInput
    /**
     * In case the Rejection found by the `where` argument doesn't exist, create a new Rejection with this data.
     */
    create: XOR<RejectionCreateInput, RejectionUncheckedCreateInput>
    /**
     * In case the Rejection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RejectionUpdateInput, RejectionUncheckedUpdateInput>
  }

  /**
   * Rejection delete
   */
  export type RejectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
    /**
     * Filter which Rejection to delete.
     */
    where: RejectionWhereUniqueInput
  }

  /**
   * Rejection deleteMany
   */
  export type RejectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rejections to delete
     */
    where?: RejectionWhereInput
  }

  /**
   * Rejection without action
   */
  export type RejectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rejection
     */
    select?: RejectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RejectionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    targetType: string | null
    targetId: string | null
    reason: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: $Enums.AdminAction | null
    targetType: string | null
    targetId: string | null
    reason: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetType: number
    targetId: number
    changes: number
    reason: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    reason?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    reason?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    changes?: true
    reason?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminId: string
    action: $Enums.AdminAction
    targetType: string
    targetId: string | null
    changes: JsonValue | null
    reason: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    changes?: boolean
    reason?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    changes?: boolean
    reason?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    changes?: boolean
    reason?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: $Enums.AdminAction
      targetType: string
      targetId: string | null
      changes: Prisma.JsonValue | null
      reason: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */ 
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'AdminAction'>
    readonly targetType: FieldRef<"AdminAuditLog", 'String'>
    readonly targetId: FieldRef<"AdminAuditLog", 'String'>
    readonly changes: FieldRef<"AdminAuditLog", 'Json'>
    readonly reason: FieldRef<"AdminAuditLog", 'String'>
    readonly details: FieldRef<"AdminAuditLog", 'String'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
    readonly userAgent: FieldRef<"AdminAuditLog", 'String'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    translationsCount: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    translationsCount: number | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    syncDate: Date | null
    initiatedBy: string | null
    translationsCount: number | null
    babelonFilePath: string | null
    githubPrUrl: string | null
    status: $Enums.SyncStatus | null
    errorMessage: string | null
    completedAt: Date | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    syncDate: Date | null
    initiatedBy: string | null
    translationsCount: number | null
    babelonFilePath: string | null
    githubPrUrl: string | null
    status: $Enums.SyncStatus | null
    errorMessage: string | null
    completedAt: Date | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    syncDate: number
    initiatedBy: number
    translationsCount: number
    babelonFilePath: number
    githubPrUrl: number
    status: number
    errorMessage: number
    completedAt: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    translationsCount?: true
  }

  export type SyncLogSumAggregateInputType = {
    translationsCount?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    syncDate?: true
    initiatedBy?: true
    translationsCount?: true
    babelonFilePath?: true
    githubPrUrl?: true
    status?: true
    errorMessage?: true
    completedAt?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    syncDate?: true
    initiatedBy?: true
    translationsCount?: true
    babelonFilePath?: true
    githubPrUrl?: true
    status?: true
    errorMessage?: true
    completedAt?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    syncDate?: true
    initiatedBy?: true
    translationsCount?: true
    babelonFilePath?: true
    githubPrUrl?: true
    status?: true
    errorMessage?: true
    completedAt?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    syncDate: Date
    initiatedBy: string
    translationsCount: number
    babelonFilePath: string | null
    githubPrUrl: string | null
    status: $Enums.SyncStatus
    errorMessage: string | null
    completedAt: Date | null
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncDate?: boolean
    initiatedBy?: boolean
    translationsCount?: boolean
    babelonFilePath?: boolean
    githubPrUrl?: boolean
    status?: boolean
    errorMessage?: boolean
    completedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncDate?: boolean
    initiatedBy?: boolean
    translationsCount?: boolean
    babelonFilePath?: boolean
    githubPrUrl?: boolean
    status?: boolean
    errorMessage?: boolean
    completedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    syncDate?: boolean
    initiatedBy?: boolean
    translationsCount?: boolean
    babelonFilePath?: boolean
    githubPrUrl?: boolean
    status?: boolean
    errorMessage?: boolean
    completedAt?: boolean
  }

  export type SyncLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SyncLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syncDate: Date
      initiatedBy: string
      translationsCount: number
      babelonFilePath: string | null
      githubPrUrl: string | null
      status: $Enums.SyncStatus
      errorMessage: string | null
      completedAt: Date | null
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */ 
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly syncDate: FieldRef<"SyncLog", 'DateTime'>
    readonly initiatedBy: FieldRef<"SyncLog", 'String'>
    readonly translationsCount: FieldRef<"SyncLog", 'Int'>
    readonly babelonFilePath: FieldRef<"SyncLog", 'String'>
    readonly githubPrUrl: FieldRef<"SyncLog", 'String'>
    readonly status: FieldRef<"SyncLog", 'SyncStatus'>
    readonly errorMessage: FieldRef<"SyncLog", 'String'>
    readonly completedAt: FieldRef<"SyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    link: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    link: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    link: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    link: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      link: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Strike
   */

  export type AggregateStrike = {
    _count: StrikeCountAggregateOutputType | null
    _avg: StrikeAvgAggregateOutputType | null
    _sum: StrikeSumAggregateOutputType | null
    _min: StrikeMinAggregateOutputType | null
    _max: StrikeMaxAggregateOutputType | null
  }

  export type StrikeAvgAggregateOutputType = {
    severity: number | null
  }

  export type StrikeSumAggregateOutputType = {
    severity: number | null
  }

  export type StrikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    reason: $Enums.StrikeReason | null
    detailedReason: string | null
    translationId: string | null
    severity: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type StrikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    reason: $Enums.StrikeReason | null
    detailedReason: string | null
    translationId: string | null
    severity: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type StrikeCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    reason: number
    detailedReason: number
    translationId: number
    severity: number
    isActive: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type StrikeAvgAggregateInputType = {
    severity?: true
  }

  export type StrikeSumAggregateInputType = {
    severity?: true
  }

  export type StrikeMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    reason?: true
    detailedReason?: true
    translationId?: true
    severity?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type StrikeMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    reason?: true
    detailedReason?: true
    translationId?: true
    severity?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type StrikeCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    reason?: true
    detailedReason?: true
    translationId?: true
    severity?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type StrikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strike to aggregate.
     */
    where?: StrikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strikes to fetch.
     */
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strikes
    **/
    _count?: true | StrikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrikeMaxAggregateInputType
  }

  export type GetStrikeAggregateType<T extends StrikeAggregateArgs> = {
        [P in keyof T & keyof AggregateStrike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrike[P]>
      : GetScalarType<T[P], AggregateStrike[P]>
  }




  export type StrikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrikeWhereInput
    orderBy?: StrikeOrderByWithAggregationInput | StrikeOrderByWithAggregationInput[]
    by: StrikeScalarFieldEnum[] | StrikeScalarFieldEnum
    having?: StrikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrikeCountAggregateInputType | true
    _avg?: StrikeAvgAggregateInputType
    _sum?: StrikeSumAggregateInputType
    _min?: StrikeMinAggregateInputType
    _max?: StrikeMaxAggregateInputType
  }

  export type StrikeGroupByOutputType = {
    id: string
    userId: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId: string | null
    severity: number
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    _count: StrikeCountAggregateOutputType | null
    _avg: StrikeAvgAggregateOutputType | null
    _sum: StrikeSumAggregateOutputType | null
    _min: StrikeMinAggregateOutputType | null
    _max: StrikeMaxAggregateOutputType | null
  }

  type GetStrikeGroupByPayload<T extends StrikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrikeGroupByOutputType[P]>
            : GetScalarType<T[P], StrikeGroupByOutputType[P]>
        }
      >
    >


  export type StrikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    reason?: boolean
    detailedReason?: boolean
    translationId?: boolean
    severity?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | Strike$translationArgs<ExtArgs>
  }, ExtArgs["result"]["strike"]>

  export type StrikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    reason?: boolean
    detailedReason?: boolean
    translationId?: boolean
    severity?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | Strike$translationArgs<ExtArgs>
  }, ExtArgs["result"]["strike"]>

  export type StrikeSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    reason?: boolean
    detailedReason?: boolean
    translationId?: boolean
    severity?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type StrikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | Strike$translationArgs<ExtArgs>
  }
  export type StrikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    admin?: boolean | UserDefaultArgs<ExtArgs>
    translation?: boolean | Strike$translationArgs<ExtArgs>
  }

  export type $StrikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Strike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      admin: Prisma.$UserPayload<ExtArgs>
      translation: Prisma.$TranslationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      adminId: string
      reason: $Enums.StrikeReason
      detailedReason: string
      translationId: string | null
      severity: number
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["strike"]>
    composites: {}
  }

  type StrikeGetPayload<S extends boolean | null | undefined | StrikeDefaultArgs> = $Result.GetResult<Prisma.$StrikePayload, S>

  type StrikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrikeCountAggregateInputType | true
    }

  export interface StrikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Strike'], meta: { name: 'Strike' } }
    /**
     * Find zero or one Strike that matches the filter.
     * @param {StrikeFindUniqueArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrikeFindUniqueArgs>(args: SelectSubset<T, StrikeFindUniqueArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Strike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrikeFindUniqueOrThrowArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrikeFindUniqueOrThrowArgs>(args: SelectSubset<T, StrikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Strike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeFindFirstArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrikeFindFirstArgs>(args?: SelectSubset<T, StrikeFindFirstArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Strike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeFindFirstOrThrowArgs} args - Arguments to find a Strike
     * @example
     * // Get one Strike
     * const strike = await prisma.strike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrikeFindFirstOrThrowArgs>(args?: SelectSubset<T, StrikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Strikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strikes
     * const strikes = await prisma.strike.findMany()
     * 
     * // Get first 10 Strikes
     * const strikes = await prisma.strike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strikeWithIdOnly = await prisma.strike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrikeFindManyArgs>(args?: SelectSubset<T, StrikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Strike.
     * @param {StrikeCreateArgs} args - Arguments to create a Strike.
     * @example
     * // Create one Strike
     * const Strike = await prisma.strike.create({
     *   data: {
     *     // ... data to create a Strike
     *   }
     * })
     * 
     */
    create<T extends StrikeCreateArgs>(args: SelectSubset<T, StrikeCreateArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Strikes.
     * @param {StrikeCreateManyArgs} args - Arguments to create many Strikes.
     * @example
     * // Create many Strikes
     * const strike = await prisma.strike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrikeCreateManyArgs>(args?: SelectSubset<T, StrikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Strikes and returns the data saved in the database.
     * @param {StrikeCreateManyAndReturnArgs} args - Arguments to create many Strikes.
     * @example
     * // Create many Strikes
     * const strike = await prisma.strike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Strikes and only return the `id`
     * const strikeWithIdOnly = await prisma.strike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrikeCreateManyAndReturnArgs>(args?: SelectSubset<T, StrikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Strike.
     * @param {StrikeDeleteArgs} args - Arguments to delete one Strike.
     * @example
     * // Delete one Strike
     * const Strike = await prisma.strike.delete({
     *   where: {
     *     // ... filter to delete one Strike
     *   }
     * })
     * 
     */
    delete<T extends StrikeDeleteArgs>(args: SelectSubset<T, StrikeDeleteArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Strike.
     * @param {StrikeUpdateArgs} args - Arguments to update one Strike.
     * @example
     * // Update one Strike
     * const strike = await prisma.strike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrikeUpdateArgs>(args: SelectSubset<T, StrikeUpdateArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Strikes.
     * @param {StrikeDeleteManyArgs} args - Arguments to filter Strikes to delete.
     * @example
     * // Delete a few Strikes
     * const { count } = await prisma.strike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrikeDeleteManyArgs>(args?: SelectSubset<T, StrikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strikes
     * const strike = await prisma.strike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrikeUpdateManyArgs>(args: SelectSubset<T, StrikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Strike.
     * @param {StrikeUpsertArgs} args - Arguments to update or create a Strike.
     * @example
     * // Update or create a Strike
     * const strike = await prisma.strike.upsert({
     *   create: {
     *     // ... data to create a Strike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strike we want to update
     *   }
     * })
     */
    upsert<T extends StrikeUpsertArgs>(args: SelectSubset<T, StrikeUpsertArgs<ExtArgs>>): Prisma__StrikeClient<$Result.GetResult<Prisma.$StrikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Strikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeCountArgs} args - Arguments to filter Strikes to count.
     * @example
     * // Count the number of Strikes
     * const count = await prisma.strike.count({
     *   where: {
     *     // ... the filter for the Strikes we want to count
     *   }
     * })
    **/
    count<T extends StrikeCountArgs>(
      args?: Subset<T, StrikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrikeAggregateArgs>(args: Subset<T, StrikeAggregateArgs>): Prisma.PrismaPromise<GetStrikeAggregateType<T>>

    /**
     * Group by Strike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrikeGroupByArgs['orderBy'] }
        : { orderBy?: StrikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Strike model
   */
  readonly fields: StrikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Strike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translation<T extends Strike$translationArgs<ExtArgs> = {}>(args?: Subset<T, Strike$translationArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Strike model
   */ 
  interface StrikeFieldRefs {
    readonly id: FieldRef<"Strike", 'String'>
    readonly userId: FieldRef<"Strike", 'String'>
    readonly adminId: FieldRef<"Strike", 'String'>
    readonly reason: FieldRef<"Strike", 'StrikeReason'>
    readonly detailedReason: FieldRef<"Strike", 'String'>
    readonly translationId: FieldRef<"Strike", 'String'>
    readonly severity: FieldRef<"Strike", 'Int'>
    readonly isActive: FieldRef<"Strike", 'Boolean'>
    readonly expiresAt: FieldRef<"Strike", 'DateTime'>
    readonly createdAt: FieldRef<"Strike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Strike findUnique
   */
  export type StrikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter, which Strike to fetch.
     */
    where: StrikeWhereUniqueInput
  }

  /**
   * Strike findUniqueOrThrow
   */
  export type StrikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter, which Strike to fetch.
     */
    where: StrikeWhereUniqueInput
  }

  /**
   * Strike findFirst
   */
  export type StrikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter, which Strike to fetch.
     */
    where?: StrikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strikes to fetch.
     */
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strikes.
     */
    cursor?: StrikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strikes.
     */
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * Strike findFirstOrThrow
   */
  export type StrikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter, which Strike to fetch.
     */
    where?: StrikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strikes to fetch.
     */
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strikes.
     */
    cursor?: StrikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strikes.
     */
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * Strike findMany
   */
  export type StrikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter, which Strikes to fetch.
     */
    where?: StrikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strikes to fetch.
     */
    orderBy?: StrikeOrderByWithRelationInput | StrikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strikes.
     */
    cursor?: StrikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strikes.
     */
    skip?: number
    distinct?: StrikeScalarFieldEnum | StrikeScalarFieldEnum[]
  }

  /**
   * Strike create
   */
  export type StrikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Strike.
     */
    data: XOR<StrikeCreateInput, StrikeUncheckedCreateInput>
  }

  /**
   * Strike createMany
   */
  export type StrikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Strikes.
     */
    data: StrikeCreateManyInput | StrikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strike createManyAndReturn
   */
  export type StrikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Strikes.
     */
    data: StrikeCreateManyInput | StrikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strike update
   */
  export type StrikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Strike.
     */
    data: XOR<StrikeUpdateInput, StrikeUncheckedUpdateInput>
    /**
     * Choose, which Strike to update.
     */
    where: StrikeWhereUniqueInput
  }

  /**
   * Strike updateMany
   */
  export type StrikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Strikes.
     */
    data: XOR<StrikeUpdateManyMutationInput, StrikeUncheckedUpdateManyInput>
    /**
     * Filter which Strikes to update
     */
    where?: StrikeWhereInput
  }

  /**
   * Strike upsert
   */
  export type StrikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Strike to update in case it exists.
     */
    where: StrikeWhereUniqueInput
    /**
     * In case the Strike found by the `where` argument doesn't exist, create a new Strike with this data.
     */
    create: XOR<StrikeCreateInput, StrikeUncheckedCreateInput>
    /**
     * In case the Strike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrikeUpdateInput, StrikeUncheckedUpdateInput>
  }

  /**
   * Strike delete
   */
  export type StrikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
    /**
     * Filter which Strike to delete.
     */
    where: StrikeWhereUniqueInput
  }

  /**
   * Strike deleteMany
   */
  export type StrikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strikes to delete
     */
    where?: StrikeWhereInput
  }

  /**
   * Strike.translation
   */
  export type Strike$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
  }

  /**
   * Strike without action
   */
  export type StrikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strike
     */
    select?: StrikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrikeInclude<ExtArgs> | null
  }


  /**
   * Model SessionLog
   */

  export type AggregateSessionLog = {
    _count: SessionLogCountAggregateOutputType | null
    _avg: SessionLogAvgAggregateOutputType | null
    _sum: SessionLogSumAggregateOutputType | null
    _min: SessionLogMinAggregateOutputType | null
    _max: SessionLogMaxAggregateOutputType | null
  }

  export type SessionLogAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    duration: number | null
    actionsCount: number | null
    avgResponseTime: number | null
  }

  export type SessionLogSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    duration: number | null
    actionsCount: number | null
    avgResponseTime: number | null
  }

  export type SessionLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ipAddress: string | null
    country: string | null
    city: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    userAgent: string | null
    browser: string | null
    browserVersion: string | null
    os: string | null
    osVersion: string | null
    device: string | null
    isMobile: boolean | null
    sessionStart: Date | null
    sessionEnd: Date | null
    duration: number | null
    actionsCount: number | null
    avgResponseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ipAddress: string | null
    country: string | null
    city: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    userAgent: string | null
    browser: string | null
    browserVersion: string | null
    os: string | null
    osVersion: string | null
    device: string | null
    isMobile: boolean | null
    sessionStart: Date | null
    sessionEnd: Date | null
    duration: number | null
    actionsCount: number | null
    avgResponseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionLogCountAggregateOutputType = {
    id: number
    userId: number
    ipAddress: number
    country: number
    city: number
    region: number
    latitude: number
    longitude: number
    userAgent: number
    browser: number
    browserVersion: number
    os: number
    osVersion: number
    device: number
    isMobile: number
    sessionStart: number
    sessionEnd: number
    duration: number
    pagesVisited: number
    actionsCount: number
    avgResponseTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionLogAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    duration?: true
    actionsCount?: true
    avgResponseTime?: true
  }

  export type SessionLogSumAggregateInputType = {
    latitude?: true
    longitude?: true
    duration?: true
    actionsCount?: true
    avgResponseTime?: true
  }

  export type SessionLogMinAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    country?: true
    city?: true
    region?: true
    latitude?: true
    longitude?: true
    userAgent?: true
    browser?: true
    browserVersion?: true
    os?: true
    osVersion?: true
    device?: true
    isMobile?: true
    sessionStart?: true
    sessionEnd?: true
    duration?: true
    actionsCount?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionLogMaxAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    country?: true
    city?: true
    region?: true
    latitude?: true
    longitude?: true
    userAgent?: true
    browser?: true
    browserVersion?: true
    os?: true
    osVersion?: true
    device?: true
    isMobile?: true
    sessionStart?: true
    sessionEnd?: true
    duration?: true
    actionsCount?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionLogCountAggregateInputType = {
    id?: true
    userId?: true
    ipAddress?: true
    country?: true
    city?: true
    region?: true
    latitude?: true
    longitude?: true
    userAgent?: true
    browser?: true
    browserVersion?: true
    os?: true
    osVersion?: true
    device?: true
    isMobile?: true
    sessionStart?: true
    sessionEnd?: true
    duration?: true
    pagesVisited?: true
    actionsCount?: true
    avgResponseTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLog to aggregate.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionLogs
    **/
    _count?: true | SessionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionLogMaxAggregateInputType
  }

  export type GetSessionLogAggregateType<T extends SessionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionLog[P]>
      : GetScalarType<T[P], AggregateSessionLog[P]>
  }




  export type SessionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLogWhereInput
    orderBy?: SessionLogOrderByWithAggregationInput | SessionLogOrderByWithAggregationInput[]
    by: SessionLogScalarFieldEnum[] | SessionLogScalarFieldEnum
    having?: SessionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionLogCountAggregateInputType | true
    _avg?: SessionLogAvgAggregateInputType
    _sum?: SessionLogSumAggregateInputType
    _min?: SessionLogMinAggregateInputType
    _max?: SessionLogMaxAggregateInputType
  }

  export type SessionLogGroupByOutputType = {
    id: string
    userId: string | null
    ipAddress: string
    country: string | null
    city: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    userAgent: string
    browser: string | null
    browserVersion: string | null
    os: string | null
    osVersion: string | null
    device: string | null
    isMobile: boolean
    sessionStart: Date
    sessionEnd: Date | null
    duration: number | null
    pagesVisited: string[]
    actionsCount: number
    avgResponseTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: SessionLogCountAggregateOutputType | null
    _avg: SessionLogAvgAggregateOutputType | null
    _sum: SessionLogSumAggregateOutputType | null
    _min: SessionLogMinAggregateOutputType | null
    _max: SessionLogMaxAggregateOutputType | null
  }

  type GetSessionLogGroupByPayload<T extends SessionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionLogGroupByOutputType[P]>
            : GetScalarType<T[P], SessionLogGroupByOutputType[P]>
        }
      >
    >


  export type SessionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    country?: boolean
    city?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    userAgent?: boolean
    browser?: boolean
    browserVersion?: boolean
    os?: boolean
    osVersion?: boolean
    device?: boolean
    isMobile?: boolean
    sessionStart?: boolean
    sessionEnd?: boolean
    duration?: boolean
    pagesVisited?: boolean
    actionsCount?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SessionLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLog"]>

  export type SessionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    country?: boolean
    city?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    userAgent?: boolean
    browser?: boolean
    browserVersion?: boolean
    os?: boolean
    osVersion?: boolean
    device?: boolean
    isMobile?: boolean
    sessionStart?: boolean
    sessionEnd?: boolean
    duration?: boolean
    pagesVisited?: boolean
    actionsCount?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SessionLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLog"]>

  export type SessionLogSelectScalar = {
    id?: boolean
    userId?: boolean
    ipAddress?: boolean
    country?: boolean
    city?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    userAgent?: boolean
    browser?: boolean
    browserVersion?: boolean
    os?: boolean
    osVersion?: boolean
    device?: boolean
    isMobile?: boolean
    sessionStart?: boolean
    sessionEnd?: boolean
    duration?: boolean
    pagesVisited?: boolean
    actionsCount?: boolean
    avgResponseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SessionLog$userArgs<ExtArgs>
  }
  export type SessionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SessionLog$userArgs<ExtArgs>
  }

  export type $SessionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      ipAddress: string
      country: string | null
      city: string | null
      region: string | null
      latitude: number | null
      longitude: number | null
      userAgent: string
      browser: string | null
      browserVersion: string | null
      os: string | null
      osVersion: string | null
      device: string | null
      isMobile: boolean
      sessionStart: Date
      sessionEnd: Date | null
      duration: number | null
      pagesVisited: string[]
      actionsCount: number
      avgResponseTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionLog"]>
    composites: {}
  }

  type SessionLogGetPayload<S extends boolean | null | undefined | SessionLogDefaultArgs> = $Result.GetResult<Prisma.$SessionLogPayload, S>

  type SessionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionLogCountAggregateInputType | true
    }

  export interface SessionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionLog'], meta: { name: 'SessionLog' } }
    /**
     * Find zero or one SessionLog that matches the filter.
     * @param {SessionLogFindUniqueArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionLogFindUniqueArgs>(args: SelectSubset<T, SessionLogFindUniqueArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionLogFindUniqueOrThrowArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindFirstArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionLogFindFirstArgs>(args?: SelectSubset<T, SessionLogFindFirstArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindFirstOrThrowArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionLogs
     * const sessionLogs = await prisma.sessionLog.findMany()
     * 
     * // Get first 10 SessionLogs
     * const sessionLogs = await prisma.sessionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionLogWithIdOnly = await prisma.sessionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionLogFindManyArgs>(args?: SelectSubset<T, SessionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionLog.
     * @param {SessionLogCreateArgs} args - Arguments to create a SessionLog.
     * @example
     * // Create one SessionLog
     * const SessionLog = await prisma.sessionLog.create({
     *   data: {
     *     // ... data to create a SessionLog
     *   }
     * })
     * 
     */
    create<T extends SessionLogCreateArgs>(args: SelectSubset<T, SessionLogCreateArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionLogs.
     * @param {SessionLogCreateManyArgs} args - Arguments to create many SessionLogs.
     * @example
     * // Create many SessionLogs
     * const sessionLog = await prisma.sessionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionLogCreateManyArgs>(args?: SelectSubset<T, SessionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionLogs and returns the data saved in the database.
     * @param {SessionLogCreateManyAndReturnArgs} args - Arguments to create many SessionLogs.
     * @example
     * // Create many SessionLogs
     * const sessionLog = await prisma.sessionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionLogs and only return the `id`
     * const sessionLogWithIdOnly = await prisma.sessionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionLog.
     * @param {SessionLogDeleteArgs} args - Arguments to delete one SessionLog.
     * @example
     * // Delete one SessionLog
     * const SessionLog = await prisma.sessionLog.delete({
     *   where: {
     *     // ... filter to delete one SessionLog
     *   }
     * })
     * 
     */
    delete<T extends SessionLogDeleteArgs>(args: SelectSubset<T, SessionLogDeleteArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionLog.
     * @param {SessionLogUpdateArgs} args - Arguments to update one SessionLog.
     * @example
     * // Update one SessionLog
     * const sessionLog = await prisma.sessionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionLogUpdateArgs>(args: SelectSubset<T, SessionLogUpdateArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionLogs.
     * @param {SessionLogDeleteManyArgs} args - Arguments to filter SessionLogs to delete.
     * @example
     * // Delete a few SessionLogs
     * const { count } = await prisma.sessionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionLogDeleteManyArgs>(args?: SelectSubset<T, SessionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionLogs
     * const sessionLog = await prisma.sessionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionLogUpdateManyArgs>(args: SelectSubset<T, SessionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionLog.
     * @param {SessionLogUpsertArgs} args - Arguments to update or create a SessionLog.
     * @example
     * // Update or create a SessionLog
     * const sessionLog = await prisma.sessionLog.upsert({
     *   create: {
     *     // ... data to create a SessionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionLog we want to update
     *   }
     * })
     */
    upsert<T extends SessionLogUpsertArgs>(args: SelectSubset<T, SessionLogUpsertArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogCountArgs} args - Arguments to filter SessionLogs to count.
     * @example
     * // Count the number of SessionLogs
     * const count = await prisma.sessionLog.count({
     *   where: {
     *     // ... the filter for the SessionLogs we want to count
     *   }
     * })
    **/
    count<T extends SessionLogCountArgs>(
      args?: Subset<T, SessionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionLogAggregateArgs>(args: Subset<T, SessionLogAggregateArgs>): Prisma.PrismaPromise<GetSessionLogAggregateType<T>>

    /**
     * Group by SessionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionLogGroupByArgs['orderBy'] }
        : { orderBy?: SessionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionLog model
   */
  readonly fields: SessionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SessionLog$userArgs<ExtArgs> = {}>(args?: Subset<T, SessionLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionLog model
   */ 
  interface SessionLogFieldRefs {
    readonly id: FieldRef<"SessionLog", 'String'>
    readonly userId: FieldRef<"SessionLog", 'String'>
    readonly ipAddress: FieldRef<"SessionLog", 'String'>
    readonly country: FieldRef<"SessionLog", 'String'>
    readonly city: FieldRef<"SessionLog", 'String'>
    readonly region: FieldRef<"SessionLog", 'String'>
    readonly latitude: FieldRef<"SessionLog", 'Float'>
    readonly longitude: FieldRef<"SessionLog", 'Float'>
    readonly userAgent: FieldRef<"SessionLog", 'String'>
    readonly browser: FieldRef<"SessionLog", 'String'>
    readonly browserVersion: FieldRef<"SessionLog", 'String'>
    readonly os: FieldRef<"SessionLog", 'String'>
    readonly osVersion: FieldRef<"SessionLog", 'String'>
    readonly device: FieldRef<"SessionLog", 'String'>
    readonly isMobile: FieldRef<"SessionLog", 'Boolean'>
    readonly sessionStart: FieldRef<"SessionLog", 'DateTime'>
    readonly sessionEnd: FieldRef<"SessionLog", 'DateTime'>
    readonly duration: FieldRef<"SessionLog", 'Int'>
    readonly pagesVisited: FieldRef<"SessionLog", 'String[]'>
    readonly actionsCount: FieldRef<"SessionLog", 'Int'>
    readonly avgResponseTime: FieldRef<"SessionLog", 'Float'>
    readonly createdAt: FieldRef<"SessionLog", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionLog findUnique
   */
  export type SessionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog findUniqueOrThrow
   */
  export type SessionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog findFirst
   */
  export type SessionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLogs.
     */
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog findFirstOrThrow
   */
  export type SessionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLogs.
     */
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog findMany
   */
  export type SessionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLogs to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog create
   */
  export type SessionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionLog.
     */
    data: XOR<SessionLogCreateInput, SessionLogUncheckedCreateInput>
  }

  /**
   * SessionLog createMany
   */
  export type SessionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionLogs.
     */
    data: SessionLogCreateManyInput | SessionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionLog createManyAndReturn
   */
  export type SessionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionLogs.
     */
    data: SessionLogCreateManyInput | SessionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionLog update
   */
  export type SessionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionLog.
     */
    data: XOR<SessionLogUpdateInput, SessionLogUncheckedUpdateInput>
    /**
     * Choose, which SessionLog to update.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog updateMany
   */
  export type SessionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionLogs.
     */
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionLogs to update
     */
    where?: SessionLogWhereInput
  }

  /**
   * SessionLog upsert
   */
  export type SessionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionLog to update in case it exists.
     */
    where: SessionLogWhereUniqueInput
    /**
     * In case the SessionLog found by the `where` argument doesn't exist, create a new SessionLog with this data.
     */
    create: XOR<SessionLogCreateInput, SessionLogUncheckedCreateInput>
    /**
     * In case the SessionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionLogUpdateInput, SessionLogUncheckedUpdateInput>
  }

  /**
   * SessionLog delete
   */
  export type SessionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter which SessionLog to delete.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog deleteMany
   */
  export type SessionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLogs to delete
     */
    where?: SessionLogWhereInput
  }

  /**
   * SessionLog.user
   */
  export type SessionLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SessionLog without action
   */
  export type SessionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
  }


  /**
   * Model UserAnalytics
   */

  export type AggregateUserAnalytics = {
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  export type UserAnalyticsAvgAggregateOutputType = {
    translationsToday: number | null
    validationsToday: number | null
    loginStreak: number | null
    totalSessions: number | null
    avgSessionDuration: number | null
    preferredHours: number | null
    preferredDays: number | null
    avgTranslationTime: number | null
    avgValidationTime: number | null
    approvalRate: number | null
    avgConfidenceScore: number | null
  }

  export type UserAnalyticsSumAggregateOutputType = {
    translationsToday: number | null
    validationsToday: number | null
    loginStreak: number | null
    totalSessions: number | null
    avgSessionDuration: number | null
    preferredHours: number[]
    preferredDays: number[]
    avgTranslationTime: number | null
    avgValidationTime: number | null
    approvalRate: number | null
    avgConfidenceScore: number | null
  }

  export type UserAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    translationsToday: number | null
    validationsToday: number | null
    loginStreak: number | null
    lastActivityDate: Date | null
    totalSessions: number | null
    avgSessionDuration: number | null
    avgTranslationTime: number | null
    avgValidationTime: number | null
    approvalRate: number | null
    avgConfidenceScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    translationsToday: number | null
    validationsToday: number | null
    loginStreak: number | null
    lastActivityDate: Date | null
    totalSessions: number | null
    avgSessionDuration: number | null
    avgTranslationTime: number | null
    avgValidationTime: number | null
    approvalRate: number | null
    avgConfidenceScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    translationsToday: number
    validationsToday: number
    loginStreak: number
    lastActivityDate: number
    totalSessions: number
    avgSessionDuration: number
    preferredHours: number
    preferredDays: number
    mostUsedFeatures: number
    avgTranslationTime: number
    avgValidationTime: number
    approvalRate: number
    avgConfidenceScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAnalyticsAvgAggregateInputType = {
    translationsToday?: true
    validationsToday?: true
    loginStreak?: true
    totalSessions?: true
    avgSessionDuration?: true
    preferredHours?: true
    preferredDays?: true
    avgTranslationTime?: true
    avgValidationTime?: true
    approvalRate?: true
    avgConfidenceScore?: true
  }

  export type UserAnalyticsSumAggregateInputType = {
    translationsToday?: true
    validationsToday?: true
    loginStreak?: true
    totalSessions?: true
    avgSessionDuration?: true
    preferredHours?: true
    preferredDays?: true
    avgTranslationTime?: true
    avgValidationTime?: true
    approvalRate?: true
    avgConfidenceScore?: true
  }

  export type UserAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    translationsToday?: true
    validationsToday?: true
    loginStreak?: true
    lastActivityDate?: true
    totalSessions?: true
    avgSessionDuration?: true
    avgTranslationTime?: true
    avgValidationTime?: true
    approvalRate?: true
    avgConfidenceScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    translationsToday?: true
    validationsToday?: true
    loginStreak?: true
    lastActivityDate?: true
    totalSessions?: true
    avgSessionDuration?: true
    avgTranslationTime?: true
    avgValidationTime?: true
    approvalRate?: true
    avgConfidenceScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    translationsToday?: true
    validationsToday?: true
    loginStreak?: true
    lastActivityDate?: true
    totalSessions?: true
    avgSessionDuration?: true
    preferredHours?: true
    preferredDays?: true
    mostUsedFeatures?: true
    avgTranslationTime?: true
    avgValidationTime?: true
    approvalRate?: true
    avgConfidenceScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to aggregate.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnalytics
    **/
    _count?: true | UserAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type GetUserAnalyticsAggregateType<T extends UserAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnalytics[P]>
      : GetScalarType<T[P], AggregateUserAnalytics[P]>
  }




  export type UserAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnalyticsWhereInput
    orderBy?: UserAnalyticsOrderByWithAggregationInput | UserAnalyticsOrderByWithAggregationInput[]
    by: UserAnalyticsScalarFieldEnum[] | UserAnalyticsScalarFieldEnum
    having?: UserAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnalyticsCountAggregateInputType | true
    _avg?: UserAnalyticsAvgAggregateInputType
    _sum?: UserAnalyticsSumAggregateInputType
    _min?: UserAnalyticsMinAggregateInputType
    _max?: UserAnalyticsMaxAggregateInputType
  }

  export type UserAnalyticsGroupByOutputType = {
    id: string
    userId: string
    translationsToday: number
    validationsToday: number
    loginStreak: number
    lastActivityDate: Date | null
    totalSessions: number
    avgSessionDuration: number | null
    preferredHours: number[]
    preferredDays: number[]
    mostUsedFeatures: string[]
    avgTranslationTime: number | null
    avgValidationTime: number | null
    approvalRate: number | null
    avgConfidenceScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserAnalyticsCountAggregateOutputType | null
    _avg: UserAnalyticsAvgAggregateOutputType | null
    _sum: UserAnalyticsSumAggregateOutputType | null
    _min: UserAnalyticsMinAggregateOutputType | null
    _max: UserAnalyticsMaxAggregateOutputType | null
  }

  type GetUserAnalyticsGroupByPayload<T extends UserAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type UserAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    translationsToday?: boolean
    validationsToday?: boolean
    loginStreak?: boolean
    lastActivityDate?: boolean
    totalSessions?: boolean
    avgSessionDuration?: boolean
    preferredHours?: boolean
    preferredDays?: boolean
    mostUsedFeatures?: boolean
    avgTranslationTime?: boolean
    avgValidationTime?: boolean
    approvalRate?: boolean
    avgConfidenceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    translationsToday?: boolean
    validationsToday?: boolean
    loginStreak?: boolean
    lastActivityDate?: boolean
    totalSessions?: boolean
    avgSessionDuration?: boolean
    preferredHours?: boolean
    preferredDays?: boolean
    mostUsedFeatures?: boolean
    avgTranslationTime?: boolean
    avgValidationTime?: boolean
    approvalRate?: boolean
    avgConfidenceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnalytics"]>

  export type UserAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    translationsToday?: boolean
    validationsToday?: boolean
    loginStreak?: boolean
    lastActivityDate?: boolean
    totalSessions?: boolean
    avgSessionDuration?: boolean
    preferredHours?: boolean
    preferredDays?: boolean
    mostUsedFeatures?: boolean
    avgTranslationTime?: boolean
    avgValidationTime?: boolean
    approvalRate?: boolean
    avgConfidenceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      translationsToday: number
      validationsToday: number
      loginStreak: number
      lastActivityDate: Date | null
      totalSessions: number
      avgSessionDuration: number | null
      preferredHours: number[]
      preferredDays: number[]
      mostUsedFeatures: string[]
      avgTranslationTime: number | null
      avgValidationTime: number | null
      approvalRate: number | null
      avgConfidenceScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAnalytics"]>
    composites: {}
  }

  type UserAnalyticsGetPayload<S extends boolean | null | undefined | UserAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$UserAnalyticsPayload, S>

  type UserAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAnalyticsCountAggregateInputType | true
    }

  export interface UserAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnalytics'], meta: { name: 'UserAnalytics' } }
    /**
     * Find zero or one UserAnalytics that matches the filter.
     * @param {UserAnalyticsFindUniqueArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAnalyticsFindUniqueArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAnalyticsFindFirstArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindFirstOrThrowArgs} args - Arguments to find a UserAnalytics
     * @example
     * // Get one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany()
     * 
     * // Get first 10 UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAnalyticsFindManyArgs>(args?: SelectSubset<T, UserAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAnalytics.
     * @param {UserAnalyticsCreateArgs} args - Arguments to create a UserAnalytics.
     * @example
     * // Create one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.create({
     *   data: {
     *     // ... data to create a UserAnalytics
     *   }
     * })
     * 
     */
    create<T extends UserAnalyticsCreateArgs>(args: SelectSubset<T, UserAnalyticsCreateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAnalytics.
     * @param {UserAnalyticsCreateManyArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAnalyticsCreateManyArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAnalytics and returns the data saved in the database.
     * @param {UserAnalyticsCreateManyAndReturnArgs} args - Arguments to create many UserAnalytics.
     * @example
     * // Create many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAnalytics and only return the `id`
     * const userAnalyticsWithIdOnly = await prisma.userAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAnalytics.
     * @param {UserAnalyticsDeleteArgs} args - Arguments to delete one UserAnalytics.
     * @example
     * // Delete one UserAnalytics
     * const UserAnalytics = await prisma.userAnalytics.delete({
     *   where: {
     *     // ... filter to delete one UserAnalytics
     *   }
     * })
     * 
     */
    delete<T extends UserAnalyticsDeleteArgs>(args: SelectSubset<T, UserAnalyticsDeleteArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAnalytics.
     * @param {UserAnalyticsUpdateArgs} args - Arguments to update one UserAnalytics.
     * @example
     * // Update one UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAnalyticsUpdateArgs>(args: SelectSubset<T, UserAnalyticsUpdateArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAnalytics.
     * @param {UserAnalyticsDeleteManyArgs} args - Arguments to filter UserAnalytics to delete.
     * @example
     * // Delete a few UserAnalytics
     * const { count } = await prisma.userAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAnalyticsDeleteManyArgs>(args?: SelectSubset<T, UserAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAnalyticsUpdateManyArgs>(args: SelectSubset<T, UserAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAnalytics.
     * @param {UserAnalyticsUpsertArgs} args - Arguments to update or create a UserAnalytics.
     * @example
     * // Update or create a UserAnalytics
     * const userAnalytics = await prisma.userAnalytics.upsert({
     *   create: {
     *     // ... data to create a UserAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends UserAnalyticsUpsertArgs>(args: SelectSubset<T, UserAnalyticsUpsertArgs<ExtArgs>>): Prisma__UserAnalyticsClient<$Result.GetResult<Prisma.$UserAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsCountArgs} args - Arguments to filter UserAnalytics to count.
     * @example
     * // Count the number of UserAnalytics
     * const count = await prisma.userAnalytics.count({
     *   where: {
     *     // ... the filter for the UserAnalytics we want to count
     *   }
     * })
    **/
    count<T extends UserAnalyticsCountArgs>(
      args?: Subset<T, UserAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnalyticsAggregateArgs>(args: Subset<T, UserAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetUserAnalyticsAggregateType<T>>

    /**
     * Group by UserAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: UserAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnalytics model
   */
  readonly fields: UserAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAnalytics model
   */ 
  interface UserAnalyticsFieldRefs {
    readonly id: FieldRef<"UserAnalytics", 'String'>
    readonly userId: FieldRef<"UserAnalytics", 'String'>
    readonly translationsToday: FieldRef<"UserAnalytics", 'Int'>
    readonly validationsToday: FieldRef<"UserAnalytics", 'Int'>
    readonly loginStreak: FieldRef<"UserAnalytics", 'Int'>
    readonly lastActivityDate: FieldRef<"UserAnalytics", 'DateTime'>
    readonly totalSessions: FieldRef<"UserAnalytics", 'Int'>
    readonly avgSessionDuration: FieldRef<"UserAnalytics", 'Float'>
    readonly preferredHours: FieldRef<"UserAnalytics", 'Int[]'>
    readonly preferredDays: FieldRef<"UserAnalytics", 'Int[]'>
    readonly mostUsedFeatures: FieldRef<"UserAnalytics", 'String[]'>
    readonly avgTranslationTime: FieldRef<"UserAnalytics", 'Float'>
    readonly avgValidationTime: FieldRef<"UserAnalytics", 'Float'>
    readonly approvalRate: FieldRef<"UserAnalytics", 'Float'>
    readonly avgConfidenceScore: FieldRef<"UserAnalytics", 'Float'>
    readonly createdAt: FieldRef<"UserAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAnalytics findUnique
   */
  export type UserAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findUniqueOrThrow
   */
  export type UserAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics findFirst
   */
  export type UserAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findFirstOrThrow
   */
  export type UserAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnalytics.
     */
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics findMany
   */
  export type UserAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UserAnalytics to fetch.
     */
    where?: UserAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnalytics to fetch.
     */
    orderBy?: UserAnalyticsOrderByWithRelationInput | UserAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnalytics.
     */
    cursor?: UserAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnalytics.
     */
    skip?: number
    distinct?: UserAnalyticsScalarFieldEnum | UserAnalyticsScalarFieldEnum[]
  }

  /**
   * UserAnalytics create
   */
  export type UserAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAnalytics.
     */
    data: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
  }

  /**
   * UserAnalytics createMany
   */
  export type UserAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnalytics createManyAndReturn
   */
  export type UserAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAnalytics.
     */
    data: UserAnalyticsCreateManyInput | UserAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAnalytics update
   */
  export type UserAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which UserAnalytics to update.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics updateMany
   */
  export type UserAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnalytics.
     */
    data: XOR<UserAnalyticsUpdateManyMutationInput, UserAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UserAnalytics to update
     */
    where?: UserAnalyticsWhereInput
  }

  /**
   * UserAnalytics upsert
   */
  export type UserAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAnalytics to update in case it exists.
     */
    where: UserAnalyticsWhereUniqueInput
    /**
     * In case the UserAnalytics found by the `where` argument doesn't exist, create a new UserAnalytics with this data.
     */
    create: XOR<UserAnalyticsCreateInput, UserAnalyticsUncheckedCreateInput>
    /**
     * In case the UserAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnalyticsUpdateInput, UserAnalyticsUncheckedUpdateInput>
  }

  /**
   * UserAnalytics delete
   */
  export type UserAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which UserAnalytics to delete.
     */
    where: UserAnalyticsWhereUniqueInput
  }

  /**
   * UserAnalytics deleteMany
   */
  export type UserAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnalytics to delete
     */
    where?: UserAnalyticsWhereInput
  }

  /**
   * UserAnalytics without action
   */
  export type UserAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnalytics
     */
    select?: UserAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model ApiMetrics
   */

  export type AggregateApiMetrics = {
    _count: ApiMetricsCountAggregateOutputType | null
    _avg: ApiMetricsAvgAggregateOutputType | null
    _sum: ApiMetricsSumAggregateOutputType | null
    _min: ApiMetricsMinAggregateOutputType | null
    _max: ApiMetricsMaxAggregateOutputType | null
  }

  export type ApiMetricsAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type ApiMetricsSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type ApiMetricsMinAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    errorMessage: string | null
    errorStack: string | null
    timestamp: Date | null
  }

  export type ApiMetricsMaxAggregateOutputType = {
    id: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    errorMessage: string | null
    errorStack: string | null
    timestamp: Date | null
  }

  export type ApiMetricsCountAggregateOutputType = {
    id: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    userId: number
    ipAddress: number
    userAgent: number
    errorMessage: number
    errorStack: number
    timestamp: number
    _all: number
  }


  export type ApiMetricsAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type ApiMetricsSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type ApiMetricsMinAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    errorStack?: true
    timestamp?: true
  }

  export type ApiMetricsMaxAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    errorStack?: true
    timestamp?: true
  }

  export type ApiMetricsCountAggregateInputType = {
    id?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    errorMessage?: true
    errorStack?: true
    timestamp?: true
    _all?: true
  }

  export type ApiMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiMetrics to aggregate.
     */
    where?: ApiMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiMetrics to fetch.
     */
    orderBy?: ApiMetricsOrderByWithRelationInput | ApiMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiMetrics
    **/
    _count?: true | ApiMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiMetricsMaxAggregateInputType
  }

  export type GetApiMetricsAggregateType<T extends ApiMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateApiMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiMetrics[P]>
      : GetScalarType<T[P], AggregateApiMetrics[P]>
  }




  export type ApiMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiMetricsWhereInput
    orderBy?: ApiMetricsOrderByWithAggregationInput | ApiMetricsOrderByWithAggregationInput[]
    by: ApiMetricsScalarFieldEnum[] | ApiMetricsScalarFieldEnum
    having?: ApiMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiMetricsCountAggregateInputType | true
    _avg?: ApiMetricsAvgAggregateInputType
    _sum?: ApiMetricsSumAggregateInputType
    _min?: ApiMetricsMinAggregateInputType
    _max?: ApiMetricsMaxAggregateInputType
  }

  export type ApiMetricsGroupByOutputType = {
    id: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    userId: string | null
    ipAddress: string
    userAgent: string
    errorMessage: string | null
    errorStack: string | null
    timestamp: Date
    _count: ApiMetricsCountAggregateOutputType | null
    _avg: ApiMetricsAvgAggregateOutputType | null
    _sum: ApiMetricsSumAggregateOutputType | null
    _min: ApiMetricsMinAggregateOutputType | null
    _max: ApiMetricsMaxAggregateOutputType | null
  }

  type GetApiMetricsGroupByPayload<T extends ApiMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], ApiMetricsGroupByOutputType[P]>
        }
      >
    >


  export type ApiMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiMetrics"]>

  export type ApiMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["apiMetrics"]>

  export type ApiMetricsSelectScalar = {
    id?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    timestamp?: boolean
  }


  export type $ApiMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endpoint: string
      method: string
      statusCode: number
      responseTime: number
      userId: string | null
      ipAddress: string
      userAgent: string
      errorMessage: string | null
      errorStack: string | null
      timestamp: Date
    }, ExtArgs["result"]["apiMetrics"]>
    composites: {}
  }

  type ApiMetricsGetPayload<S extends boolean | null | undefined | ApiMetricsDefaultArgs> = $Result.GetResult<Prisma.$ApiMetricsPayload, S>

  type ApiMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiMetricsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiMetricsCountAggregateInputType | true
    }

  export interface ApiMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiMetrics'], meta: { name: 'ApiMetrics' } }
    /**
     * Find zero or one ApiMetrics that matches the filter.
     * @param {ApiMetricsFindUniqueArgs} args - Arguments to find a ApiMetrics
     * @example
     * // Get one ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiMetricsFindUniqueArgs>(args: SelectSubset<T, ApiMetricsFindUniqueArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiMetrics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiMetricsFindUniqueOrThrowArgs} args - Arguments to find a ApiMetrics
     * @example
     * // Get one ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsFindFirstArgs} args - Arguments to find a ApiMetrics
     * @example
     * // Get one ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiMetricsFindFirstArgs>(args?: SelectSubset<T, ApiMetricsFindFirstArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsFindFirstOrThrowArgs} args - Arguments to find a ApiMetrics
     * @example
     * // Get one ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findMany()
     * 
     * // Get first 10 ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiMetricsWithIdOnly = await prisma.apiMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiMetricsFindManyArgs>(args?: SelectSubset<T, ApiMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiMetrics.
     * @param {ApiMetricsCreateArgs} args - Arguments to create a ApiMetrics.
     * @example
     * // Create one ApiMetrics
     * const ApiMetrics = await prisma.apiMetrics.create({
     *   data: {
     *     // ... data to create a ApiMetrics
     *   }
     * })
     * 
     */
    create<T extends ApiMetricsCreateArgs>(args: SelectSubset<T, ApiMetricsCreateArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiMetrics.
     * @param {ApiMetricsCreateManyArgs} args - Arguments to create many ApiMetrics.
     * @example
     * // Create many ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiMetricsCreateManyArgs>(args?: SelectSubset<T, ApiMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiMetrics and returns the data saved in the database.
     * @param {ApiMetricsCreateManyAndReturnArgs} args - Arguments to create many ApiMetrics.
     * @example
     * // Create many ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiMetrics and only return the `id`
     * const apiMetricsWithIdOnly = await prisma.apiMetrics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiMetrics.
     * @param {ApiMetricsDeleteArgs} args - Arguments to delete one ApiMetrics.
     * @example
     * // Delete one ApiMetrics
     * const ApiMetrics = await prisma.apiMetrics.delete({
     *   where: {
     *     // ... filter to delete one ApiMetrics
     *   }
     * })
     * 
     */
    delete<T extends ApiMetricsDeleteArgs>(args: SelectSubset<T, ApiMetricsDeleteArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiMetrics.
     * @param {ApiMetricsUpdateArgs} args - Arguments to update one ApiMetrics.
     * @example
     * // Update one ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiMetricsUpdateArgs>(args: SelectSubset<T, ApiMetricsUpdateArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiMetrics.
     * @param {ApiMetricsDeleteManyArgs} args - Arguments to filter ApiMetrics to delete.
     * @example
     * // Delete a few ApiMetrics
     * const { count } = await prisma.apiMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiMetricsDeleteManyArgs>(args?: SelectSubset<T, ApiMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiMetricsUpdateManyArgs>(args: SelectSubset<T, ApiMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiMetrics.
     * @param {ApiMetricsUpsertArgs} args - Arguments to update or create a ApiMetrics.
     * @example
     * // Update or create a ApiMetrics
     * const apiMetrics = await prisma.apiMetrics.upsert({
     *   create: {
     *     // ... data to create a ApiMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiMetrics we want to update
     *   }
     * })
     */
    upsert<T extends ApiMetricsUpsertArgs>(args: SelectSubset<T, ApiMetricsUpsertArgs<ExtArgs>>): Prisma__ApiMetricsClient<$Result.GetResult<Prisma.$ApiMetricsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsCountArgs} args - Arguments to filter ApiMetrics to count.
     * @example
     * // Count the number of ApiMetrics
     * const count = await prisma.apiMetrics.count({
     *   where: {
     *     // ... the filter for the ApiMetrics we want to count
     *   }
     * })
    **/
    count<T extends ApiMetricsCountArgs>(
      args?: Subset<T, ApiMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiMetricsAggregateArgs>(args: Subset<T, ApiMetricsAggregateArgs>): Prisma.PrismaPromise<GetApiMetricsAggregateType<T>>

    /**
     * Group by ApiMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiMetricsGroupByArgs['orderBy'] }
        : { orderBy?: ApiMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiMetrics model
   */
  readonly fields: ApiMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiMetrics model
   */ 
  interface ApiMetricsFieldRefs {
    readonly id: FieldRef<"ApiMetrics", 'String'>
    readonly endpoint: FieldRef<"ApiMetrics", 'String'>
    readonly method: FieldRef<"ApiMetrics", 'String'>
    readonly statusCode: FieldRef<"ApiMetrics", 'Int'>
    readonly responseTime: FieldRef<"ApiMetrics", 'Float'>
    readonly userId: FieldRef<"ApiMetrics", 'String'>
    readonly ipAddress: FieldRef<"ApiMetrics", 'String'>
    readonly userAgent: FieldRef<"ApiMetrics", 'String'>
    readonly errorMessage: FieldRef<"ApiMetrics", 'String'>
    readonly errorStack: FieldRef<"ApiMetrics", 'String'>
    readonly timestamp: FieldRef<"ApiMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiMetrics findUnique
   */
  export type ApiMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter, which ApiMetrics to fetch.
     */
    where: ApiMetricsWhereUniqueInput
  }

  /**
   * ApiMetrics findUniqueOrThrow
   */
  export type ApiMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter, which ApiMetrics to fetch.
     */
    where: ApiMetricsWhereUniqueInput
  }

  /**
   * ApiMetrics findFirst
   */
  export type ApiMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter, which ApiMetrics to fetch.
     */
    where?: ApiMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiMetrics to fetch.
     */
    orderBy?: ApiMetricsOrderByWithRelationInput | ApiMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiMetrics.
     */
    cursor?: ApiMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiMetrics.
     */
    distinct?: ApiMetricsScalarFieldEnum | ApiMetricsScalarFieldEnum[]
  }

  /**
   * ApiMetrics findFirstOrThrow
   */
  export type ApiMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter, which ApiMetrics to fetch.
     */
    where?: ApiMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiMetrics to fetch.
     */
    orderBy?: ApiMetricsOrderByWithRelationInput | ApiMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiMetrics.
     */
    cursor?: ApiMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiMetrics.
     */
    distinct?: ApiMetricsScalarFieldEnum | ApiMetricsScalarFieldEnum[]
  }

  /**
   * ApiMetrics findMany
   */
  export type ApiMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter, which ApiMetrics to fetch.
     */
    where?: ApiMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiMetrics to fetch.
     */
    orderBy?: ApiMetricsOrderByWithRelationInput | ApiMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiMetrics.
     */
    cursor?: ApiMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiMetrics.
     */
    skip?: number
    distinct?: ApiMetricsScalarFieldEnum | ApiMetricsScalarFieldEnum[]
  }

  /**
   * ApiMetrics create
   */
  export type ApiMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * The data needed to create a ApiMetrics.
     */
    data: XOR<ApiMetricsCreateInput, ApiMetricsUncheckedCreateInput>
  }

  /**
   * ApiMetrics createMany
   */
  export type ApiMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiMetrics.
     */
    data: ApiMetricsCreateManyInput | ApiMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiMetrics createManyAndReturn
   */
  export type ApiMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiMetrics.
     */
    data: ApiMetricsCreateManyInput | ApiMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiMetrics update
   */
  export type ApiMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * The data needed to update a ApiMetrics.
     */
    data: XOR<ApiMetricsUpdateInput, ApiMetricsUncheckedUpdateInput>
    /**
     * Choose, which ApiMetrics to update.
     */
    where: ApiMetricsWhereUniqueInput
  }

  /**
   * ApiMetrics updateMany
   */
  export type ApiMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiMetrics.
     */
    data: XOR<ApiMetricsUpdateManyMutationInput, ApiMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ApiMetrics to update
     */
    where?: ApiMetricsWhereInput
  }

  /**
   * ApiMetrics upsert
   */
  export type ApiMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * The filter to search for the ApiMetrics to update in case it exists.
     */
    where: ApiMetricsWhereUniqueInput
    /**
     * In case the ApiMetrics found by the `where` argument doesn't exist, create a new ApiMetrics with this data.
     */
    create: XOR<ApiMetricsCreateInput, ApiMetricsUncheckedCreateInput>
    /**
     * In case the ApiMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiMetricsUpdateInput, ApiMetricsUncheckedUpdateInput>
  }

  /**
   * ApiMetrics delete
   */
  export type ApiMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
    /**
     * Filter which ApiMetrics to delete.
     */
    where: ApiMetricsWhereUniqueInput
  }

  /**
   * ApiMetrics deleteMany
   */
  export type ApiMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiMetrics to delete
     */
    where?: ApiMetricsWhereInput
  }

  /**
   * ApiMetrics without action
   */
  export type ApiMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiMetrics
     */
    select?: ApiMetricsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    username: 'username',
    password: 'password',
    orcidId: 'orcidId',
    role: 'role',
    institution: 'institution',
    specialty: 'specialty',
    country: 'country',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    profileJson: 'profileJson',
    points: 'points',
    level: 'level',
    streak: 'streak',
    lastActiveAt: 'lastActiveAt',
    lastLoginAt: 'lastLoginAt',
    approvedCount: 'approvedCount',
    hasCompletedOnboarding: 'hasCompletedOnboarding',
    warningCount: 'warningCount',
    lastWarningAt: 'lastWarningAt',
    bannedBy: 'bannedBy',
    promotedAt: 'promotedAt',
    isActive: 'isActive',
    isBanned: 'isBanned',
    bannedAt: 'bannedAt',
    bannedReason: 'bannedReason',
    isVerified: 'isVerified',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HpoTermScalarFieldEnum: {
    id: 'id',
    hpoId: 'hpoId',
    labelEn: 'labelEn',
    definitionEn: 'definitionEn',
    synonymsEn: 'synonymsEn',
    category: 'category',
    parentId: 'parentId',
    difficulty: 'difficulty',
    translationStatus: 'translationStatus',
    hpoVersion: 'hpoVersion',
    isObsolete: 'isObsolete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HpoTermScalarFieldEnum = (typeof HpoTermScalarFieldEnum)[keyof typeof HpoTermScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    id: 'id',
    termId: 'termId',
    userId: 'userId',
    labelPt: 'labelPt',
    definitionPt: 'definitionPt',
    synonymsPt: 'synonymsPt',
    notes: 'notes',
    status: 'status',
    confidence: 'confidence',
    source: 'source',
    isLegacy: 'isLegacy',
    aiSuggestion: 'aiSuggestion',
    aiConfidence: 'aiConfidence',
    approvalCount: 'approvalCount',
    rejectionCount: 'rejectionCount',
    averageRating: 'averageRating',
    syncedToHpo: 'syncedToHpo',
    syncedAt: 'syncedAt',
    approvedBy: 'approvedBy',
    rejectedBy: 'rejectedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approvedAt: 'approvedAt'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const ValidationScalarFieldEnum: {
    id: 'id',
    translationId: 'translationId',
    validatorId: 'validatorId',
    rating: 'rating',
    decision: 'decision',
    comments: 'comments',
    suggestions: 'suggestions',
    accuracyScore: 'accuracyScore',
    clarityScore: 'clarityScore',
    consistencyScore: 'consistencyScore',
    timeSpentSeconds: 'timeSpentSeconds',
    createdAt: 'createdAt'
  };

  export type ValidationScalarFieldEnum = (typeof ValidationScalarFieldEnum)[keyof typeof ValidationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    translationId: 'translationId',
    userId: 'userId',
    content: 'content',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl',
    points: 'points',
    rarity: 'rarity',
    createdAt: 'createdAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    earnedAt: 'earnedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const UserActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    points: 'points',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UserActivityScalarFieldEnum = (typeof UserActivityScalarFieldEnum)[keyof typeof UserActivityScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const ConflictReviewScalarFieldEnum: {
    id: 'id',
    hpoTermId: 'hpoTermId',
    type: 'type',
    status: 'status',
    priority: 'priority',
    winningTranslationId: 'winningTranslationId',
    resolution: 'resolution',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConflictReviewScalarFieldEnum = (typeof ConflictReviewScalarFieldEnum)[keyof typeof ConflictReviewScalarFieldEnum]


  export const CommitteeVoteScalarFieldEnum: {
    id: 'id',
    conflictReviewId: 'conflictReviewId',
    voterId: 'voterId',
    translationId: 'translationId',
    voteType: 'voteType',
    comment: 'comment',
    votedAt: 'votedAt'
  };

  export type CommitteeVoteScalarFieldEnum = (typeof CommitteeVoteScalarFieldEnum)[keyof typeof CommitteeVoteScalarFieldEnum]


  export const RejectionScalarFieldEnum: {
    id: 'id',
    translationId: 'translationId',
    rejectedBy: 'rejectedBy',
    reasonCode: 'reasonCode',
    detailedReason: 'detailedReason',
    suggestions: 'suggestions',
    canResubmit: 'canResubmit',
    createdAt: 'createdAt'
  };

  export type RejectionScalarFieldEnum = (typeof RejectionScalarFieldEnum)[keyof typeof RejectionScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    changes: 'changes',
    reason: 'reason',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    syncDate: 'syncDate',
    initiatedBy: 'initiatedBy',
    translationsCount: 'translationsCount',
    babelonFilePath: 'babelonFilePath',
    githubPrUrl: 'githubPrUrl',
    status: 'status',
    errorMessage: 'errorMessage',
    completedAt: 'completedAt'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    link: 'link',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const StrikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    reason: 'reason',
    detailedReason: 'detailedReason',
    translationId: 'translationId',
    severity: 'severity',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type StrikeScalarFieldEnum = (typeof StrikeScalarFieldEnum)[keyof typeof StrikeScalarFieldEnum]


  export const SessionLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ipAddress: 'ipAddress',
    country: 'country',
    city: 'city',
    region: 'region',
    latitude: 'latitude',
    longitude: 'longitude',
    userAgent: 'userAgent',
    browser: 'browser',
    browserVersion: 'browserVersion',
    os: 'os',
    osVersion: 'osVersion',
    device: 'device',
    isMobile: 'isMobile',
    sessionStart: 'sessionStart',
    sessionEnd: 'sessionEnd',
    duration: 'duration',
    pagesVisited: 'pagesVisited',
    actionsCount: 'actionsCount',
    avgResponseTime: 'avgResponseTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionLogScalarFieldEnum = (typeof SessionLogScalarFieldEnum)[keyof typeof SessionLogScalarFieldEnum]


  export const UserAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    translationsToday: 'translationsToday',
    validationsToday: 'validationsToday',
    loginStreak: 'loginStreak',
    lastActivityDate: 'lastActivityDate',
    totalSessions: 'totalSessions',
    avgSessionDuration: 'avgSessionDuration',
    preferredHours: 'preferredHours',
    preferredDays: 'preferredDays',
    mostUsedFeatures: 'mostUsedFeatures',
    avgTranslationTime: 'avgTranslationTime',
    avgValidationTime: 'avgValidationTime',
    approvalRate: 'approvalRate',
    avgConfidenceScore: 'avgConfidenceScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAnalyticsScalarFieldEnum = (typeof UserAnalyticsScalarFieldEnum)[keyof typeof UserAnalyticsScalarFieldEnum]


  export const ApiMetricsScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    userId: 'userId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack',
    timestamp: 'timestamp'
  };

  export type ApiMetricsScalarFieldEnum = (typeof ApiMetricsScalarFieldEnum)[keyof typeof ApiMetricsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TranslationStatus'
   */
  export type EnumTranslationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationStatus'>
    


  /**
   * Reference to a field of type 'TranslationStatus[]'
   */
  export type ListEnumTranslationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationStatus[]'>
    


  /**
   * Reference to a field of type 'TranslationSource'
   */
  export type EnumTranslationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationSource'>
    


  /**
   * Reference to a field of type 'TranslationSource[]'
   */
  export type ListEnumTranslationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranslationSource[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ValidationDecision'
   */
  export type EnumValidationDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValidationDecision'>
    


  /**
   * Reference to a field of type 'ValidationDecision[]'
   */
  export type ListEnumValidationDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValidationDecision[]'>
    


  /**
   * Reference to a field of type 'BadgeRarity'
   */
  export type EnumBadgeRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeRarity'>
    


  /**
   * Reference to a field of type 'BadgeRarity[]'
   */
  export type ListEnumBadgeRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BadgeRarity[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'ConflictType'
   */
  export type EnumConflictTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConflictType'>
    


  /**
   * Reference to a field of type 'ConflictType[]'
   */
  export type ListEnumConflictTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConflictType[]'>
    


  /**
   * Reference to a field of type 'ConflictStatus'
   */
  export type EnumConflictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConflictStatus'>
    


  /**
   * Reference to a field of type 'ConflictStatus[]'
   */
  export type ListEnumConflictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConflictStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'VoteType'
   */
  export type EnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType'>
    


  /**
   * Reference to a field of type 'VoteType[]'
   */
  export type ListEnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType[]'>
    


  /**
   * Reference to a field of type 'RejectionReason'
   */
  export type EnumRejectionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RejectionReason'>
    


  /**
   * Reference to a field of type 'RejectionReason[]'
   */
  export type ListEnumRejectionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RejectionReason[]'>
    


  /**
   * Reference to a field of type 'AdminAction'
   */
  export type EnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction'>
    


  /**
   * Reference to a field of type 'AdminAction[]'
   */
  export type ListEnumAdminActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminAction[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'StrikeReason'
   */
  export type EnumStrikeReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StrikeReason'>
    


  /**
   * Reference to a field of type 'StrikeReason[]'
   */
  export type ListEnumStrikeReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StrikeReason[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    orcidId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    institution?: StringNullableFilter<"User"> | string | null
    specialty?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    profileJson?: JsonNullableFilter<"User">
    points?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    approvedCount?: IntFilter<"User"> | number
    hasCompletedOnboarding?: BoolFilter<"User"> | boolean
    warningCount?: IntFilter<"User"> | number
    lastWarningAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bannedBy?: StringNullableFilter<"User"> | string | null
    promotedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    isBanned?: BoolFilter<"User"> | boolean
    bannedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bannedReason?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    translations?: TranslationListRelationFilter
    validations?: ValidationListRelationFilter
    comments?: CommentListRelationFilter
    badges?: UserBadgeListRelationFilter
    activities?: UserActivityListRelationFilter
    conflictVotes?: CommitteeVoteListRelationFilter
    rejectionsMade?: RejectionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    syncLogs?: SyncLogListRelationFilter
    notificationsSent?: NotificationListRelationFilter
    conflictsResolved?: ConflictReviewListRelationFilter
    strikes?: StrikeListRelationFilter
    strikesGiven?: StrikeListRelationFilter
    sessions?: SessionLogListRelationFilter
    analytics?: XOR<UserAnalyticsNullableRelationFilter, UserAnalyticsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    orcidId?: SortOrderInput | SortOrder
    role?: SortOrder
    institution?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    profileJson?: SortOrderInput | SortOrder
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    approvedCount?: SortOrder
    hasCompletedOnboarding?: SortOrder
    warningCount?: SortOrder
    lastWarningAt?: SortOrderInput | SortOrder
    bannedBy?: SortOrderInput | SortOrder
    promotedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrderInput | SortOrder
    bannedReason?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: TranslationOrderByRelationAggregateInput
    validations?: ValidationOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    activities?: UserActivityOrderByRelationAggregateInput
    conflictVotes?: CommitteeVoteOrderByRelationAggregateInput
    rejectionsMade?: RejectionOrderByRelationAggregateInput
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
    syncLogs?: SyncLogOrderByRelationAggregateInput
    notificationsSent?: NotificationOrderByRelationAggregateInput
    conflictsResolved?: ConflictReviewOrderByRelationAggregateInput
    strikes?: StrikeOrderByRelationAggregateInput
    strikesGiven?: StrikeOrderByRelationAggregateInput
    sessions?: SessionLogOrderByRelationAggregateInput
    analytics?: UserAnalyticsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    orcidId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    institution?: StringNullableFilter<"User"> | string | null
    specialty?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    profileJson?: JsonNullableFilter<"User">
    points?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    approvedCount?: IntFilter<"User"> | number
    hasCompletedOnboarding?: BoolFilter<"User"> | boolean
    warningCount?: IntFilter<"User"> | number
    lastWarningAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bannedBy?: StringNullableFilter<"User"> | string | null
    promotedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    isBanned?: BoolFilter<"User"> | boolean
    bannedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    bannedReason?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    translations?: TranslationListRelationFilter
    validations?: ValidationListRelationFilter
    comments?: CommentListRelationFilter
    badges?: UserBadgeListRelationFilter
    activities?: UserActivityListRelationFilter
    conflictVotes?: CommitteeVoteListRelationFilter
    rejectionsMade?: RejectionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    syncLogs?: SyncLogListRelationFilter
    notificationsSent?: NotificationListRelationFilter
    conflictsResolved?: ConflictReviewListRelationFilter
    strikes?: StrikeListRelationFilter
    strikesGiven?: StrikeListRelationFilter
    sessions?: SessionLogListRelationFilter
    analytics?: XOR<UserAnalyticsNullableRelationFilter, UserAnalyticsWhereInput> | null
  }, "id" | "email" | "username" | "orcidId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    orcidId?: SortOrderInput | SortOrder
    role?: SortOrder
    institution?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    profileJson?: SortOrderInput | SortOrder
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    approvedCount?: SortOrder
    hasCompletedOnboarding?: SortOrder
    warningCount?: SortOrder
    lastWarningAt?: SortOrderInput | SortOrder
    bannedBy?: SortOrderInput | SortOrder
    promotedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrderInput | SortOrder
    bannedReason?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    orcidId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    institution?: StringNullableWithAggregatesFilter<"User"> | string | null
    specialty?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileJson?: JsonNullableWithAggregatesFilter<"User">
    points?: IntWithAggregatesFilter<"User"> | number
    level?: IntWithAggregatesFilter<"User"> | number
    streak?: IntWithAggregatesFilter<"User"> | number
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    approvedCount?: IntWithAggregatesFilter<"User"> | number
    hasCompletedOnboarding?: BoolWithAggregatesFilter<"User"> | boolean
    warningCount?: IntWithAggregatesFilter<"User"> | number
    lastWarningAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bannedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    promotedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    bannedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bannedReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type HpoTermWhereInput = {
    AND?: HpoTermWhereInput | HpoTermWhereInput[]
    OR?: HpoTermWhereInput[]
    NOT?: HpoTermWhereInput | HpoTermWhereInput[]
    id?: StringFilter<"HpoTerm"> | string
    hpoId?: StringFilter<"HpoTerm"> | string
    labelEn?: StringFilter<"HpoTerm"> | string
    definitionEn?: StringNullableFilter<"HpoTerm"> | string | null
    synonymsEn?: StringNullableListFilter<"HpoTerm">
    category?: StringNullableFilter<"HpoTerm"> | string | null
    parentId?: StringNullableFilter<"HpoTerm"> | string | null
    difficulty?: IntFilter<"HpoTerm"> | number
    translationStatus?: EnumTranslationStatusFilter<"HpoTerm"> | $Enums.TranslationStatus
    hpoVersion?: StringNullableFilter<"HpoTerm"> | string | null
    isObsolete?: BoolFilter<"HpoTerm"> | boolean
    createdAt?: DateTimeFilter<"HpoTerm"> | Date | string
    updatedAt?: DateTimeFilter<"HpoTerm"> | Date | string
    translations?: TranslationListRelationFilter
    parent?: XOR<HpoTermNullableRelationFilter, HpoTermWhereInput> | null
    children?: HpoTermListRelationFilter
    conflictReviews?: ConflictReviewListRelationFilter
  }

  export type HpoTermOrderByWithRelationInput = {
    id?: SortOrder
    hpoId?: SortOrder
    labelEn?: SortOrder
    definitionEn?: SortOrderInput | SortOrder
    synonymsEn?: SortOrder
    category?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    translationStatus?: SortOrder
    hpoVersion?: SortOrderInput | SortOrder
    isObsolete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: TranslationOrderByRelationAggregateInput
    parent?: HpoTermOrderByWithRelationInput
    children?: HpoTermOrderByRelationAggregateInput
    conflictReviews?: ConflictReviewOrderByRelationAggregateInput
  }

  export type HpoTermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hpoId?: string
    AND?: HpoTermWhereInput | HpoTermWhereInput[]
    OR?: HpoTermWhereInput[]
    NOT?: HpoTermWhereInput | HpoTermWhereInput[]
    labelEn?: StringFilter<"HpoTerm"> | string
    definitionEn?: StringNullableFilter<"HpoTerm"> | string | null
    synonymsEn?: StringNullableListFilter<"HpoTerm">
    category?: StringNullableFilter<"HpoTerm"> | string | null
    parentId?: StringNullableFilter<"HpoTerm"> | string | null
    difficulty?: IntFilter<"HpoTerm"> | number
    translationStatus?: EnumTranslationStatusFilter<"HpoTerm"> | $Enums.TranslationStatus
    hpoVersion?: StringNullableFilter<"HpoTerm"> | string | null
    isObsolete?: BoolFilter<"HpoTerm"> | boolean
    createdAt?: DateTimeFilter<"HpoTerm"> | Date | string
    updatedAt?: DateTimeFilter<"HpoTerm"> | Date | string
    translations?: TranslationListRelationFilter
    parent?: XOR<HpoTermNullableRelationFilter, HpoTermWhereInput> | null
    children?: HpoTermListRelationFilter
    conflictReviews?: ConflictReviewListRelationFilter
  }, "id" | "hpoId">

  export type HpoTermOrderByWithAggregationInput = {
    id?: SortOrder
    hpoId?: SortOrder
    labelEn?: SortOrder
    definitionEn?: SortOrderInput | SortOrder
    synonymsEn?: SortOrder
    category?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    translationStatus?: SortOrder
    hpoVersion?: SortOrderInput | SortOrder
    isObsolete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HpoTermCountOrderByAggregateInput
    _avg?: HpoTermAvgOrderByAggregateInput
    _max?: HpoTermMaxOrderByAggregateInput
    _min?: HpoTermMinOrderByAggregateInput
    _sum?: HpoTermSumOrderByAggregateInput
  }

  export type HpoTermScalarWhereWithAggregatesInput = {
    AND?: HpoTermScalarWhereWithAggregatesInput | HpoTermScalarWhereWithAggregatesInput[]
    OR?: HpoTermScalarWhereWithAggregatesInput[]
    NOT?: HpoTermScalarWhereWithAggregatesInput | HpoTermScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HpoTerm"> | string
    hpoId?: StringWithAggregatesFilter<"HpoTerm"> | string
    labelEn?: StringWithAggregatesFilter<"HpoTerm"> | string
    definitionEn?: StringNullableWithAggregatesFilter<"HpoTerm"> | string | null
    synonymsEn?: StringNullableListFilter<"HpoTerm">
    category?: StringNullableWithAggregatesFilter<"HpoTerm"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"HpoTerm"> | string | null
    difficulty?: IntWithAggregatesFilter<"HpoTerm"> | number
    translationStatus?: EnumTranslationStatusWithAggregatesFilter<"HpoTerm"> | $Enums.TranslationStatus
    hpoVersion?: StringNullableWithAggregatesFilter<"HpoTerm"> | string | null
    isObsolete?: BoolWithAggregatesFilter<"HpoTerm"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HpoTerm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HpoTerm"> | Date | string
  }

  export type TranslationWhereInput = {
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    id?: StringFilter<"Translation"> | string
    termId?: StringFilter<"Translation"> | string
    userId?: StringFilter<"Translation"> | string
    labelPt?: StringFilter<"Translation"> | string
    definitionPt?: StringNullableFilter<"Translation"> | string | null
    synonymsPt?: StringNullableListFilter<"Translation">
    notes?: StringNullableFilter<"Translation"> | string | null
    status?: EnumTranslationStatusFilter<"Translation"> | $Enums.TranslationStatus
    confidence?: IntFilter<"Translation"> | number
    source?: EnumTranslationSourceFilter<"Translation"> | $Enums.TranslationSource
    isLegacy?: BoolFilter<"Translation"> | boolean
    aiSuggestion?: StringNullableFilter<"Translation"> | string | null
    aiConfidence?: FloatNullableFilter<"Translation"> | number | null
    approvalCount?: IntFilter<"Translation"> | number
    rejectionCount?: IntFilter<"Translation"> | number
    averageRating?: FloatNullableFilter<"Translation"> | number | null
    syncedToHpo?: BoolFilter<"Translation"> | boolean
    syncedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    approvedBy?: StringNullableFilter<"Translation"> | string | null
    rejectedBy?: StringNullableFilter<"Translation"> | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    term?: XOR<HpoTermRelationFilter, HpoTermWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    validations?: ValidationListRelationFilter
    comments?: CommentListRelationFilter
    strikes?: StrikeListRelationFilter
    rejection?: XOR<RejectionNullableRelationFilter, RejectionWhereInput> | null
    conflictReviews?: ConflictReviewListRelationFilter
    committeeVotes?: CommitteeVoteListRelationFilter
  }

  export type TranslationOrderByWithRelationInput = {
    id?: SortOrder
    termId?: SortOrder
    userId?: SortOrder
    labelPt?: SortOrder
    definitionPt?: SortOrderInput | SortOrder
    synonymsPt?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    isLegacy?: SortOrder
    aiSuggestion?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    syncedToHpo?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    term?: HpoTermOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    validations?: ValidationOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    strikes?: StrikeOrderByRelationAggregateInput
    rejection?: RejectionOrderByWithRelationInput
    conflictReviews?: ConflictReviewOrderByRelationAggregateInput
    committeeVotes?: CommitteeVoteOrderByRelationAggregateInput
  }

  export type TranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    termId?: StringFilter<"Translation"> | string
    userId?: StringFilter<"Translation"> | string
    labelPt?: StringFilter<"Translation"> | string
    definitionPt?: StringNullableFilter<"Translation"> | string | null
    synonymsPt?: StringNullableListFilter<"Translation">
    notes?: StringNullableFilter<"Translation"> | string | null
    status?: EnumTranslationStatusFilter<"Translation"> | $Enums.TranslationStatus
    confidence?: IntFilter<"Translation"> | number
    source?: EnumTranslationSourceFilter<"Translation"> | $Enums.TranslationSource
    isLegacy?: BoolFilter<"Translation"> | boolean
    aiSuggestion?: StringNullableFilter<"Translation"> | string | null
    aiConfidence?: FloatNullableFilter<"Translation"> | number | null
    approvalCount?: IntFilter<"Translation"> | number
    rejectionCount?: IntFilter<"Translation"> | number
    averageRating?: FloatNullableFilter<"Translation"> | number | null
    syncedToHpo?: BoolFilter<"Translation"> | boolean
    syncedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    approvedBy?: StringNullableFilter<"Translation"> | string | null
    rejectedBy?: StringNullableFilter<"Translation"> | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    term?: XOR<HpoTermRelationFilter, HpoTermWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    validations?: ValidationListRelationFilter
    comments?: CommentListRelationFilter
    strikes?: StrikeListRelationFilter
    rejection?: XOR<RejectionNullableRelationFilter, RejectionWhereInput> | null
    conflictReviews?: ConflictReviewListRelationFilter
    committeeVotes?: CommitteeVoteListRelationFilter
  }, "id">

  export type TranslationOrderByWithAggregationInput = {
    id?: SortOrder
    termId?: SortOrder
    userId?: SortOrder
    labelPt?: SortOrder
    definitionPt?: SortOrderInput | SortOrder
    synonymsPt?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    isLegacy?: SortOrder
    aiSuggestion?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    syncedToHpo?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: TranslationCountOrderByAggregateInput
    _avg?: TranslationAvgOrderByAggregateInput
    _max?: TranslationMaxOrderByAggregateInput
    _min?: TranslationMinOrderByAggregateInput
    _sum?: TranslationSumOrderByAggregateInput
  }

  export type TranslationScalarWhereWithAggregatesInput = {
    AND?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    OR?: TranslationScalarWhereWithAggregatesInput[]
    NOT?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Translation"> | string
    termId?: StringWithAggregatesFilter<"Translation"> | string
    userId?: StringWithAggregatesFilter<"Translation"> | string
    labelPt?: StringWithAggregatesFilter<"Translation"> | string
    definitionPt?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    synonymsPt?: StringNullableListFilter<"Translation">
    notes?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    status?: EnumTranslationStatusWithAggregatesFilter<"Translation"> | $Enums.TranslationStatus
    confidence?: IntWithAggregatesFilter<"Translation"> | number
    source?: EnumTranslationSourceWithAggregatesFilter<"Translation"> | $Enums.TranslationSource
    isLegacy?: BoolWithAggregatesFilter<"Translation"> | boolean
    aiSuggestion?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    aiConfidence?: FloatNullableWithAggregatesFilter<"Translation"> | number | null
    approvalCount?: IntWithAggregatesFilter<"Translation"> | number
    rejectionCount?: IntWithAggregatesFilter<"Translation"> | number
    averageRating?: FloatNullableWithAggregatesFilter<"Translation"> | number | null
    syncedToHpo?: BoolWithAggregatesFilter<"Translation"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"Translation"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    rejectedBy?: StringNullableWithAggregatesFilter<"Translation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Translation"> | Date | string | null
  }

  export type ValidationWhereInput = {
    AND?: ValidationWhereInput | ValidationWhereInput[]
    OR?: ValidationWhereInput[]
    NOT?: ValidationWhereInput | ValidationWhereInput[]
    id?: StringFilter<"Validation"> | string
    translationId?: StringFilter<"Validation"> | string
    validatorId?: StringFilter<"Validation"> | string
    rating?: IntFilter<"Validation"> | number
    decision?: EnumValidationDecisionFilter<"Validation"> | $Enums.ValidationDecision
    comments?: StringNullableFilter<"Validation"> | string | null
    suggestions?: StringNullableFilter<"Validation"> | string | null
    accuracyScore?: IntNullableFilter<"Validation"> | number | null
    clarityScore?: IntNullableFilter<"Validation"> | number | null
    consistencyScore?: IntNullableFilter<"Validation"> | number | null
    timeSpentSeconds?: IntNullableFilter<"Validation"> | number | null
    createdAt?: DateTimeFilter<"Validation"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    validator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ValidationOrderByWithRelationInput = {
    id?: SortOrder
    translationId?: SortOrder
    validatorId?: SortOrder
    rating?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    accuracyScore?: SortOrderInput | SortOrder
    clarityScore?: SortOrderInput | SortOrder
    consistencyScore?: SortOrderInput | SortOrder
    timeSpentSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    translation?: TranslationOrderByWithRelationInput
    validator?: UserOrderByWithRelationInput
  }

  export type ValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    translationId_validatorId?: ValidationTranslationIdValidatorIdCompoundUniqueInput
    AND?: ValidationWhereInput | ValidationWhereInput[]
    OR?: ValidationWhereInput[]
    NOT?: ValidationWhereInput | ValidationWhereInput[]
    translationId?: StringFilter<"Validation"> | string
    validatorId?: StringFilter<"Validation"> | string
    rating?: IntFilter<"Validation"> | number
    decision?: EnumValidationDecisionFilter<"Validation"> | $Enums.ValidationDecision
    comments?: StringNullableFilter<"Validation"> | string | null
    suggestions?: StringNullableFilter<"Validation"> | string | null
    accuracyScore?: IntNullableFilter<"Validation"> | number | null
    clarityScore?: IntNullableFilter<"Validation"> | number | null
    consistencyScore?: IntNullableFilter<"Validation"> | number | null
    timeSpentSeconds?: IntNullableFilter<"Validation"> | number | null
    createdAt?: DateTimeFilter<"Validation"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    validator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "translationId_validatorId">

  export type ValidationOrderByWithAggregationInput = {
    id?: SortOrder
    translationId?: SortOrder
    validatorId?: SortOrder
    rating?: SortOrder
    decision?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    accuracyScore?: SortOrderInput | SortOrder
    clarityScore?: SortOrderInput | SortOrder
    consistencyScore?: SortOrderInput | SortOrder
    timeSpentSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ValidationCountOrderByAggregateInput
    _avg?: ValidationAvgOrderByAggregateInput
    _max?: ValidationMaxOrderByAggregateInput
    _min?: ValidationMinOrderByAggregateInput
    _sum?: ValidationSumOrderByAggregateInput
  }

  export type ValidationScalarWhereWithAggregatesInput = {
    AND?: ValidationScalarWhereWithAggregatesInput | ValidationScalarWhereWithAggregatesInput[]
    OR?: ValidationScalarWhereWithAggregatesInput[]
    NOT?: ValidationScalarWhereWithAggregatesInput | ValidationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Validation"> | string
    translationId?: StringWithAggregatesFilter<"Validation"> | string
    validatorId?: StringWithAggregatesFilter<"Validation"> | string
    rating?: IntWithAggregatesFilter<"Validation"> | number
    decision?: EnumValidationDecisionWithAggregatesFilter<"Validation"> | $Enums.ValidationDecision
    comments?: StringNullableWithAggregatesFilter<"Validation"> | string | null
    suggestions?: StringNullableWithAggregatesFilter<"Validation"> | string | null
    accuracyScore?: IntNullableWithAggregatesFilter<"Validation"> | number | null
    clarityScore?: IntNullableWithAggregatesFilter<"Validation"> | number | null
    consistencyScore?: IntNullableWithAggregatesFilter<"Validation"> | number | null
    timeSpentSeconds?: IntNullableWithAggregatesFilter<"Validation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Validation"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    translationId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    translationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translation?: TranslationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    translationId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    translationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    translationId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    code?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringNullableFilter<"Badge"> | string | null
    points?: IntFilter<"Badge"> | number
    rarity?: EnumBadgeRarityFilter<"Badge"> | $Enums.BadgeRarity
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    users?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringNullableFilter<"Badge"> | string | null
    points?: IntFilter<"Badge"> | number
    rarity?: EnumBadgeRarityFilter<"Badge"> | $Enums.BadgeRarity
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }, "id" | "code">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    code?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    iconUrl?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    points?: IntWithAggregatesFilter<"Badge"> | number
    rarity?: EnumBadgeRarityWithAggregatesFilter<"Badge"> | $Enums.BadgeRarity
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }, "id" | "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type UserActivityWhereInput = {
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    id?: StringFilter<"UserActivity"> | string
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    points?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    createdAt?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserActivityWhereInput | UserActivityWhereInput[]
    OR?: UserActivityWhereInput[]
    NOT?: UserActivityWhereInput | UserActivityWhereInput[]
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    points?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    createdAt?: DateTimeFilter<"UserActivity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserActivityCountOrderByAggregateInput
    _avg?: UserActivityAvgOrderByAggregateInput
    _max?: UserActivityMaxOrderByAggregateInput
    _min?: UserActivityMinOrderByAggregateInput
    _sum?: UserActivitySumOrderByAggregateInput
  }

  export type UserActivityScalarWhereWithAggregatesInput = {
    AND?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    OR?: UserActivityScalarWhereWithAggregatesInput[]
    NOT?: UserActivityScalarWhereWithAggregatesInput | UserActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserActivity"> | string
    userId?: StringWithAggregatesFilter<"UserActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"UserActivity"> | $Enums.ActivityType
    points?: IntWithAggregatesFilter<"UserActivity"> | number
    metadata?: JsonNullableWithAggregatesFilter<"UserActivity">
    createdAt?: DateTimeWithAggregatesFilter<"UserActivity"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type ConflictReviewWhereInput = {
    AND?: ConflictReviewWhereInput | ConflictReviewWhereInput[]
    OR?: ConflictReviewWhereInput[]
    NOT?: ConflictReviewWhereInput | ConflictReviewWhereInput[]
    id?: StringFilter<"ConflictReview"> | string
    hpoTermId?: StringFilter<"ConflictReview"> | string
    type?: EnumConflictTypeFilter<"ConflictReview"> | $Enums.ConflictType
    status?: EnumConflictStatusFilter<"ConflictReview"> | $Enums.ConflictStatus
    priority?: EnumPriorityFilter<"ConflictReview"> | $Enums.Priority
    winningTranslationId?: StringNullableFilter<"ConflictReview"> | string | null
    resolution?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedBy?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ConflictReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ConflictReview"> | Date | string
    updatedAt?: DateTimeFilter<"ConflictReview"> | Date | string
    hpoTerm?: XOR<HpoTermRelationFilter, HpoTermWhereInput>
    translations?: TranslationListRelationFilter
    committeeVotes?: CommitteeVoteListRelationFilter
    resolver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ConflictReviewOrderByWithRelationInput = {
    id?: SortOrder
    hpoTermId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    winningTranslationId?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hpoTerm?: HpoTermOrderByWithRelationInput
    translations?: TranslationOrderByRelationAggregateInput
    committeeVotes?: CommitteeVoteOrderByRelationAggregateInput
    resolver?: UserOrderByWithRelationInput
  }

  export type ConflictReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConflictReviewWhereInput | ConflictReviewWhereInput[]
    OR?: ConflictReviewWhereInput[]
    NOT?: ConflictReviewWhereInput | ConflictReviewWhereInput[]
    hpoTermId?: StringFilter<"ConflictReview"> | string
    type?: EnumConflictTypeFilter<"ConflictReview"> | $Enums.ConflictType
    status?: EnumConflictStatusFilter<"ConflictReview"> | $Enums.ConflictStatus
    priority?: EnumPriorityFilter<"ConflictReview"> | $Enums.Priority
    winningTranslationId?: StringNullableFilter<"ConflictReview"> | string | null
    resolution?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedBy?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ConflictReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ConflictReview"> | Date | string
    updatedAt?: DateTimeFilter<"ConflictReview"> | Date | string
    hpoTerm?: XOR<HpoTermRelationFilter, HpoTermWhereInput>
    translations?: TranslationListRelationFilter
    committeeVotes?: CommitteeVoteListRelationFilter
    resolver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ConflictReviewOrderByWithAggregationInput = {
    id?: SortOrder
    hpoTermId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    winningTranslationId?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConflictReviewCountOrderByAggregateInput
    _max?: ConflictReviewMaxOrderByAggregateInput
    _min?: ConflictReviewMinOrderByAggregateInput
  }

  export type ConflictReviewScalarWhereWithAggregatesInput = {
    AND?: ConflictReviewScalarWhereWithAggregatesInput | ConflictReviewScalarWhereWithAggregatesInput[]
    OR?: ConflictReviewScalarWhereWithAggregatesInput[]
    NOT?: ConflictReviewScalarWhereWithAggregatesInput | ConflictReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConflictReview"> | string
    hpoTermId?: StringWithAggregatesFilter<"ConflictReview"> | string
    type?: EnumConflictTypeWithAggregatesFilter<"ConflictReview"> | $Enums.ConflictType
    status?: EnumConflictStatusWithAggregatesFilter<"ConflictReview"> | $Enums.ConflictStatus
    priority?: EnumPriorityWithAggregatesFilter<"ConflictReview"> | $Enums.Priority
    winningTranslationId?: StringNullableWithAggregatesFilter<"ConflictReview"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"ConflictReview"> | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"ConflictReview"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ConflictReview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConflictReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConflictReview"> | Date | string
  }

  export type CommitteeVoteWhereInput = {
    AND?: CommitteeVoteWhereInput | CommitteeVoteWhereInput[]
    OR?: CommitteeVoteWhereInput[]
    NOT?: CommitteeVoteWhereInput | CommitteeVoteWhereInput[]
    id?: StringFilter<"CommitteeVote"> | string
    conflictReviewId?: StringFilter<"CommitteeVote"> | string
    voterId?: StringFilter<"CommitteeVote"> | string
    translationId?: StringNullableFilter<"CommitteeVote"> | string | null
    voteType?: EnumVoteTypeFilter<"CommitteeVote"> | $Enums.VoteType
    comment?: StringNullableFilter<"CommitteeVote"> | string | null
    votedAt?: DateTimeFilter<"CommitteeVote"> | Date | string
    conflictReview?: XOR<ConflictReviewRelationFilter, ConflictReviewWhereInput>
    voter?: XOR<UserRelationFilter, UserWhereInput>
    translation?: XOR<TranslationNullableRelationFilter, TranslationWhereInput> | null
  }

  export type CommitteeVoteOrderByWithRelationInput = {
    id?: SortOrder
    conflictReviewId?: SortOrder
    voterId?: SortOrder
    translationId?: SortOrderInput | SortOrder
    voteType?: SortOrder
    comment?: SortOrderInput | SortOrder
    votedAt?: SortOrder
    conflictReview?: ConflictReviewOrderByWithRelationInput
    voter?: UserOrderByWithRelationInput
    translation?: TranslationOrderByWithRelationInput
  }

  export type CommitteeVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conflictReviewId_voterId?: CommitteeVoteConflictReviewIdVoterIdCompoundUniqueInput
    AND?: CommitteeVoteWhereInput | CommitteeVoteWhereInput[]
    OR?: CommitteeVoteWhereInput[]
    NOT?: CommitteeVoteWhereInput | CommitteeVoteWhereInput[]
    conflictReviewId?: StringFilter<"CommitteeVote"> | string
    voterId?: StringFilter<"CommitteeVote"> | string
    translationId?: StringNullableFilter<"CommitteeVote"> | string | null
    voteType?: EnumVoteTypeFilter<"CommitteeVote"> | $Enums.VoteType
    comment?: StringNullableFilter<"CommitteeVote"> | string | null
    votedAt?: DateTimeFilter<"CommitteeVote"> | Date | string
    conflictReview?: XOR<ConflictReviewRelationFilter, ConflictReviewWhereInput>
    voter?: XOR<UserRelationFilter, UserWhereInput>
    translation?: XOR<TranslationNullableRelationFilter, TranslationWhereInput> | null
  }, "id" | "conflictReviewId_voterId">

  export type CommitteeVoteOrderByWithAggregationInput = {
    id?: SortOrder
    conflictReviewId?: SortOrder
    voterId?: SortOrder
    translationId?: SortOrderInput | SortOrder
    voteType?: SortOrder
    comment?: SortOrderInput | SortOrder
    votedAt?: SortOrder
    _count?: CommitteeVoteCountOrderByAggregateInput
    _max?: CommitteeVoteMaxOrderByAggregateInput
    _min?: CommitteeVoteMinOrderByAggregateInput
  }

  export type CommitteeVoteScalarWhereWithAggregatesInput = {
    AND?: CommitteeVoteScalarWhereWithAggregatesInput | CommitteeVoteScalarWhereWithAggregatesInput[]
    OR?: CommitteeVoteScalarWhereWithAggregatesInput[]
    NOT?: CommitteeVoteScalarWhereWithAggregatesInput | CommitteeVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommitteeVote"> | string
    conflictReviewId?: StringWithAggregatesFilter<"CommitteeVote"> | string
    voterId?: StringWithAggregatesFilter<"CommitteeVote"> | string
    translationId?: StringNullableWithAggregatesFilter<"CommitteeVote"> | string | null
    voteType?: EnumVoteTypeWithAggregatesFilter<"CommitteeVote"> | $Enums.VoteType
    comment?: StringNullableWithAggregatesFilter<"CommitteeVote"> | string | null
    votedAt?: DateTimeWithAggregatesFilter<"CommitteeVote"> | Date | string
  }

  export type RejectionWhereInput = {
    AND?: RejectionWhereInput | RejectionWhereInput[]
    OR?: RejectionWhereInput[]
    NOT?: RejectionWhereInput | RejectionWhereInput[]
    id?: StringFilter<"Rejection"> | string
    translationId?: StringFilter<"Rejection"> | string
    rejectedBy?: StringFilter<"Rejection"> | string
    reasonCode?: EnumRejectionReasonFilter<"Rejection"> | $Enums.RejectionReason
    detailedReason?: StringFilter<"Rejection"> | string
    suggestions?: StringNullableFilter<"Rejection"> | string | null
    canResubmit?: BoolFilter<"Rejection"> | boolean
    createdAt?: DateTimeFilter<"Rejection"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RejectionOrderByWithRelationInput = {
    id?: SortOrder
    translationId?: SortOrder
    rejectedBy?: SortOrder
    reasonCode?: SortOrder
    detailedReason?: SortOrder
    suggestions?: SortOrderInput | SortOrder
    canResubmit?: SortOrder
    createdAt?: SortOrder
    translation?: TranslationOrderByWithRelationInput
    admin?: UserOrderByWithRelationInput
  }

  export type RejectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    translationId?: string
    AND?: RejectionWhereInput | RejectionWhereInput[]
    OR?: RejectionWhereInput[]
    NOT?: RejectionWhereInput | RejectionWhereInput[]
    rejectedBy?: StringFilter<"Rejection"> | string
    reasonCode?: EnumRejectionReasonFilter<"Rejection"> | $Enums.RejectionReason
    detailedReason?: StringFilter<"Rejection"> | string
    suggestions?: StringNullableFilter<"Rejection"> | string | null
    canResubmit?: BoolFilter<"Rejection"> | boolean
    createdAt?: DateTimeFilter<"Rejection"> | Date | string
    translation?: XOR<TranslationRelationFilter, TranslationWhereInput>
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "translationId">

  export type RejectionOrderByWithAggregationInput = {
    id?: SortOrder
    translationId?: SortOrder
    rejectedBy?: SortOrder
    reasonCode?: SortOrder
    detailedReason?: SortOrder
    suggestions?: SortOrderInput | SortOrder
    canResubmit?: SortOrder
    createdAt?: SortOrder
    _count?: RejectionCountOrderByAggregateInput
    _max?: RejectionMaxOrderByAggregateInput
    _min?: RejectionMinOrderByAggregateInput
  }

  export type RejectionScalarWhereWithAggregatesInput = {
    AND?: RejectionScalarWhereWithAggregatesInput | RejectionScalarWhereWithAggregatesInput[]
    OR?: RejectionScalarWhereWithAggregatesInput[]
    NOT?: RejectionScalarWhereWithAggregatesInput | RejectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rejection"> | string
    translationId?: StringWithAggregatesFilter<"Rejection"> | string
    rejectedBy?: StringWithAggregatesFilter<"Rejection"> | string
    reasonCode?: EnumRejectionReasonWithAggregatesFilter<"Rejection"> | $Enums.RejectionReason
    detailedReason?: StringWithAggregatesFilter<"Rejection"> | string
    suggestions?: StringNullableWithAggregatesFilter<"Rejection"> | string | null
    canResubmit?: BoolWithAggregatesFilter<"Rejection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Rejection"> | Date | string
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    changes?: JsonNullableFilter<"AdminAuditLog">
    reason?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: StringNullableFilter<"AdminAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    changes?: JsonNullableFilter<"AdminAuditLog">
    reason?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: StringNullableFilter<"AdminAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: EnumAdminActionWithAggregatesFilter<"AdminAuditLog"> | $Enums.AdminAction
    targetType?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    reason?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    syncDate?: DateTimeFilter<"SyncLog"> | Date | string
    initiatedBy?: StringFilter<"SyncLog"> | string
    translationsCount?: IntFilter<"SyncLog"> | number
    babelonFilePath?: StringNullableFilter<"SyncLog"> | string | null
    githubPrUrl?: StringNullableFilter<"SyncLog"> | string | null
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    syncDate?: SortOrder
    initiatedBy?: SortOrder
    translationsCount?: SortOrder
    babelonFilePath?: SortOrderInput | SortOrder
    githubPrUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    syncDate?: DateTimeFilter<"SyncLog"> | Date | string
    initiatedBy?: StringFilter<"SyncLog"> | string
    translationsCount?: IntFilter<"SyncLog"> | number
    babelonFilePath?: StringNullableFilter<"SyncLog"> | string | null
    githubPrUrl?: StringNullableFilter<"SyncLog"> | string | null
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    syncDate?: SortOrder
    initiatedBy?: SortOrder
    translationsCount?: SortOrder
    babelonFilePath?: SortOrderInput | SortOrder
    githubPrUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    syncDate?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
    initiatedBy?: StringWithAggregatesFilter<"SyncLog"> | string
    translationsCount?: IntWithAggregatesFilter<"SyncLog"> | number
    babelonFilePath?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    githubPrUrl?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    status?: EnumSyncStatusWithAggregatesFilter<"SyncLog"> | $Enums.SyncStatus
    errorMessage?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncLog"> | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type StrikeWhereInput = {
    AND?: StrikeWhereInput | StrikeWhereInput[]
    OR?: StrikeWhereInput[]
    NOT?: StrikeWhereInput | StrikeWhereInput[]
    id?: StringFilter<"Strike"> | string
    userId?: StringFilter<"Strike"> | string
    adminId?: StringFilter<"Strike"> | string
    reason?: EnumStrikeReasonFilter<"Strike"> | $Enums.StrikeReason
    detailedReason?: StringFilter<"Strike"> | string
    translationId?: StringNullableFilter<"Strike"> | string | null
    severity?: IntFilter<"Strike"> | number
    isActive?: BoolFilter<"Strike"> | boolean
    expiresAt?: DateTimeNullableFilter<"Strike"> | Date | string | null
    createdAt?: DateTimeFilter<"Strike"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    admin?: XOR<UserRelationFilter, UserWhereInput>
    translation?: XOR<TranslationNullableRelationFilter, TranslationWhereInput> | null
  }

  export type StrikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    reason?: SortOrder
    detailedReason?: SortOrder
    translationId?: SortOrderInput | SortOrder
    severity?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    admin?: UserOrderByWithRelationInput
    translation?: TranslationOrderByWithRelationInput
  }

  export type StrikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrikeWhereInput | StrikeWhereInput[]
    OR?: StrikeWhereInput[]
    NOT?: StrikeWhereInput | StrikeWhereInput[]
    userId?: StringFilter<"Strike"> | string
    adminId?: StringFilter<"Strike"> | string
    reason?: EnumStrikeReasonFilter<"Strike"> | $Enums.StrikeReason
    detailedReason?: StringFilter<"Strike"> | string
    translationId?: StringNullableFilter<"Strike"> | string | null
    severity?: IntFilter<"Strike"> | number
    isActive?: BoolFilter<"Strike"> | boolean
    expiresAt?: DateTimeNullableFilter<"Strike"> | Date | string | null
    createdAt?: DateTimeFilter<"Strike"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    admin?: XOR<UserRelationFilter, UserWhereInput>
    translation?: XOR<TranslationNullableRelationFilter, TranslationWhereInput> | null
  }, "id">

  export type StrikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    reason?: SortOrder
    detailedReason?: SortOrder
    translationId?: SortOrderInput | SortOrder
    severity?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StrikeCountOrderByAggregateInput
    _avg?: StrikeAvgOrderByAggregateInput
    _max?: StrikeMaxOrderByAggregateInput
    _min?: StrikeMinOrderByAggregateInput
    _sum?: StrikeSumOrderByAggregateInput
  }

  export type StrikeScalarWhereWithAggregatesInput = {
    AND?: StrikeScalarWhereWithAggregatesInput | StrikeScalarWhereWithAggregatesInput[]
    OR?: StrikeScalarWhereWithAggregatesInput[]
    NOT?: StrikeScalarWhereWithAggregatesInput | StrikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Strike"> | string
    userId?: StringWithAggregatesFilter<"Strike"> | string
    adminId?: StringWithAggregatesFilter<"Strike"> | string
    reason?: EnumStrikeReasonWithAggregatesFilter<"Strike"> | $Enums.StrikeReason
    detailedReason?: StringWithAggregatesFilter<"Strike"> | string
    translationId?: StringNullableWithAggregatesFilter<"Strike"> | string | null
    severity?: IntWithAggregatesFilter<"Strike"> | number
    isActive?: BoolWithAggregatesFilter<"Strike"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Strike"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Strike"> | Date | string
  }

  export type SessionLogWhereInput = {
    AND?: SessionLogWhereInput | SessionLogWhereInput[]
    OR?: SessionLogWhereInput[]
    NOT?: SessionLogWhereInput | SessionLogWhereInput[]
    id?: StringFilter<"SessionLog"> | string
    userId?: StringNullableFilter<"SessionLog"> | string | null
    ipAddress?: StringFilter<"SessionLog"> | string
    country?: StringNullableFilter<"SessionLog"> | string | null
    city?: StringNullableFilter<"SessionLog"> | string | null
    region?: StringNullableFilter<"SessionLog"> | string | null
    latitude?: FloatNullableFilter<"SessionLog"> | number | null
    longitude?: FloatNullableFilter<"SessionLog"> | number | null
    userAgent?: StringFilter<"SessionLog"> | string
    browser?: StringNullableFilter<"SessionLog"> | string | null
    browserVersion?: StringNullableFilter<"SessionLog"> | string | null
    os?: StringNullableFilter<"SessionLog"> | string | null
    osVersion?: StringNullableFilter<"SessionLog"> | string | null
    device?: StringNullableFilter<"SessionLog"> | string | null
    isMobile?: BoolFilter<"SessionLog"> | boolean
    sessionStart?: DateTimeFilter<"SessionLog"> | Date | string
    sessionEnd?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    duration?: IntNullableFilter<"SessionLog"> | number | null
    pagesVisited?: StringNullableListFilter<"SessionLog">
    actionsCount?: IntFilter<"SessionLog"> | number
    avgResponseTime?: FloatNullableFilter<"SessionLog"> | number | null
    createdAt?: DateTimeFilter<"SessionLog"> | Date | string
    updatedAt?: DateTimeFilter<"SessionLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SessionLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    userAgent?: SortOrder
    browser?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    isMobile?: SortOrder
    sessionStart?: SortOrder
    sessionEnd?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pagesVisited?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionLogWhereInput | SessionLogWhereInput[]
    OR?: SessionLogWhereInput[]
    NOT?: SessionLogWhereInput | SessionLogWhereInput[]
    userId?: StringNullableFilter<"SessionLog"> | string | null
    ipAddress?: StringFilter<"SessionLog"> | string
    country?: StringNullableFilter<"SessionLog"> | string | null
    city?: StringNullableFilter<"SessionLog"> | string | null
    region?: StringNullableFilter<"SessionLog"> | string | null
    latitude?: FloatNullableFilter<"SessionLog"> | number | null
    longitude?: FloatNullableFilter<"SessionLog"> | number | null
    userAgent?: StringFilter<"SessionLog"> | string
    browser?: StringNullableFilter<"SessionLog"> | string | null
    browserVersion?: StringNullableFilter<"SessionLog"> | string | null
    os?: StringNullableFilter<"SessionLog"> | string | null
    osVersion?: StringNullableFilter<"SessionLog"> | string | null
    device?: StringNullableFilter<"SessionLog"> | string | null
    isMobile?: BoolFilter<"SessionLog"> | boolean
    sessionStart?: DateTimeFilter<"SessionLog"> | Date | string
    sessionEnd?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    duration?: IntNullableFilter<"SessionLog"> | number | null
    pagesVisited?: StringNullableListFilter<"SessionLog">
    actionsCount?: IntFilter<"SessionLog"> | number
    avgResponseTime?: FloatNullableFilter<"SessionLog"> | number | null
    createdAt?: DateTimeFilter<"SessionLog"> | Date | string
    updatedAt?: DateTimeFilter<"SessionLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SessionLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    userAgent?: SortOrder
    browser?: SortOrderInput | SortOrder
    browserVersion?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    isMobile?: SortOrder
    sessionStart?: SortOrder
    sessionEnd?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    pagesVisited?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionLogCountOrderByAggregateInput
    _avg?: SessionLogAvgOrderByAggregateInput
    _max?: SessionLogMaxOrderByAggregateInput
    _min?: SessionLogMinOrderByAggregateInput
    _sum?: SessionLogSumOrderByAggregateInput
  }

  export type SessionLogScalarWhereWithAggregatesInput = {
    AND?: SessionLogScalarWhereWithAggregatesInput | SessionLogScalarWhereWithAggregatesInput[]
    OR?: SessionLogScalarWhereWithAggregatesInput[]
    NOT?: SessionLogScalarWhereWithAggregatesInput | SessionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionLog"> | string
    userId?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    ipAddress?: StringWithAggregatesFilter<"SessionLog"> | string
    country?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    city?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    region?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"SessionLog"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"SessionLog"> | number | null
    userAgent?: StringWithAggregatesFilter<"SessionLog"> | string
    browser?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    browserVersion?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    os?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    device?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    isMobile?: BoolWithAggregatesFilter<"SessionLog"> | boolean
    sessionStart?: DateTimeWithAggregatesFilter<"SessionLog"> | Date | string
    sessionEnd?: DateTimeNullableWithAggregatesFilter<"SessionLog"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"SessionLog"> | number | null
    pagesVisited?: StringNullableListFilter<"SessionLog">
    actionsCount?: IntWithAggregatesFilter<"SessionLog"> | number
    avgResponseTime?: FloatNullableWithAggregatesFilter<"SessionLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionLog"> | Date | string
  }

  export type UserAnalyticsWhereInput = {
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    id?: StringFilter<"UserAnalytics"> | string
    userId?: StringFilter<"UserAnalytics"> | string
    translationsToday?: IntFilter<"UserAnalytics"> | number
    validationsToday?: IntFilter<"UserAnalytics"> | number
    loginStreak?: IntFilter<"UserAnalytics"> | number
    lastActivityDate?: DateTimeNullableFilter<"UserAnalytics"> | Date | string | null
    totalSessions?: IntFilter<"UserAnalytics"> | number
    avgSessionDuration?: FloatNullableFilter<"UserAnalytics"> | number | null
    preferredHours?: IntNullableListFilter<"UserAnalytics">
    preferredDays?: IntNullableListFilter<"UserAnalytics">
    mostUsedFeatures?: StringNullableListFilter<"UserAnalytics">
    avgTranslationTime?: FloatNullableFilter<"UserAnalytics"> | number | null
    avgValidationTime?: FloatNullableFilter<"UserAnalytics"> | number | null
    approvalRate?: FloatNullableFilter<"UserAnalytics"> | number | null
    avgConfidenceScore?: FloatNullableFilter<"UserAnalytics"> | number | null
    createdAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    lastActivityDate?: SortOrderInput | SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrderInput | SortOrder
    preferredHours?: SortOrder
    preferredDays?: SortOrder
    mostUsedFeatures?: SortOrder
    avgTranslationTime?: SortOrderInput | SortOrder
    avgValidationTime?: SortOrderInput | SortOrder
    approvalRate?: SortOrderInput | SortOrder
    avgConfidenceScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    OR?: UserAnalyticsWhereInput[]
    NOT?: UserAnalyticsWhereInput | UserAnalyticsWhereInput[]
    translationsToday?: IntFilter<"UserAnalytics"> | number
    validationsToday?: IntFilter<"UserAnalytics"> | number
    loginStreak?: IntFilter<"UserAnalytics"> | number
    lastActivityDate?: DateTimeNullableFilter<"UserAnalytics"> | Date | string | null
    totalSessions?: IntFilter<"UserAnalytics"> | number
    avgSessionDuration?: FloatNullableFilter<"UserAnalytics"> | number | null
    preferredHours?: IntNullableListFilter<"UserAnalytics">
    preferredDays?: IntNullableListFilter<"UserAnalytics">
    mostUsedFeatures?: StringNullableListFilter<"UserAnalytics">
    avgTranslationTime?: FloatNullableFilter<"UserAnalytics"> | number | null
    avgValidationTime?: FloatNullableFilter<"UserAnalytics"> | number | null
    approvalRate?: FloatNullableFilter<"UserAnalytics"> | number | null
    avgConfidenceScore?: FloatNullableFilter<"UserAnalytics"> | number | null
    createdAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"UserAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    lastActivityDate?: SortOrderInput | SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrderInput | SortOrder
    preferredHours?: SortOrder
    preferredDays?: SortOrder
    mostUsedFeatures?: SortOrder
    avgTranslationTime?: SortOrderInput | SortOrder
    avgValidationTime?: SortOrderInput | SortOrder
    approvalRate?: SortOrderInput | SortOrder
    avgConfidenceScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAnalyticsCountOrderByAggregateInput
    _avg?: UserAnalyticsAvgOrderByAggregateInput
    _max?: UserAnalyticsMaxOrderByAggregateInput
    _min?: UserAnalyticsMinOrderByAggregateInput
    _sum?: UserAnalyticsSumOrderByAggregateInput
  }

  export type UserAnalyticsScalarWhereWithAggregatesInput = {
    AND?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    OR?: UserAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: UserAnalyticsScalarWhereWithAggregatesInput | UserAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAnalytics"> | string
    userId?: StringWithAggregatesFilter<"UserAnalytics"> | string
    translationsToday?: IntWithAggregatesFilter<"UserAnalytics"> | number
    validationsToday?: IntWithAggregatesFilter<"UserAnalytics"> | number
    loginStreak?: IntWithAggregatesFilter<"UserAnalytics"> | number
    lastActivityDate?: DateTimeNullableWithAggregatesFilter<"UserAnalytics"> | Date | string | null
    totalSessions?: IntWithAggregatesFilter<"UserAnalytics"> | number
    avgSessionDuration?: FloatNullableWithAggregatesFilter<"UserAnalytics"> | number | null
    preferredHours?: IntNullableListFilter<"UserAnalytics">
    preferredDays?: IntNullableListFilter<"UserAnalytics">
    mostUsedFeatures?: StringNullableListFilter<"UserAnalytics">
    avgTranslationTime?: FloatNullableWithAggregatesFilter<"UserAnalytics"> | number | null
    avgValidationTime?: FloatNullableWithAggregatesFilter<"UserAnalytics"> | number | null
    approvalRate?: FloatNullableWithAggregatesFilter<"UserAnalytics"> | number | null
    avgConfidenceScore?: FloatNullableWithAggregatesFilter<"UserAnalytics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAnalytics"> | Date | string
  }

  export type ApiMetricsWhereInput = {
    AND?: ApiMetricsWhereInput | ApiMetricsWhereInput[]
    OR?: ApiMetricsWhereInput[]
    NOT?: ApiMetricsWhereInput | ApiMetricsWhereInput[]
    id?: StringFilter<"ApiMetrics"> | string
    endpoint?: StringFilter<"ApiMetrics"> | string
    method?: StringFilter<"ApiMetrics"> | string
    statusCode?: IntFilter<"ApiMetrics"> | number
    responseTime?: FloatFilter<"ApiMetrics"> | number
    userId?: StringNullableFilter<"ApiMetrics"> | string | null
    ipAddress?: StringFilter<"ApiMetrics"> | string
    userAgent?: StringFilter<"ApiMetrics"> | string
    errorMessage?: StringNullableFilter<"ApiMetrics"> | string | null
    errorStack?: StringNullableFilter<"ApiMetrics"> | string | null
    timestamp?: DateTimeFilter<"ApiMetrics"> | Date | string
  }

  export type ApiMetricsOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type ApiMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiMetricsWhereInput | ApiMetricsWhereInput[]
    OR?: ApiMetricsWhereInput[]
    NOT?: ApiMetricsWhereInput | ApiMetricsWhereInput[]
    endpoint?: StringFilter<"ApiMetrics"> | string
    method?: StringFilter<"ApiMetrics"> | string
    statusCode?: IntFilter<"ApiMetrics"> | number
    responseTime?: FloatFilter<"ApiMetrics"> | number
    userId?: StringNullableFilter<"ApiMetrics"> | string | null
    ipAddress?: StringFilter<"ApiMetrics"> | string
    userAgent?: StringFilter<"ApiMetrics"> | string
    errorMessage?: StringNullableFilter<"ApiMetrics"> | string | null
    errorStack?: StringNullableFilter<"ApiMetrics"> | string | null
    timestamp?: DateTimeFilter<"ApiMetrics"> | Date | string
  }, "id">

  export type ApiMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: ApiMetricsCountOrderByAggregateInput
    _avg?: ApiMetricsAvgOrderByAggregateInput
    _max?: ApiMetricsMaxOrderByAggregateInput
    _min?: ApiMetricsMinOrderByAggregateInput
    _sum?: ApiMetricsSumOrderByAggregateInput
  }

  export type ApiMetricsScalarWhereWithAggregatesInput = {
    AND?: ApiMetricsScalarWhereWithAggregatesInput | ApiMetricsScalarWhereWithAggregatesInput[]
    OR?: ApiMetricsScalarWhereWithAggregatesInput[]
    NOT?: ApiMetricsScalarWhereWithAggregatesInput | ApiMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiMetrics"> | string
    endpoint?: StringWithAggregatesFilter<"ApiMetrics"> | string
    method?: StringWithAggregatesFilter<"ApiMetrics"> | string
    statusCode?: IntWithAggregatesFilter<"ApiMetrics"> | number
    responseTime?: FloatWithAggregatesFilter<"ApiMetrics"> | number
    userId?: StringNullableWithAggregatesFilter<"ApiMetrics"> | string | null
    ipAddress?: StringWithAggregatesFilter<"ApiMetrics"> | string
    userAgent?: StringWithAggregatesFilter<"ApiMetrics"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ApiMetrics"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"ApiMetrics"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ApiMetrics"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HpoTermCreateInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutTermInput
    parent?: HpoTermCreateNestedOneWithoutChildrenInput
    children?: HpoTermCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermUncheckedCreateInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    parentId?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutTermInput
    children?: HpoTermUncheckedCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutTermNestedInput
    parent?: HpoTermUpdateOneWithoutChildrenNestedInput
    children?: HpoTermUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutTermNestedInput
    children?: HpoTermUncheckedUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermCreateManyInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    parentId?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HpoTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HpoTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationCreateManyInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type TranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ValidationCreateInput = {
    id?: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
    translation: TranslationCreateNestedOneWithoutValidationsInput
    validator: UserCreateNestedOneWithoutValidationsInput
  }

  export type ValidationUncheckedCreateInput = {
    id?: string
    translationId: string
    validatorId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type ValidationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutValidationsNestedInput
    validator?: UserUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ValidationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    validatorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationCreateManyInput = {
    id?: string
    translationId: string
    validatorId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type ValidationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    validatorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translation: TranslationCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    translationId: string
    userId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    translationId: string
    userId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    code: string
    name: string
    description: string
    iconUrl?: string | null
    points?: number
    rarity?: $Enums.BadgeRarity
    createdAt?: Date | string
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description: string
    iconUrl?: string | null
    points?: number
    rarity?: $Enums.BadgeRarity
    createdAt?: Date | string
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    code: string
    name: string
    description: string
    iconUrl?: string | null
    points?: number
    rarity?: $Enums.BadgeRarity
    createdAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateInput = {
    id?: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type UserActivityUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type UserActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewCreateInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hpoTerm: HpoTermCreateNestedOneWithoutConflictReviewsInput
    translations?: TranslationCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutConflictReviewInput
    resolver?: UserCreateNestedOneWithoutConflictsResolvedInput
  }

  export type ConflictReviewUncheckedCreateInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutConflictReviewInput
  }

  export type ConflictReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hpoTerm?: HpoTermUpdateOneRequiredWithoutConflictReviewsNestedInput
    translations?: TranslationUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutConflictReviewNestedInput
    resolver?: UserUpdateOneWithoutConflictsResolvedNestedInput
  }

  export type ConflictReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutConflictReviewNestedInput
  }

  export type ConflictReviewCreateManyInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConflictReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteCreateInput = {
    id?: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
    conflictReview: ConflictReviewCreateNestedOneWithoutCommitteeVotesInput
    voter: UserCreateNestedOneWithoutConflictVotesInput
    translation?: TranslationCreateNestedOneWithoutCommitteeVotesInput
  }

  export type CommitteeVoteUncheckedCreateInput = {
    id?: string
    conflictReviewId: string
    voterId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type CommitteeVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conflictReview?: ConflictReviewUpdateOneRequiredWithoutCommitteeVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutConflictVotesNestedInput
    translation?: TranslationUpdateOneWithoutCommitteeVotesNestedInput
  }

  export type CommitteeVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteCreateManyInput = {
    id?: string
    conflictReviewId: string
    voterId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type CommitteeVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RejectionCreateInput = {
    id?: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
    translation: TranslationCreateNestedOneWithoutRejectionInput
    admin: UserCreateNestedOneWithoutRejectionsMadeInput
  }

  export type RejectionUncheckedCreateInput = {
    id?: string
    translationId: string
    rejectedBy: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
  }

  export type RejectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutRejectionNestedInput
    admin?: UserUpdateOneRequiredWithoutRejectionsMadeNestedInput
  }

  export type RejectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    rejectedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RejectionCreateManyInput = {
    id?: string
    translationId: string
    rejectedBy: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
  }

  export type RejectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RejectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    rejectedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminId: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateInput = {
    id?: string
    syncDate?: Date | string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
    admin: UserCreateNestedOneWithoutSyncLogsInput
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    syncDate?: Date | string
    initiatedBy: string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: UserUpdateOneRequiredWithoutSyncLogsNestedInput
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncLogCreateManyInput = {
    id?: string
    syncDate?: Date | string
    initiatedBy: string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsSentInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsSentNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeCreateInput = {
    id?: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStrikesInput
    admin: UserCreateNestedOneWithoutStrikesGivenInput
    translation?: TranslationCreateNestedOneWithoutStrikesInput
  }

  export type StrikeUncheckedCreateInput = {
    id?: string
    userId: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStrikesNestedInput
    admin?: UserUpdateOneRequiredWithoutStrikesGivenNestedInput
    translation?: TranslationUpdateOneWithoutStrikesNestedInput
  }

  export type StrikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeCreateManyInput = {
    id?: string
    userId: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogCreateInput = {
    id?: string
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSessionsNestedInput
  }

  export type SessionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogCreateManyInput = {
    id?: string
    userId?: string | null
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsCreateInput = {
    id?: string
    translationsToday?: number
    validationsToday?: number
    loginStreak?: number
    lastActivityDate?: Date | string | null
    totalSessions?: number
    avgSessionDuration?: number | null
    preferredHours?: UserAnalyticsCreatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsCreatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsCreatemostUsedFeaturesInput | string[]
    avgTranslationTime?: number | null
    avgValidationTime?: number | null
    approvalRate?: number | null
    avgConfidenceScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsInput
  }

  export type UserAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    translationsToday?: number
    validationsToday?: number
    loginStreak?: number
    lastActivityDate?: Date | string | null
    totalSessions?: number
    avgSessionDuration?: number | null
    preferredHours?: UserAnalyticsCreatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsCreatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsCreatemostUsedFeaturesInput | string[]
    avgTranslationTime?: number | null
    avgValidationTime?: number | null
    approvalRate?: number | null
    avgConfidenceScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type UserAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsCreateManyInput = {
    id?: string
    userId: string
    translationsToday?: number
    validationsToday?: number
    loginStreak?: number
    lastActivityDate?: Date | string | null
    totalSessions?: number
    avgSessionDuration?: number | null
    preferredHours?: UserAnalyticsCreatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsCreatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsCreatemostUsedFeaturesInput | string[]
    avgTranslationTime?: number | null
    avgValidationTime?: number | null
    approvalRate?: number | null
    avgConfidenceScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiMetricsCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    userId?: string | null
    ipAddress: string
    userAgent: string
    errorMessage?: string | null
    errorStack?: string | null
    timestamp?: Date | string
  }

  export type ApiMetricsUncheckedCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    userId?: string | null
    ipAddress: string
    userAgent: string
    errorMessage?: string | null
    errorStack?: string | null
    timestamp?: Date | string
  }

  export type ApiMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiMetricsCreateManyInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    userId?: string | null
    ipAddress: string
    userAgent: string
    errorMessage?: string | null
    errorStack?: string | null
    timestamp?: Date | string
  }

  export type ApiMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: FloatFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TranslationListRelationFilter = {
    every?: TranslationWhereInput
    some?: TranslationWhereInput
    none?: TranslationWhereInput
  }

  export type ValidationListRelationFilter = {
    every?: ValidationWhereInput
    some?: ValidationWhereInput
    none?: ValidationWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type UserActivityListRelationFilter = {
    every?: UserActivityWhereInput
    some?: UserActivityWhereInput
    none?: UserActivityWhereInput
  }

  export type CommitteeVoteListRelationFilter = {
    every?: CommitteeVoteWhereInput
    some?: CommitteeVoteWhereInput
    none?: CommitteeVoteWhereInput
  }

  export type RejectionListRelationFilter = {
    every?: RejectionWhereInput
    some?: RejectionWhereInput
    none?: RejectionWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type SyncLogListRelationFilter = {
    every?: SyncLogWhereInput
    some?: SyncLogWhereInput
    none?: SyncLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ConflictReviewListRelationFilter = {
    every?: ConflictReviewWhereInput
    some?: ConflictReviewWhereInput
    none?: ConflictReviewWhereInput
  }

  export type StrikeListRelationFilter = {
    every?: StrikeWhereInput
    some?: StrikeWhereInput
    none?: StrikeWhereInput
  }

  export type SessionLogListRelationFilter = {
    every?: SessionLogWhereInput
    some?: SessionLogWhereInput
    none?: SessionLogWhereInput
  }

  export type UserAnalyticsNullableRelationFilter = {
    is?: UserAnalyticsWhereInput | null
    isNot?: UserAnalyticsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ValidationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommitteeVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RejectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyncLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConflictReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    orcidId?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    specialty?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    profileJson?: SortOrder
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastActiveAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedCount?: SortOrder
    hasCompletedOnboarding?: SortOrder
    warningCount?: SortOrder
    lastWarningAt?: SortOrder
    bannedBy?: SortOrder
    promotedAt?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    bannedReason?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    approvedCount?: SortOrder
    warningCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    orcidId?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    specialty?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastActiveAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedCount?: SortOrder
    hasCompletedOnboarding?: SortOrder
    warningCount?: SortOrder
    lastWarningAt?: SortOrder
    bannedBy?: SortOrder
    promotedAt?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    bannedReason?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    orcidId?: SortOrder
    role?: SortOrder
    institution?: SortOrder
    specialty?: SortOrder
    country?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastActiveAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedCount?: SortOrder
    hasCompletedOnboarding?: SortOrder
    warningCount?: SortOrder
    lastWarningAt?: SortOrder
    bannedBy?: SortOrder
    promotedAt?: SortOrder
    isActive?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    bannedReason?: SortOrder
    isVerified?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    approvedCount?: SortOrder
    warningCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumTranslationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusFilter<$PrismaModel> | $Enums.TranslationStatus
  }

  export type HpoTermNullableRelationFilter = {
    is?: HpoTermWhereInput | null
    isNot?: HpoTermWhereInput | null
  }

  export type HpoTermListRelationFilter = {
    every?: HpoTermWhereInput
    some?: HpoTermWhereInput
    none?: HpoTermWhereInput
  }

  export type HpoTermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HpoTermCountOrderByAggregateInput = {
    id?: SortOrder
    hpoId?: SortOrder
    labelEn?: SortOrder
    definitionEn?: SortOrder
    synonymsEn?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    difficulty?: SortOrder
    translationStatus?: SortOrder
    hpoVersion?: SortOrder
    isObsolete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HpoTermAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type HpoTermMaxOrderByAggregateInput = {
    id?: SortOrder
    hpoId?: SortOrder
    labelEn?: SortOrder
    definitionEn?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    difficulty?: SortOrder
    translationStatus?: SortOrder
    hpoVersion?: SortOrder
    isObsolete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HpoTermMinOrderByAggregateInput = {
    id?: SortOrder
    hpoId?: SortOrder
    labelEn?: SortOrder
    definitionEn?: SortOrder
    category?: SortOrder
    parentId?: SortOrder
    difficulty?: SortOrder
    translationStatus?: SortOrder
    hpoVersion?: SortOrder
    isObsolete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HpoTermSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type EnumTranslationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranslationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationStatusFilter<$PrismaModel>
    _max?: NestedEnumTranslationStatusFilter<$PrismaModel>
  }

  export type EnumTranslationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationSource | EnumTranslationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationSourceFilter<$PrismaModel> | $Enums.TranslationSource
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type HpoTermRelationFilter = {
    is?: HpoTermWhereInput
    isNot?: HpoTermWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RejectionNullableRelationFilter = {
    is?: RejectionWhereInput | null
    isNot?: RejectionWhereInput | null
  }

  export type TranslationCountOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    userId?: SortOrder
    labelPt?: SortOrder
    definitionPt?: SortOrder
    synonymsPt?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    isLegacy?: SortOrder
    aiSuggestion?: SortOrder
    aiConfidence?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrder
    syncedToHpo?: SortOrder
    syncedAt?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type TranslationAvgOrderByAggregateInput = {
    confidence?: SortOrder
    aiConfidence?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrder
  }

  export type TranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    userId?: SortOrder
    labelPt?: SortOrder
    definitionPt?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    isLegacy?: SortOrder
    aiSuggestion?: SortOrder
    aiConfidence?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrder
    syncedToHpo?: SortOrder
    syncedAt?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type TranslationMinOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
    userId?: SortOrder
    labelPt?: SortOrder
    definitionPt?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    confidence?: SortOrder
    source?: SortOrder
    isLegacy?: SortOrder
    aiSuggestion?: SortOrder
    aiConfidence?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrder
    syncedToHpo?: SortOrder
    syncedAt?: SortOrder
    approvedBy?: SortOrder
    rejectedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type TranslationSumOrderByAggregateInput = {
    confidence?: SortOrder
    aiConfidence?: SortOrder
    approvalCount?: SortOrder
    rejectionCount?: SortOrder
    averageRating?: SortOrder
  }

  export type EnumTranslationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationSource | EnumTranslationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationSourceWithAggregatesFilter<$PrismaModel> | $Enums.TranslationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationSourceFilter<$PrismaModel>
    _max?: NestedEnumTranslationSourceFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumValidationDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ValidationDecision | EnumValidationDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumValidationDecisionFilter<$PrismaModel> | $Enums.ValidationDecision
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TranslationRelationFilter = {
    is?: TranslationWhereInput
    isNot?: TranslationWhereInput
  }

  export type ValidationTranslationIdValidatorIdCompoundUniqueInput = {
    translationId: string
    validatorId: string
  }

  export type ValidationCountOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    validatorId?: SortOrder
    rating?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    suggestions?: SortOrder
    accuracyScore?: SortOrder
    clarityScore?: SortOrder
    consistencyScore?: SortOrder
    timeSpentSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ValidationAvgOrderByAggregateInput = {
    rating?: SortOrder
    accuracyScore?: SortOrder
    clarityScore?: SortOrder
    consistencyScore?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type ValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    validatorId?: SortOrder
    rating?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    suggestions?: SortOrder
    accuracyScore?: SortOrder
    clarityScore?: SortOrder
    consistencyScore?: SortOrder
    timeSpentSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ValidationMinOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    validatorId?: SortOrder
    rating?: SortOrder
    decision?: SortOrder
    comments?: SortOrder
    suggestions?: SortOrder
    accuracyScore?: SortOrder
    clarityScore?: SortOrder
    consistencyScore?: SortOrder
    timeSpentSeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ValidationSumOrderByAggregateInput = {
    rating?: SortOrder
    accuracyScore?: SortOrder
    clarityScore?: SortOrder
    consistencyScore?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type EnumValidationDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValidationDecision | EnumValidationDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumValidationDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ValidationDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValidationDecisionFilter<$PrismaModel>
    _max?: NestedEnumValidationDecisionFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBadgeRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityFilter<$PrismaModel> | $Enums.BadgeRarity
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumBadgeRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel> | $Enums.BadgeRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeRarityFilter<$PrismaModel>
    _max?: NestedEnumBadgeRarityFilter<$PrismaModel>
  }

  export type BadgeRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type UserActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type UserActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivitySumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConflictTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictType | EnumConflictTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictTypeFilter<$PrismaModel> | $Enums.ConflictType
  }

  export type EnumConflictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictStatus | EnumConflictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictStatusFilter<$PrismaModel> | $Enums.ConflictStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ConflictReviewCountOrderByAggregateInput = {
    id?: SortOrder
    hpoTermId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    winningTranslationId?: SortOrder
    resolution?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConflictReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    hpoTermId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    winningTranslationId?: SortOrder
    resolution?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConflictReviewMinOrderByAggregateInput = {
    id?: SortOrder
    hpoTermId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    winningTranslationId?: SortOrder
    resolution?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConflictTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictType | EnumConflictTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConflictType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConflictTypeFilter<$PrismaModel>
    _max?: NestedEnumConflictTypeFilter<$PrismaModel>
  }

  export type EnumConflictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictStatus | EnumConflictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConflictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConflictStatusFilter<$PrismaModel>
    _max?: NestedEnumConflictStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type ConflictReviewRelationFilter = {
    is?: ConflictReviewWhereInput
    isNot?: ConflictReviewWhereInput
  }

  export type TranslationNullableRelationFilter = {
    is?: TranslationWhereInput | null
    isNot?: TranslationWhereInput | null
  }

  export type CommitteeVoteConflictReviewIdVoterIdCompoundUniqueInput = {
    conflictReviewId: string
    voterId: string
  }

  export type CommitteeVoteCountOrderByAggregateInput = {
    id?: SortOrder
    conflictReviewId?: SortOrder
    voterId?: SortOrder
    translationId?: SortOrder
    voteType?: SortOrder
    comment?: SortOrder
    votedAt?: SortOrder
  }

  export type CommitteeVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    conflictReviewId?: SortOrder
    voterId?: SortOrder
    translationId?: SortOrder
    voteType?: SortOrder
    comment?: SortOrder
    votedAt?: SortOrder
  }

  export type CommitteeVoteMinOrderByAggregateInput = {
    id?: SortOrder
    conflictReviewId?: SortOrder
    voterId?: SortOrder
    translationId?: SortOrder
    voteType?: SortOrder
    comment?: SortOrder
    votedAt?: SortOrder
  }

  export type EnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type EnumRejectionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RejectionReason | EnumRejectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRejectionReasonFilter<$PrismaModel> | $Enums.RejectionReason
  }

  export type RejectionCountOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    rejectedBy?: SortOrder
    reasonCode?: SortOrder
    detailedReason?: SortOrder
    suggestions?: SortOrder
    canResubmit?: SortOrder
    createdAt?: SortOrder
  }

  export type RejectionMaxOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    rejectedBy?: SortOrder
    reasonCode?: SortOrder
    detailedReason?: SortOrder
    suggestions?: SortOrder
    canResubmit?: SortOrder
    createdAt?: SortOrder
  }

  export type RejectionMinOrderByAggregateInput = {
    id?: SortOrder
    translationId?: SortOrder
    rejectedBy?: SortOrder
    reasonCode?: SortOrder
    detailedReason?: SortOrder
    suggestions?: SortOrder
    canResubmit?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRejectionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RejectionReason | EnumRejectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRejectionReasonWithAggregatesFilter<$PrismaModel> | $Enums.RejectionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRejectionReasonFilter<$PrismaModel>
    _max?: NestedEnumRejectionReasonFilter<$PrismaModel>
  }

  export type EnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    changes?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    syncDate?: SortOrder
    initiatedBy?: SortOrder
    translationsCount?: SortOrder
    babelonFilePath?: SortOrder
    githubPrUrl?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    completedAt?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    translationsCount?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    syncDate?: SortOrder
    initiatedBy?: SortOrder
    translationsCount?: SortOrder
    babelonFilePath?: SortOrder
    githubPrUrl?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    completedAt?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    syncDate?: SortOrder
    initiatedBy?: SortOrder
    translationsCount?: SortOrder
    babelonFilePath?: SortOrder
    githubPrUrl?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    completedAt?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    translationsCount?: SortOrder
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumStrikeReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StrikeReason | EnumStrikeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStrikeReasonFilter<$PrismaModel> | $Enums.StrikeReason
  }

  export type StrikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    reason?: SortOrder
    detailedReason?: SortOrder
    translationId?: SortOrder
    severity?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StrikeAvgOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type StrikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    reason?: SortOrder
    detailedReason?: SortOrder
    translationId?: SortOrder
    severity?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StrikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    reason?: SortOrder
    detailedReason?: SortOrder
    translationId?: SortOrder
    severity?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StrikeSumOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type EnumStrikeReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StrikeReason | EnumStrikeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStrikeReasonWithAggregatesFilter<$PrismaModel> | $Enums.StrikeReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStrikeReasonFilter<$PrismaModel>
    _max?: NestedEnumStrikeReasonFilter<$PrismaModel>
  }

  export type SessionLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    userAgent?: SortOrder
    browser?: SortOrder
    browserVersion?: SortOrder
    os?: SortOrder
    osVersion?: SortOrder
    device?: SortOrder
    isMobile?: SortOrder
    sessionStart?: SortOrder
    sessionEnd?: SortOrder
    duration?: SortOrder
    pagesVisited?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionLogAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    duration?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type SessionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    userAgent?: SortOrder
    browser?: SortOrder
    browserVersion?: SortOrder
    os?: SortOrder
    osVersion?: SortOrder
    device?: SortOrder
    isMobile?: SortOrder
    sessionStart?: SortOrder
    sessionEnd?: SortOrder
    duration?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    country?: SortOrder
    city?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    userAgent?: SortOrder
    browser?: SortOrder
    browserVersion?: SortOrder
    os?: SortOrder
    osVersion?: SortOrder
    device?: SortOrder
    isMobile?: SortOrder
    sessionStart?: SortOrder
    sessionEnd?: SortOrder
    duration?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionLogSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    duration?: SortOrder
    actionsCount?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    lastActivityDate?: SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrder
    preferredHours?: SortOrder
    preferredDays?: SortOrder
    mostUsedFeatures?: SortOrder
    avgTranslationTime?: SortOrder
    avgValidationTime?: SortOrder
    approvalRate?: SortOrder
    avgConfidenceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsAvgOrderByAggregateInput = {
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrder
    preferredHours?: SortOrder
    preferredDays?: SortOrder
    avgTranslationTime?: SortOrder
    avgValidationTime?: SortOrder
    approvalRate?: SortOrder
    avgConfidenceScore?: SortOrder
  }

  export type UserAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    lastActivityDate?: SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrder
    avgTranslationTime?: SortOrder
    avgValidationTime?: SortOrder
    approvalRate?: SortOrder
    avgConfidenceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    lastActivityDate?: SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrder
    avgTranslationTime?: SortOrder
    avgValidationTime?: SortOrder
    approvalRate?: SortOrder
    avgConfidenceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAnalyticsSumOrderByAggregateInput = {
    translationsToday?: SortOrder
    validationsToday?: SortOrder
    loginStreak?: SortOrder
    totalSessions?: SortOrder
    avgSessionDuration?: SortOrder
    preferredHours?: SortOrder
    preferredDays?: SortOrder
    avgTranslationTime?: SortOrder
    avgValidationTime?: SortOrder
    approvalRate?: SortOrder
    avgConfidenceScore?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ApiMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiMetricsAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type ApiMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    timestamp?: SortOrder
  }

  export type ApiMetricsSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TranslationCreateNestedManyWithoutUserInput = {
    create?: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput> | TranslationCreateWithoutUserInput[] | TranslationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutUserInput | TranslationCreateOrConnectWithoutUserInput[]
    createMany?: TranslationCreateManyUserInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type ValidationCreateNestedManyWithoutValidatorInput = {
    create?: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput> | ValidationCreateWithoutValidatorInput[] | ValidationUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutValidatorInput | ValidationCreateOrConnectWithoutValidatorInput[]
    createMany?: ValidationCreateManyValidatorInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type CommitteeVoteCreateNestedManyWithoutVoterInput = {
    create?: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput> | CommitteeVoteCreateWithoutVoterInput[] | CommitteeVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutVoterInput | CommitteeVoteCreateOrConnectWithoutVoterInput[]
    createMany?: CommitteeVoteCreateManyVoterInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type RejectionCreateNestedManyWithoutAdminInput = {
    create?: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput> | RejectionCreateWithoutAdminInput[] | RejectionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RejectionCreateOrConnectWithoutAdminInput | RejectionCreateOrConnectWithoutAdminInput[]
    createMany?: RejectionCreateManyAdminInputEnvelope
    connect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type SyncLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput> | SyncLogCreateWithoutAdminInput[] | SyncLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutAdminInput | SyncLogCreateOrConnectWithoutAdminInput[]
    createMany?: SyncLogCreateManyAdminInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConflictReviewCreateNestedManyWithoutResolverInput = {
    create?: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput> | ConflictReviewCreateWithoutResolverInput[] | ConflictReviewUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutResolverInput | ConflictReviewCreateOrConnectWithoutResolverInput[]
    createMany?: ConflictReviewCreateManyResolverInputEnvelope
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type StrikeCreateNestedManyWithoutUserInput = {
    create?: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput> | StrikeCreateWithoutUserInput[] | StrikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutUserInput | StrikeCreateOrConnectWithoutUserInput[]
    createMany?: StrikeCreateManyUserInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type StrikeCreateNestedManyWithoutAdminInput = {
    create?: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput> | StrikeCreateWithoutAdminInput[] | StrikeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutAdminInput | StrikeCreateOrConnectWithoutAdminInput[]
    createMany?: StrikeCreateManyAdminInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type SessionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserAnalyticsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutUserInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type TranslationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput> | TranslationCreateWithoutUserInput[] | TranslationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutUserInput | TranslationCreateOrConnectWithoutUserInput[]
    createMany?: TranslationCreateManyUserInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type ValidationUncheckedCreateNestedManyWithoutValidatorInput = {
    create?: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput> | ValidationCreateWithoutValidatorInput[] | ValidationUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutValidatorInput | ValidationCreateOrConnectWithoutValidatorInput[]
    createMany?: ValidationCreateManyValidatorInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
  }

  export type CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput = {
    create?: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput> | CommitteeVoteCreateWithoutVoterInput[] | CommitteeVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutVoterInput | CommitteeVoteCreateOrConnectWithoutVoterInput[]
    createMany?: CommitteeVoteCreateManyVoterInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type RejectionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput> | RejectionCreateWithoutAdminInput[] | RejectionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RejectionCreateOrConnectWithoutAdminInput | RejectionCreateOrConnectWithoutAdminInput[]
    createMany?: RejectionCreateManyAdminInputEnvelope
    connect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type SyncLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput> | SyncLogCreateWithoutAdminInput[] | SyncLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutAdminInput | SyncLogCreateOrConnectWithoutAdminInput[]
    createMany?: SyncLogCreateManyAdminInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConflictReviewUncheckedCreateNestedManyWithoutResolverInput = {
    create?: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput> | ConflictReviewCreateWithoutResolverInput[] | ConflictReviewUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutResolverInput | ConflictReviewCreateOrConnectWithoutResolverInput[]
    createMany?: ConflictReviewCreateManyResolverInputEnvelope
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type StrikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput> | StrikeCreateWithoutUserInput[] | StrikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutUserInput | StrikeCreateOrConnectWithoutUserInput[]
    createMany?: StrikeCreateManyUserInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type StrikeUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput> | StrikeCreateWithoutAdminInput[] | StrikeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutAdminInput | StrikeCreateOrConnectWithoutAdminInput[]
    createMany?: StrikeCreateManyAdminInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type SessionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserAnalyticsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutUserInput
    connect?: UserAnalyticsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TranslationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput> | TranslationCreateWithoutUserInput[] | TranslationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutUserInput | TranslationCreateOrConnectWithoutUserInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutUserInput | TranslationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TranslationCreateManyUserInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutUserInput | TranslationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutUserInput | TranslationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type ValidationUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput> | ValidationCreateWithoutValidatorInput[] | ValidationUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutValidatorInput | ValidationCreateOrConnectWithoutValidatorInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutValidatorInput | ValidationUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: ValidationCreateManyValidatorInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutValidatorInput | ValidationUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutValidatorInput | ValidationUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type CommitteeVoteUpdateManyWithoutVoterNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput> | CommitteeVoteCreateWithoutVoterInput[] | CommitteeVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutVoterInput | CommitteeVoteCreateOrConnectWithoutVoterInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutVoterInput | CommitteeVoteUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: CommitteeVoteCreateManyVoterInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutVoterInput | CommitteeVoteUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutVoterInput | CommitteeVoteUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type RejectionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput> | RejectionCreateWithoutAdminInput[] | RejectionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RejectionCreateOrConnectWithoutAdminInput | RejectionCreateOrConnectWithoutAdminInput[]
    upsert?: RejectionUpsertWithWhereUniqueWithoutAdminInput | RejectionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RejectionCreateManyAdminInputEnvelope
    set?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    disconnect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    delete?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    connect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    update?: RejectionUpdateWithWhereUniqueWithoutAdminInput | RejectionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RejectionUpdateManyWithWhereWithoutAdminInput | RejectionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RejectionScalarWhereInput | RejectionScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type SyncLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput> | SyncLogCreateWithoutAdminInput[] | SyncLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutAdminInput | SyncLogCreateOrConnectWithoutAdminInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutAdminInput | SyncLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SyncLogCreateManyAdminInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutAdminInput | SyncLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutAdminInput | SyncLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConflictReviewUpdateManyWithoutResolverNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput> | ConflictReviewCreateWithoutResolverInput[] | ConflictReviewUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutResolverInput | ConflictReviewCreateOrConnectWithoutResolverInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutResolverInput | ConflictReviewUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: ConflictReviewCreateManyResolverInputEnvelope
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutResolverInput | ConflictReviewUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutResolverInput | ConflictReviewUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type StrikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput> | StrikeCreateWithoutUserInput[] | StrikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutUserInput | StrikeCreateOrConnectWithoutUserInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutUserInput | StrikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StrikeCreateManyUserInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutUserInput | StrikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutUserInput | StrikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type StrikeUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput> | StrikeCreateWithoutAdminInput[] | StrikeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutAdminInput | StrikeCreateOrConnectWithoutAdminInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutAdminInput | StrikeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StrikeCreateManyAdminInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutAdminInput | StrikeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutAdminInput | StrikeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type SessionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutUserInput | SessionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutUserInput | SessionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutUserInput | SessionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserAnalyticsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutUserInput
    upsert?: UserAnalyticsUpsertWithoutUserInput
    disconnect?: UserAnalyticsWhereInput | boolean
    delete?: UserAnalyticsWhereInput | boolean
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutUserInput, UserAnalyticsUpdateWithoutUserInput>, UserAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type TranslationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput> | TranslationCreateWithoutUserInput[] | TranslationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutUserInput | TranslationCreateOrConnectWithoutUserInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutUserInput | TranslationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TranslationCreateManyUserInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutUserInput | TranslationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutUserInput | TranslationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type ValidationUncheckedUpdateManyWithoutValidatorNestedInput = {
    create?: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput> | ValidationCreateWithoutValidatorInput[] | ValidationUncheckedCreateWithoutValidatorInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutValidatorInput | ValidationCreateOrConnectWithoutValidatorInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutValidatorInput | ValidationUpsertWithWhereUniqueWithoutValidatorInput[]
    createMany?: ValidationCreateManyValidatorInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutValidatorInput | ValidationUpdateWithWhereUniqueWithoutValidatorInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutValidatorInput | ValidationUpdateManyWithWhereWithoutValidatorInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput> | UserActivityCreateWithoutUserInput[] | UserActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivityCreateOrConnectWithoutUserInput | UserActivityCreateOrConnectWithoutUserInput[]
    upsert?: UserActivityUpsertWithWhereUniqueWithoutUserInput | UserActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivityCreateManyUserInputEnvelope
    set?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    disconnect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    delete?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    connect?: UserActivityWhereUniqueInput | UserActivityWhereUniqueInput[]
    update?: UserActivityUpdateWithWhereUniqueWithoutUserInput | UserActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivityUpdateManyWithWhereWithoutUserInput | UserActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput> | CommitteeVoteCreateWithoutVoterInput[] | CommitteeVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutVoterInput | CommitteeVoteCreateOrConnectWithoutVoterInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutVoterInput | CommitteeVoteUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: CommitteeVoteCreateManyVoterInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutVoterInput | CommitteeVoteUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutVoterInput | CommitteeVoteUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type RejectionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput> | RejectionCreateWithoutAdminInput[] | RejectionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RejectionCreateOrConnectWithoutAdminInput | RejectionCreateOrConnectWithoutAdminInput[]
    upsert?: RejectionUpsertWithWhereUniqueWithoutAdminInput | RejectionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RejectionCreateManyAdminInputEnvelope
    set?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    disconnect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    delete?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    connect?: RejectionWhereUniqueInput | RejectionWhereUniqueInput[]
    update?: RejectionUpdateWithWhereUniqueWithoutAdminInput | RejectionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RejectionUpdateManyWithWhereWithoutAdminInput | RejectionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RejectionScalarWhereInput | RejectionScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type SyncLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput> | SyncLogCreateWithoutAdminInput[] | SyncLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutAdminInput | SyncLogCreateOrConnectWithoutAdminInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutAdminInput | SyncLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SyncLogCreateManyAdminInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutAdminInput | SyncLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutAdminInput | SyncLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput> | ConflictReviewCreateWithoutResolverInput[] | ConflictReviewUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutResolverInput | ConflictReviewCreateOrConnectWithoutResolverInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutResolverInput | ConflictReviewUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: ConflictReviewCreateManyResolverInputEnvelope
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutResolverInput | ConflictReviewUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutResolverInput | ConflictReviewUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type StrikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput> | StrikeCreateWithoutUserInput[] | StrikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutUserInput | StrikeCreateOrConnectWithoutUserInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutUserInput | StrikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StrikeCreateManyUserInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutUserInput | StrikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutUserInput | StrikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type StrikeUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput> | StrikeCreateWithoutAdminInput[] | StrikeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutAdminInput | StrikeCreateOrConnectWithoutAdminInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutAdminInput | StrikeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: StrikeCreateManyAdminInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutAdminInput | StrikeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutAdminInput | StrikeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type SessionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutUserInput | SessionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutUserInput | SessionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutUserInput | SessionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAnalyticsCreateOrConnectWithoutUserInput
    upsert?: UserAnalyticsUpsertWithoutUserInput
    disconnect?: UserAnalyticsWhereInput | boolean
    delete?: UserAnalyticsWhereInput | boolean
    connect?: UserAnalyticsWhereUniqueInput
    update?: XOR<XOR<UserAnalyticsUpdateToOneWithWhereWithoutUserInput, UserAnalyticsUpdateWithoutUserInput>, UserAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type HpoTermCreatesynonymsEnInput = {
    set: string[]
  }

  export type TranslationCreateNestedManyWithoutTermInput = {
    create?: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput> | TranslationCreateWithoutTermInput[] | TranslationUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutTermInput | TranslationCreateOrConnectWithoutTermInput[]
    createMany?: TranslationCreateManyTermInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type HpoTermCreateNestedOneWithoutChildrenInput = {
    create?: XOR<HpoTermCreateWithoutChildrenInput, HpoTermUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutChildrenInput
    connect?: HpoTermWhereUniqueInput
  }

  export type HpoTermCreateNestedManyWithoutParentInput = {
    create?: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput> | HpoTermCreateWithoutParentInput[] | HpoTermUncheckedCreateWithoutParentInput[]
    connectOrCreate?: HpoTermCreateOrConnectWithoutParentInput | HpoTermCreateOrConnectWithoutParentInput[]
    createMany?: HpoTermCreateManyParentInputEnvelope
    connect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
  }

  export type ConflictReviewCreateNestedManyWithoutHpoTermInput = {
    create?: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput> | ConflictReviewCreateWithoutHpoTermInput[] | ConflictReviewUncheckedCreateWithoutHpoTermInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutHpoTermInput | ConflictReviewCreateOrConnectWithoutHpoTermInput[]
    createMany?: ConflictReviewCreateManyHpoTermInputEnvelope
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type TranslationUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput> | TranslationCreateWithoutTermInput[] | TranslationUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutTermInput | TranslationCreateOrConnectWithoutTermInput[]
    createMany?: TranslationCreateManyTermInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type HpoTermUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput> | HpoTermCreateWithoutParentInput[] | HpoTermUncheckedCreateWithoutParentInput[]
    connectOrCreate?: HpoTermCreateOrConnectWithoutParentInput | HpoTermCreateOrConnectWithoutParentInput[]
    createMany?: HpoTermCreateManyParentInputEnvelope
    connect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
  }

  export type ConflictReviewUncheckedCreateNestedManyWithoutHpoTermInput = {
    create?: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput> | ConflictReviewCreateWithoutHpoTermInput[] | ConflictReviewUncheckedCreateWithoutHpoTermInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutHpoTermInput | ConflictReviewCreateOrConnectWithoutHpoTermInput[]
    createMany?: ConflictReviewCreateManyHpoTermInputEnvelope
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type HpoTermUpdatesynonymsEnInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTranslationStatusFieldUpdateOperationsInput = {
    set?: $Enums.TranslationStatus
  }

  export type TranslationUpdateManyWithoutTermNestedInput = {
    create?: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput> | TranslationCreateWithoutTermInput[] | TranslationUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutTermInput | TranslationCreateOrConnectWithoutTermInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutTermInput | TranslationUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TranslationCreateManyTermInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutTermInput | TranslationUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutTermInput | TranslationUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type HpoTermUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<HpoTermCreateWithoutChildrenInput, HpoTermUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutChildrenInput
    upsert?: HpoTermUpsertWithoutChildrenInput
    disconnect?: HpoTermWhereInput | boolean
    delete?: HpoTermWhereInput | boolean
    connect?: HpoTermWhereUniqueInput
    update?: XOR<XOR<HpoTermUpdateToOneWithWhereWithoutChildrenInput, HpoTermUpdateWithoutChildrenInput>, HpoTermUncheckedUpdateWithoutChildrenInput>
  }

  export type HpoTermUpdateManyWithoutParentNestedInput = {
    create?: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput> | HpoTermCreateWithoutParentInput[] | HpoTermUncheckedCreateWithoutParentInput[]
    connectOrCreate?: HpoTermCreateOrConnectWithoutParentInput | HpoTermCreateOrConnectWithoutParentInput[]
    upsert?: HpoTermUpsertWithWhereUniqueWithoutParentInput | HpoTermUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: HpoTermCreateManyParentInputEnvelope
    set?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    disconnect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    delete?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    connect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    update?: HpoTermUpdateWithWhereUniqueWithoutParentInput | HpoTermUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: HpoTermUpdateManyWithWhereWithoutParentInput | HpoTermUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: HpoTermScalarWhereInput | HpoTermScalarWhereInput[]
  }

  export type ConflictReviewUpdateManyWithoutHpoTermNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput> | ConflictReviewCreateWithoutHpoTermInput[] | ConflictReviewUncheckedCreateWithoutHpoTermInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutHpoTermInput | ConflictReviewCreateOrConnectWithoutHpoTermInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutHpoTermInput | ConflictReviewUpsertWithWhereUniqueWithoutHpoTermInput[]
    createMany?: ConflictReviewCreateManyHpoTermInputEnvelope
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutHpoTermInput | ConflictReviewUpdateWithWhereUniqueWithoutHpoTermInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutHpoTermInput | ConflictReviewUpdateManyWithWhereWithoutHpoTermInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type TranslationUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput> | TranslationCreateWithoutTermInput[] | TranslationUncheckedCreateWithoutTermInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutTermInput | TranslationCreateOrConnectWithoutTermInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutTermInput | TranslationUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: TranslationCreateManyTermInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutTermInput | TranslationUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutTermInput | TranslationUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type HpoTermUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput> | HpoTermCreateWithoutParentInput[] | HpoTermUncheckedCreateWithoutParentInput[]
    connectOrCreate?: HpoTermCreateOrConnectWithoutParentInput | HpoTermCreateOrConnectWithoutParentInput[]
    upsert?: HpoTermUpsertWithWhereUniqueWithoutParentInput | HpoTermUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: HpoTermCreateManyParentInputEnvelope
    set?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    disconnect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    delete?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    connect?: HpoTermWhereUniqueInput | HpoTermWhereUniqueInput[]
    update?: HpoTermUpdateWithWhereUniqueWithoutParentInput | HpoTermUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: HpoTermUpdateManyWithWhereWithoutParentInput | HpoTermUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: HpoTermScalarWhereInput | HpoTermScalarWhereInput[]
  }

  export type ConflictReviewUncheckedUpdateManyWithoutHpoTermNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput> | ConflictReviewCreateWithoutHpoTermInput[] | ConflictReviewUncheckedCreateWithoutHpoTermInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutHpoTermInput | ConflictReviewCreateOrConnectWithoutHpoTermInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutHpoTermInput | ConflictReviewUpsertWithWhereUniqueWithoutHpoTermInput[]
    createMany?: ConflictReviewCreateManyHpoTermInputEnvelope
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutHpoTermInput | ConflictReviewUpdateWithWhereUniqueWithoutHpoTermInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutHpoTermInput | ConflictReviewUpdateManyWithWhereWithoutHpoTermInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type TranslationCreatesynonymsPtInput = {
    set: string[]
  }

  export type HpoTermCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<HpoTermCreateWithoutTranslationsInput, HpoTermUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutTranslationsInput
    connect?: HpoTermWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<UserCreateWithoutTranslationsInput, UserUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTranslationsInput
    connect?: UserWhereUniqueInput
  }

  export type ValidationCreateNestedManyWithoutTranslationInput = {
    create?: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput> | ValidationCreateWithoutTranslationInput[] | ValidationUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutTranslationInput | ValidationCreateOrConnectWithoutTranslationInput[]
    createMany?: ValidationCreateManyTranslationInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTranslationInput = {
    create?: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput> | CommentCreateWithoutTranslationInput[] | CommentUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationInput | CommentCreateOrConnectWithoutTranslationInput[]
    createMany?: CommentCreateManyTranslationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StrikeCreateNestedManyWithoutTranslationInput = {
    create?: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput> | StrikeCreateWithoutTranslationInput[] | StrikeUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutTranslationInput | StrikeCreateOrConnectWithoutTranslationInput[]
    createMany?: StrikeCreateManyTranslationInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type RejectionCreateNestedOneWithoutTranslationInput = {
    create?: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: RejectionCreateOrConnectWithoutTranslationInput
    connect?: RejectionWhereUniqueInput
  }

  export type ConflictReviewCreateNestedManyWithoutTranslationsInput = {
    create?: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput> | ConflictReviewCreateWithoutTranslationsInput[] | ConflictReviewUncheckedCreateWithoutTranslationsInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutTranslationsInput | ConflictReviewCreateOrConnectWithoutTranslationsInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type CommitteeVoteCreateNestedManyWithoutTranslationInput = {
    create?: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput> | CommitteeVoteCreateWithoutTranslationInput[] | CommitteeVoteUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutTranslationInput | CommitteeVoteCreateOrConnectWithoutTranslationInput[]
    createMany?: CommitteeVoteCreateManyTranslationInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type ValidationUncheckedCreateNestedManyWithoutTranslationInput = {
    create?: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput> | ValidationCreateWithoutTranslationInput[] | ValidationUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutTranslationInput | ValidationCreateOrConnectWithoutTranslationInput[]
    createMany?: ValidationCreateManyTranslationInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTranslationInput = {
    create?: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput> | CommentCreateWithoutTranslationInput[] | CommentUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationInput | CommentCreateOrConnectWithoutTranslationInput[]
    createMany?: CommentCreateManyTranslationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StrikeUncheckedCreateNestedManyWithoutTranslationInput = {
    create?: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput> | StrikeCreateWithoutTranslationInput[] | StrikeUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutTranslationInput | StrikeCreateOrConnectWithoutTranslationInput[]
    createMany?: StrikeCreateManyTranslationInputEnvelope
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
  }

  export type RejectionUncheckedCreateNestedOneWithoutTranslationInput = {
    create?: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: RejectionCreateOrConnectWithoutTranslationInput
    connect?: RejectionWhereUniqueInput
  }

  export type ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput = {
    create?: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput> | ConflictReviewCreateWithoutTranslationsInput[] | ConflictReviewUncheckedCreateWithoutTranslationsInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutTranslationsInput | ConflictReviewCreateOrConnectWithoutTranslationsInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
  }

  export type CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput = {
    create?: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput> | CommitteeVoteCreateWithoutTranslationInput[] | CommitteeVoteUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutTranslationInput | CommitteeVoteCreateOrConnectWithoutTranslationInput[]
    createMany?: CommitteeVoteCreateManyTranslationInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type TranslationUpdatesynonymsPtInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTranslationSourceFieldUpdateOperationsInput = {
    set?: $Enums.TranslationSource
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HpoTermUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<HpoTermCreateWithoutTranslationsInput, HpoTermUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutTranslationsInput
    upsert?: HpoTermUpsertWithoutTranslationsInput
    connect?: HpoTermWhereUniqueInput
    update?: XOR<XOR<HpoTermUpdateToOneWithWhereWithoutTranslationsInput, HpoTermUpdateWithoutTranslationsInput>, HpoTermUncheckedUpdateWithoutTranslationsInput>
  }

  export type UserUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<UserCreateWithoutTranslationsInput, UserUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTranslationsInput
    upsert?: UserUpsertWithoutTranslationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTranslationsInput, UserUpdateWithoutTranslationsInput>, UserUncheckedUpdateWithoutTranslationsInput>
  }

  export type ValidationUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput> | ValidationCreateWithoutTranslationInput[] | ValidationUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutTranslationInput | ValidationCreateOrConnectWithoutTranslationInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutTranslationInput | ValidationUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: ValidationCreateManyTranslationInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutTranslationInput | ValidationUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutTranslationInput | ValidationUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput> | CommentCreateWithoutTranslationInput[] | CommentUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationInput | CommentCreateOrConnectWithoutTranslationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTranslationInput | CommentUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: CommentCreateManyTranslationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTranslationInput | CommentUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTranslationInput | CommentUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type StrikeUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput> | StrikeCreateWithoutTranslationInput[] | StrikeUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutTranslationInput | StrikeCreateOrConnectWithoutTranslationInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutTranslationInput | StrikeUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: StrikeCreateManyTranslationInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutTranslationInput | StrikeUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutTranslationInput | StrikeUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type RejectionUpdateOneWithoutTranslationNestedInput = {
    create?: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: RejectionCreateOrConnectWithoutTranslationInput
    upsert?: RejectionUpsertWithoutTranslationInput
    disconnect?: RejectionWhereInput | boolean
    delete?: RejectionWhereInput | boolean
    connect?: RejectionWhereUniqueInput
    update?: XOR<XOR<RejectionUpdateToOneWithWhereWithoutTranslationInput, RejectionUpdateWithoutTranslationInput>, RejectionUncheckedUpdateWithoutTranslationInput>
  }

  export type ConflictReviewUpdateManyWithoutTranslationsNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput> | ConflictReviewCreateWithoutTranslationsInput[] | ConflictReviewUncheckedCreateWithoutTranslationsInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutTranslationsInput | ConflictReviewCreateOrConnectWithoutTranslationsInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutTranslationsInput | ConflictReviewUpsertWithWhereUniqueWithoutTranslationsInput[]
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutTranslationsInput | ConflictReviewUpdateWithWhereUniqueWithoutTranslationsInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutTranslationsInput | ConflictReviewUpdateManyWithWhereWithoutTranslationsInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type CommitteeVoteUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput> | CommitteeVoteCreateWithoutTranslationInput[] | CommitteeVoteUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutTranslationInput | CommitteeVoteCreateOrConnectWithoutTranslationInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutTranslationInput | CommitteeVoteUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: CommitteeVoteCreateManyTranslationInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutTranslationInput | CommitteeVoteUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutTranslationInput | CommitteeVoteUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type ValidationUncheckedUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput> | ValidationCreateWithoutTranslationInput[] | ValidationUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutTranslationInput | ValidationCreateOrConnectWithoutTranslationInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutTranslationInput | ValidationUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: ValidationCreateManyTranslationInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutTranslationInput | ValidationUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutTranslationInput | ValidationUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput> | CommentCreateWithoutTranslationInput[] | CommentUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTranslationInput | CommentCreateOrConnectWithoutTranslationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTranslationInput | CommentUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: CommentCreateManyTranslationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTranslationInput | CommentUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTranslationInput | CommentUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type StrikeUncheckedUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput> | StrikeCreateWithoutTranslationInput[] | StrikeUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: StrikeCreateOrConnectWithoutTranslationInput | StrikeCreateOrConnectWithoutTranslationInput[]
    upsert?: StrikeUpsertWithWhereUniqueWithoutTranslationInput | StrikeUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: StrikeCreateManyTranslationInputEnvelope
    set?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    disconnect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    delete?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    connect?: StrikeWhereUniqueInput | StrikeWhereUniqueInput[]
    update?: StrikeUpdateWithWhereUniqueWithoutTranslationInput | StrikeUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: StrikeUpdateManyWithWhereWithoutTranslationInput | StrikeUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
  }

  export type RejectionUncheckedUpdateOneWithoutTranslationNestedInput = {
    create?: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: RejectionCreateOrConnectWithoutTranslationInput
    upsert?: RejectionUpsertWithoutTranslationInput
    disconnect?: RejectionWhereInput | boolean
    delete?: RejectionWhereInput | boolean
    connect?: RejectionWhereUniqueInput
    update?: XOR<XOR<RejectionUpdateToOneWithWhereWithoutTranslationInput, RejectionUpdateWithoutTranslationInput>, RejectionUncheckedUpdateWithoutTranslationInput>
  }

  export type ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput> | ConflictReviewCreateWithoutTranslationsInput[] | ConflictReviewUncheckedCreateWithoutTranslationsInput[]
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutTranslationsInput | ConflictReviewCreateOrConnectWithoutTranslationsInput[]
    upsert?: ConflictReviewUpsertWithWhereUniqueWithoutTranslationsInput | ConflictReviewUpsertWithWhereUniqueWithoutTranslationsInput[]
    set?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    disconnect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    delete?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    connect?: ConflictReviewWhereUniqueInput | ConflictReviewWhereUniqueInput[]
    update?: ConflictReviewUpdateWithWhereUniqueWithoutTranslationsInput | ConflictReviewUpdateWithWhereUniqueWithoutTranslationsInput[]
    updateMany?: ConflictReviewUpdateManyWithWhereWithoutTranslationsInput | ConflictReviewUpdateManyWithWhereWithoutTranslationsInput[]
    deleteMany?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput> | CommitteeVoteCreateWithoutTranslationInput[] | CommitteeVoteUncheckedCreateWithoutTranslationInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutTranslationInput | CommitteeVoteCreateOrConnectWithoutTranslationInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutTranslationInput | CommitteeVoteUpsertWithWhereUniqueWithoutTranslationInput[]
    createMany?: CommitteeVoteCreateManyTranslationInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutTranslationInput | CommitteeVoteUpdateWithWhereUniqueWithoutTranslationInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutTranslationInput | CommitteeVoteUpdateManyWithWhereWithoutTranslationInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type TranslationCreateNestedOneWithoutValidationsInput = {
    create?: XOR<TranslationCreateWithoutValidationsInput, TranslationUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutValidationsInput
    connect?: TranslationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutValidationsInput = {
    create?: XOR<UserCreateWithoutValidationsInput, UserUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumValidationDecisionFieldUpdateOperationsInput = {
    set?: $Enums.ValidationDecision
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TranslationUpdateOneRequiredWithoutValidationsNestedInput = {
    create?: XOR<TranslationCreateWithoutValidationsInput, TranslationUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutValidationsInput
    upsert?: TranslationUpsertWithoutValidationsInput
    connect?: TranslationWhereUniqueInput
    update?: XOR<XOR<TranslationUpdateToOneWithWhereWithoutValidationsInput, TranslationUpdateWithoutValidationsInput>, TranslationUncheckedUpdateWithoutValidationsInput>
  }

  export type UserUpdateOneRequiredWithoutValidationsNestedInput = {
    create?: XOR<UserCreateWithoutValidationsInput, UserUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidationsInput
    upsert?: UserUpsertWithoutValidationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidationsInput, UserUpdateWithoutValidationsInput>, UserUncheckedUpdateWithoutValidationsInput>
  }

  export type TranslationCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TranslationCreateWithoutCommentsInput, TranslationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutCommentsInput
    connect?: TranslationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TranslationUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TranslationCreateWithoutCommentsInput, TranslationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutCommentsInput
    upsert?: TranslationUpsertWithoutCommentsInput
    connect?: TranslationWhereUniqueInput
    update?: XOR<XOR<TranslationUpdateToOneWithWhereWithoutCommentsInput, TranslationUpdateWithoutCommentsInput>, TranslationUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type EnumBadgeRarityFieldUpdateOperationsInput = {
    set?: $Enums.BadgeRarity
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type HpoTermCreateNestedOneWithoutConflictReviewsInput = {
    create?: XOR<HpoTermCreateWithoutConflictReviewsInput, HpoTermUncheckedCreateWithoutConflictReviewsInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutConflictReviewsInput
    connect?: HpoTermWhereUniqueInput
  }

  export type TranslationCreateNestedManyWithoutConflictReviewsInput = {
    create?: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput> | TranslationCreateWithoutConflictReviewsInput[] | TranslationUncheckedCreateWithoutConflictReviewsInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutConflictReviewsInput | TranslationCreateOrConnectWithoutConflictReviewsInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type CommitteeVoteCreateNestedManyWithoutConflictReviewInput = {
    create?: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput> | CommitteeVoteCreateWithoutConflictReviewInput[] | CommitteeVoteUncheckedCreateWithoutConflictReviewInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutConflictReviewInput | CommitteeVoteCreateOrConnectWithoutConflictReviewInput[]
    createMany?: CommitteeVoteCreateManyConflictReviewInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutConflictsResolvedInput = {
    create?: XOR<UserCreateWithoutConflictsResolvedInput, UserUncheckedCreateWithoutConflictsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConflictsResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type TranslationUncheckedCreateNestedManyWithoutConflictReviewsInput = {
    create?: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput> | TranslationCreateWithoutConflictReviewsInput[] | TranslationUncheckedCreateWithoutConflictReviewsInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutConflictReviewsInput | TranslationCreateOrConnectWithoutConflictReviewsInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type CommitteeVoteUncheckedCreateNestedManyWithoutConflictReviewInput = {
    create?: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput> | CommitteeVoteCreateWithoutConflictReviewInput[] | CommitteeVoteUncheckedCreateWithoutConflictReviewInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutConflictReviewInput | CommitteeVoteCreateOrConnectWithoutConflictReviewInput[]
    createMany?: CommitteeVoteCreateManyConflictReviewInputEnvelope
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
  }

  export type EnumConflictTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConflictType
  }

  export type EnumConflictStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConflictStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type HpoTermUpdateOneRequiredWithoutConflictReviewsNestedInput = {
    create?: XOR<HpoTermCreateWithoutConflictReviewsInput, HpoTermUncheckedCreateWithoutConflictReviewsInput>
    connectOrCreate?: HpoTermCreateOrConnectWithoutConflictReviewsInput
    upsert?: HpoTermUpsertWithoutConflictReviewsInput
    connect?: HpoTermWhereUniqueInput
    update?: XOR<XOR<HpoTermUpdateToOneWithWhereWithoutConflictReviewsInput, HpoTermUpdateWithoutConflictReviewsInput>, HpoTermUncheckedUpdateWithoutConflictReviewsInput>
  }

  export type TranslationUpdateManyWithoutConflictReviewsNestedInput = {
    create?: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput> | TranslationCreateWithoutConflictReviewsInput[] | TranslationUncheckedCreateWithoutConflictReviewsInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutConflictReviewsInput | TranslationCreateOrConnectWithoutConflictReviewsInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutConflictReviewsInput | TranslationUpsertWithWhereUniqueWithoutConflictReviewsInput[]
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutConflictReviewsInput | TranslationUpdateWithWhereUniqueWithoutConflictReviewsInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutConflictReviewsInput | TranslationUpdateManyWithWhereWithoutConflictReviewsInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type CommitteeVoteUpdateManyWithoutConflictReviewNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput> | CommitteeVoteCreateWithoutConflictReviewInput[] | CommitteeVoteUncheckedCreateWithoutConflictReviewInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutConflictReviewInput | CommitteeVoteCreateOrConnectWithoutConflictReviewInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutConflictReviewInput | CommitteeVoteUpsertWithWhereUniqueWithoutConflictReviewInput[]
    createMany?: CommitteeVoteCreateManyConflictReviewInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutConflictReviewInput | CommitteeVoteUpdateWithWhereUniqueWithoutConflictReviewInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutConflictReviewInput | CommitteeVoteUpdateManyWithWhereWithoutConflictReviewInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type UserUpdateOneWithoutConflictsResolvedNestedInput = {
    create?: XOR<UserCreateWithoutConflictsResolvedInput, UserUncheckedCreateWithoutConflictsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConflictsResolvedInput
    upsert?: UserUpsertWithoutConflictsResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConflictsResolvedInput, UserUpdateWithoutConflictsResolvedInput>, UserUncheckedUpdateWithoutConflictsResolvedInput>
  }

  export type TranslationUncheckedUpdateManyWithoutConflictReviewsNestedInput = {
    create?: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput> | TranslationCreateWithoutConflictReviewsInput[] | TranslationUncheckedCreateWithoutConflictReviewsInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutConflictReviewsInput | TranslationCreateOrConnectWithoutConflictReviewsInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutConflictReviewsInput | TranslationUpsertWithWhereUniqueWithoutConflictReviewsInput[]
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutConflictReviewsInput | TranslationUpdateWithWhereUniqueWithoutConflictReviewsInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutConflictReviewsInput | TranslationUpdateManyWithWhereWithoutConflictReviewsInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutConflictReviewNestedInput = {
    create?: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput> | CommitteeVoteCreateWithoutConflictReviewInput[] | CommitteeVoteUncheckedCreateWithoutConflictReviewInput[]
    connectOrCreate?: CommitteeVoteCreateOrConnectWithoutConflictReviewInput | CommitteeVoteCreateOrConnectWithoutConflictReviewInput[]
    upsert?: CommitteeVoteUpsertWithWhereUniqueWithoutConflictReviewInput | CommitteeVoteUpsertWithWhereUniqueWithoutConflictReviewInput[]
    createMany?: CommitteeVoteCreateManyConflictReviewInputEnvelope
    set?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    disconnect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    delete?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    connect?: CommitteeVoteWhereUniqueInput | CommitteeVoteWhereUniqueInput[]
    update?: CommitteeVoteUpdateWithWhereUniqueWithoutConflictReviewInput | CommitteeVoteUpdateWithWhereUniqueWithoutConflictReviewInput[]
    updateMany?: CommitteeVoteUpdateManyWithWhereWithoutConflictReviewInput | CommitteeVoteUpdateManyWithWhereWithoutConflictReviewInput[]
    deleteMany?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
  }

  export type ConflictReviewCreateNestedOneWithoutCommitteeVotesInput = {
    create?: XOR<ConflictReviewCreateWithoutCommitteeVotesInput, ConflictReviewUncheckedCreateWithoutCommitteeVotesInput>
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutCommitteeVotesInput
    connect?: ConflictReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConflictVotesInput = {
    create?: XOR<UserCreateWithoutConflictVotesInput, UserUncheckedCreateWithoutConflictVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConflictVotesInput
    connect?: UserWhereUniqueInput
  }

  export type TranslationCreateNestedOneWithoutCommitteeVotesInput = {
    create?: XOR<TranslationCreateWithoutCommitteeVotesInput, TranslationUncheckedCreateWithoutCommitteeVotesInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutCommitteeVotesInput
    connect?: TranslationWhereUniqueInput
  }

  export type EnumVoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoteType
  }

  export type ConflictReviewUpdateOneRequiredWithoutCommitteeVotesNestedInput = {
    create?: XOR<ConflictReviewCreateWithoutCommitteeVotesInput, ConflictReviewUncheckedCreateWithoutCommitteeVotesInput>
    connectOrCreate?: ConflictReviewCreateOrConnectWithoutCommitteeVotesInput
    upsert?: ConflictReviewUpsertWithoutCommitteeVotesInput
    connect?: ConflictReviewWhereUniqueInput
    update?: XOR<XOR<ConflictReviewUpdateToOneWithWhereWithoutCommitteeVotesInput, ConflictReviewUpdateWithoutCommitteeVotesInput>, ConflictReviewUncheckedUpdateWithoutCommitteeVotesInput>
  }

  export type UserUpdateOneRequiredWithoutConflictVotesNestedInput = {
    create?: XOR<UserCreateWithoutConflictVotesInput, UserUncheckedCreateWithoutConflictVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConflictVotesInput
    upsert?: UserUpsertWithoutConflictVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConflictVotesInput, UserUpdateWithoutConflictVotesInput>, UserUncheckedUpdateWithoutConflictVotesInput>
  }

  export type TranslationUpdateOneWithoutCommitteeVotesNestedInput = {
    create?: XOR<TranslationCreateWithoutCommitteeVotesInput, TranslationUncheckedCreateWithoutCommitteeVotesInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutCommitteeVotesInput
    upsert?: TranslationUpsertWithoutCommitteeVotesInput
    disconnect?: TranslationWhereInput | boolean
    delete?: TranslationWhereInput | boolean
    connect?: TranslationWhereUniqueInput
    update?: XOR<XOR<TranslationUpdateToOneWithWhereWithoutCommitteeVotesInput, TranslationUpdateWithoutCommitteeVotesInput>, TranslationUncheckedUpdateWithoutCommitteeVotesInput>
  }

  export type TranslationCreateNestedOneWithoutRejectionInput = {
    create?: XOR<TranslationCreateWithoutRejectionInput, TranslationUncheckedCreateWithoutRejectionInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutRejectionInput
    connect?: TranslationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRejectionsMadeInput = {
    create?: XOR<UserCreateWithoutRejectionsMadeInput, UserUncheckedCreateWithoutRejectionsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRejectionsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRejectionReasonFieldUpdateOperationsInput = {
    set?: $Enums.RejectionReason
  }

  export type TranslationUpdateOneRequiredWithoutRejectionNestedInput = {
    create?: XOR<TranslationCreateWithoutRejectionInput, TranslationUncheckedCreateWithoutRejectionInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutRejectionInput
    upsert?: TranslationUpsertWithoutRejectionInput
    connect?: TranslationWhereUniqueInput
    update?: XOR<XOR<TranslationUpdateToOneWithWhereWithoutRejectionInput, TranslationUpdateWithoutRejectionInput>, TranslationUncheckedUpdateWithoutRejectionInput>
  }

  export type UserUpdateOneRequiredWithoutRejectionsMadeNestedInput = {
    create?: XOR<UserCreateWithoutRejectionsMadeInput, UserUncheckedCreateWithoutRejectionsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutRejectionsMadeInput
    upsert?: UserUpsertWithoutRejectionsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRejectionsMadeInput, UserUpdateWithoutRejectionsMadeInput>, UserUncheckedUpdateWithoutRejectionsMadeInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAdminActionFieldUpdateOperationsInput = {
    set?: $Enums.AdminAction
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSyncLogsInput = {
    create?: XOR<UserCreateWithoutSyncLogsInput, UserUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSyncLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type UserUpdateOneRequiredWithoutSyncLogsNestedInput = {
    create?: XOR<UserCreateWithoutSyncLogsInput, UserUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSyncLogsInput
    upsert?: UserUpsertWithoutSyncLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSyncLogsInput, UserUpdateWithoutSyncLogsInput>, UserUncheckedUpdateWithoutSyncLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsSentInput = {
    create?: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsSentNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsSentInput
    upsert?: UserUpsertWithoutNotificationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsSentInput, UserUpdateWithoutNotificationsSentInput>, UserUncheckedUpdateWithoutNotificationsSentInput>
  }

  export type UserCreateNestedOneWithoutStrikesInput = {
    create?: XOR<UserCreateWithoutStrikesInput, UserUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrikesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStrikesGivenInput = {
    create?: XOR<UserCreateWithoutStrikesGivenInput, UserUncheckedCreateWithoutStrikesGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrikesGivenInput
    connect?: UserWhereUniqueInput
  }

  export type TranslationCreateNestedOneWithoutStrikesInput = {
    create?: XOR<TranslationCreateWithoutStrikesInput, TranslationUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutStrikesInput
    connect?: TranslationWhereUniqueInput
  }

  export type EnumStrikeReasonFieldUpdateOperationsInput = {
    set?: $Enums.StrikeReason
  }

  export type UserUpdateOneRequiredWithoutStrikesNestedInput = {
    create?: XOR<UserCreateWithoutStrikesInput, UserUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrikesInput
    upsert?: UserUpsertWithoutStrikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStrikesInput, UserUpdateWithoutStrikesInput>, UserUncheckedUpdateWithoutStrikesInput>
  }

  export type UserUpdateOneRequiredWithoutStrikesGivenNestedInput = {
    create?: XOR<UserCreateWithoutStrikesGivenInput, UserUncheckedCreateWithoutStrikesGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrikesGivenInput
    upsert?: UserUpsertWithoutStrikesGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStrikesGivenInput, UserUpdateWithoutStrikesGivenInput>, UserUncheckedUpdateWithoutStrikesGivenInput>
  }

  export type TranslationUpdateOneWithoutStrikesNestedInput = {
    create?: XOR<TranslationCreateWithoutStrikesInput, TranslationUncheckedCreateWithoutStrikesInput>
    connectOrCreate?: TranslationCreateOrConnectWithoutStrikesInput
    upsert?: TranslationUpsertWithoutStrikesInput
    disconnect?: TranslationWhereInput | boolean
    delete?: TranslationWhereInput | boolean
    connect?: TranslationWhereUniqueInput
    update?: XOR<XOR<TranslationUpdateToOneWithWhereWithoutStrikesInput, TranslationUpdateWithoutStrikesInput>, TranslationUncheckedUpdateWithoutStrikesInput>
  }

  export type SessionLogCreatepagesVisitedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type SessionLogUpdatepagesVisitedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserAnalyticsCreatepreferredHoursInput = {
    set: number[]
  }

  export type UserAnalyticsCreatepreferredDaysInput = {
    set: number[]
  }

  export type UserAnalyticsCreatemostUsedFeaturesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type UserAnalyticsUpdatepreferredHoursInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserAnalyticsUpdatepreferredDaysInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserAnalyticsUpdatemostUsedFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    upsert?: UserUpsertWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsInput, UserUpdateWithoutAnalyticsInput>, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTranslationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusFilter<$PrismaModel> | $Enums.TranslationStatus
  }

  export type NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationStatus | EnumTranslationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationStatus[] | ListEnumTranslationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranslationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationStatusFilter<$PrismaModel>
    _max?: NestedEnumTranslationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTranslationSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationSource | EnumTranslationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationSourceFilter<$PrismaModel> | $Enums.TranslationSource
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTranslationSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranslationSource | EnumTranslationSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranslationSource[] | ListEnumTranslationSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTranslationSourceWithAggregatesFilter<$PrismaModel> | $Enums.TranslationSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranslationSourceFilter<$PrismaModel>
    _max?: NestedEnumTranslationSourceFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumValidationDecisionFilter<$PrismaModel = never> = {
    equals?: $Enums.ValidationDecision | EnumValidationDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumValidationDecisionFilter<$PrismaModel> | $Enums.ValidationDecision
  }

  export type NestedEnumValidationDecisionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValidationDecision | EnumValidationDecisionFieldRefInput<$PrismaModel>
    in?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ValidationDecision[] | ListEnumValidationDecisionFieldRefInput<$PrismaModel>
    not?: NestedEnumValidationDecisionWithAggregatesFilter<$PrismaModel> | $Enums.ValidationDecision
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValidationDecisionFilter<$PrismaModel>
    _max?: NestedEnumValidationDecisionFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumBadgeRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityFilter<$PrismaModel> | $Enums.BadgeRarity
  }

  export type NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BadgeRarity | EnumBadgeRarityFieldRefInput<$PrismaModel>
    in?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.BadgeRarity[] | ListEnumBadgeRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumBadgeRarityWithAggregatesFilter<$PrismaModel> | $Enums.BadgeRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBadgeRarityFilter<$PrismaModel>
    _max?: NestedEnumBadgeRarityFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumConflictTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictType | EnumConflictTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictTypeFilter<$PrismaModel> | $Enums.ConflictType
  }

  export type NestedEnumConflictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictStatus | EnumConflictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictStatusFilter<$PrismaModel> | $Enums.ConflictStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumConflictTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictType | EnumConflictTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictType[] | ListEnumConflictTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConflictType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConflictTypeFilter<$PrismaModel>
    _max?: NestedEnumConflictTypeFilter<$PrismaModel>
  }

  export type NestedEnumConflictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConflictStatus | EnumConflictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConflictStatus[] | ListEnumConflictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConflictStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConflictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConflictStatusFilter<$PrismaModel>
    _max?: NestedEnumConflictStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumRejectionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RejectionReason | EnumRejectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRejectionReasonFilter<$PrismaModel> | $Enums.RejectionReason
  }

  export type NestedEnumRejectionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RejectionReason | EnumRejectionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.RejectionReason[] | ListEnumRejectionReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumRejectionReasonWithAggregatesFilter<$PrismaModel> | $Enums.RejectionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRejectionReasonFilter<$PrismaModel>
    _max?: NestedEnumRejectionReasonFilter<$PrismaModel>
  }

  export type NestedEnumAdminActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionFilter<$PrismaModel> | $Enums.AdminAction
  }

  export type NestedEnumAdminActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminAction | EnumAdminActionFieldRefInput<$PrismaModel>
    in?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminAction[] | ListEnumAdminActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminActionWithAggregatesFilter<$PrismaModel> | $Enums.AdminAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminActionFilter<$PrismaModel>
    _max?: NestedEnumAdminActionFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumStrikeReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.StrikeReason | EnumStrikeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStrikeReasonFilter<$PrismaModel> | $Enums.StrikeReason
  }

  export type NestedEnumStrikeReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StrikeReason | EnumStrikeReasonFieldRefInput<$PrismaModel>
    in?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.StrikeReason[] | ListEnumStrikeReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumStrikeReasonWithAggregatesFilter<$PrismaModel> | $Enums.StrikeReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStrikeReasonFilter<$PrismaModel>
    _max?: NestedEnumStrikeReasonFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TranslationCreateWithoutUserInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutUserInput = {
    id?: string
    termId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutUserInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput>
  }

  export type TranslationCreateManyUserInputEnvelope = {
    data: TranslationCreateManyUserInput | TranslationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ValidationCreateWithoutValidatorInput = {
    id?: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
    translation: TranslationCreateNestedOneWithoutValidationsInput
  }

  export type ValidationUncheckedCreateWithoutValidatorInput = {
    id?: string
    translationId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type ValidationCreateOrConnectWithoutValidatorInput = {
    where: ValidationWhereUniqueInput
    create: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput>
  }

  export type ValidationCreateManyValidatorInputEnvelope = {
    data: ValidationCreateManyValidatorInput | ValidationCreateManyValidatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translation: TranslationCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    translationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    earnedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserActivityCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserActivityCreateOrConnectWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityCreateManyUserInputEnvelope = {
    data: UserActivityCreateManyUserInput | UserActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommitteeVoteCreateWithoutVoterInput = {
    id?: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
    conflictReview: ConflictReviewCreateNestedOneWithoutCommitteeVotesInput
    translation?: TranslationCreateNestedOneWithoutCommitteeVotesInput
  }

  export type CommitteeVoteUncheckedCreateWithoutVoterInput = {
    id?: string
    conflictReviewId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type CommitteeVoteCreateOrConnectWithoutVoterInput = {
    where: CommitteeVoteWhereUniqueInput
    create: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput>
  }

  export type CommitteeVoteCreateManyVoterInputEnvelope = {
    data: CommitteeVoteCreateManyVoterInput | CommitteeVoteCreateManyVoterInput[]
    skipDuplicates?: boolean
  }

  export type RejectionCreateWithoutAdminInput = {
    id?: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
    translation: TranslationCreateNestedOneWithoutRejectionInput
  }

  export type RejectionUncheckedCreateWithoutAdminInput = {
    id?: string
    translationId: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
  }

  export type RejectionCreateOrConnectWithoutAdminInput = {
    where: RejectionWhereUniqueInput
    create: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput>
  }

  export type RejectionCreateManyAdminInputEnvelope = {
    data: RejectionCreateManyAdminInput | RejectionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type SyncLogCreateWithoutAdminInput = {
    id?: string
    syncDate?: Date | string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
  }

  export type SyncLogUncheckedCreateWithoutAdminInput = {
    id?: string
    syncDate?: Date | string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
  }

  export type SyncLogCreateOrConnectWithoutAdminInput = {
    where: SyncLogWhereUniqueInput
    create: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput>
  }

  export type SyncLogCreateManyAdminInputEnvelope = {
    data: SyncLogCreateManyAdminInput | SyncLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConflictReviewCreateWithoutResolverInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hpoTerm: HpoTermCreateNestedOneWithoutConflictReviewsInput
    translations?: TranslationCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutConflictReviewInput
  }

  export type ConflictReviewUncheckedCreateWithoutResolverInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutConflictReviewInput
  }

  export type ConflictReviewCreateOrConnectWithoutResolverInput = {
    where: ConflictReviewWhereUniqueInput
    create: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput>
  }

  export type ConflictReviewCreateManyResolverInputEnvelope = {
    data: ConflictReviewCreateManyResolverInput | ConflictReviewCreateManyResolverInput[]
    skipDuplicates?: boolean
  }

  export type StrikeCreateWithoutUserInput = {
    id?: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutStrikesGivenInput
    translation?: TranslationCreateNestedOneWithoutStrikesInput
  }

  export type StrikeUncheckedCreateWithoutUserInput = {
    id?: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeCreateOrConnectWithoutUserInput = {
    where: StrikeWhereUniqueInput
    create: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput>
  }

  export type StrikeCreateManyUserInputEnvelope = {
    data: StrikeCreateManyUserInput | StrikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StrikeCreateWithoutAdminInput = {
    id?: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStrikesInput
    translation?: TranslationCreateNestedOneWithoutStrikesInput
  }

  export type StrikeUncheckedCreateWithoutAdminInput = {
    id?: string
    userId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeCreateOrConnectWithoutAdminInput = {
    where: StrikeWhereUniqueInput
    create: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput>
  }

  export type StrikeCreateManyAdminInputEnvelope = {
    data: StrikeCreateManyAdminInput | StrikeCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type SessionLogCreateWithoutUserInput = {
    id?: string
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionLogUncheckedCreateWithoutUserInput = {
    id?: string
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionLogCreateOrConnectWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    create: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput>
  }

  export type SessionLogCreateManyUserInputEnvelope = {
    data: SessionLogCreateManyUserInput | SessionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAnalyticsCreateWithoutUserInput = {
    id?: string
    translationsToday?: number
    validationsToday?: number
    loginStreak?: number
    lastActivityDate?: Date | string | null
    totalSessions?: number
    avgSessionDuration?: number | null
    preferredHours?: UserAnalyticsCreatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsCreatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsCreatemostUsedFeaturesInput | string[]
    avgTranslationTime?: number | null
    avgValidationTime?: number | null
    approvalRate?: number | null
    avgConfidenceScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    translationsToday?: number
    validationsToday?: number
    loginStreak?: number
    lastActivityDate?: Date | string | null
    totalSessions?: number
    avgSessionDuration?: number | null
    preferredHours?: UserAnalyticsCreatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsCreatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsCreatemostUsedFeaturesInput | string[]
    avgTranslationTime?: number | null
    avgValidationTime?: number | null
    approvalRate?: number | null
    avgConfidenceScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAnalyticsCreateOrConnectWithoutUserInput = {
    where: UserAnalyticsWhereUniqueInput
    create: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type TranslationUpsertWithWhereUniqueWithoutUserInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutUserInput, TranslationUncheckedUpdateWithoutUserInput>
    create: XOR<TranslationCreateWithoutUserInput, TranslationUncheckedCreateWithoutUserInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutUserInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutUserInput, TranslationUncheckedUpdateWithoutUserInput>
  }

  export type TranslationUpdateManyWithWhereWithoutUserInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutUserInput>
  }

  export type TranslationScalarWhereInput = {
    AND?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    OR?: TranslationScalarWhereInput[]
    NOT?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    id?: StringFilter<"Translation"> | string
    termId?: StringFilter<"Translation"> | string
    userId?: StringFilter<"Translation"> | string
    labelPt?: StringFilter<"Translation"> | string
    definitionPt?: StringNullableFilter<"Translation"> | string | null
    synonymsPt?: StringNullableListFilter<"Translation">
    notes?: StringNullableFilter<"Translation"> | string | null
    status?: EnumTranslationStatusFilter<"Translation"> | $Enums.TranslationStatus
    confidence?: IntFilter<"Translation"> | number
    source?: EnumTranslationSourceFilter<"Translation"> | $Enums.TranslationSource
    isLegacy?: BoolFilter<"Translation"> | boolean
    aiSuggestion?: StringNullableFilter<"Translation"> | string | null
    aiConfidence?: FloatNullableFilter<"Translation"> | number | null
    approvalCount?: IntFilter<"Translation"> | number
    rejectionCount?: IntFilter<"Translation"> | number
    averageRating?: FloatNullableFilter<"Translation"> | number | null
    syncedToHpo?: BoolFilter<"Translation"> | boolean
    syncedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
    approvedBy?: StringNullableFilter<"Translation"> | string | null
    rejectedBy?: StringNullableFilter<"Translation"> | string | null
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Translation"> | Date | string | null
  }

  export type ValidationUpsertWithWhereUniqueWithoutValidatorInput = {
    where: ValidationWhereUniqueInput
    update: XOR<ValidationUpdateWithoutValidatorInput, ValidationUncheckedUpdateWithoutValidatorInput>
    create: XOR<ValidationCreateWithoutValidatorInput, ValidationUncheckedCreateWithoutValidatorInput>
  }

  export type ValidationUpdateWithWhereUniqueWithoutValidatorInput = {
    where: ValidationWhereUniqueInput
    data: XOR<ValidationUpdateWithoutValidatorInput, ValidationUncheckedUpdateWithoutValidatorInput>
  }

  export type ValidationUpdateManyWithWhereWithoutValidatorInput = {
    where: ValidationScalarWhereInput
    data: XOR<ValidationUpdateManyMutationInput, ValidationUncheckedUpdateManyWithoutValidatorInput>
  }

  export type ValidationScalarWhereInput = {
    AND?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
    OR?: ValidationScalarWhereInput[]
    NOT?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
    id?: StringFilter<"Validation"> | string
    translationId?: StringFilter<"Validation"> | string
    validatorId?: StringFilter<"Validation"> | string
    rating?: IntFilter<"Validation"> | number
    decision?: EnumValidationDecisionFilter<"Validation"> | $Enums.ValidationDecision
    comments?: StringNullableFilter<"Validation"> | string | null
    suggestions?: StringNullableFilter<"Validation"> | string | null
    accuracyScore?: IntNullableFilter<"Validation"> | number | null
    clarityScore?: IntNullableFilter<"Validation"> | number | null
    consistencyScore?: IntNullableFilter<"Validation"> | number | null
    timeSpentSeconds?: IntNullableFilter<"Validation"> | number | null
    createdAt?: DateTimeFilter<"Validation"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    translationId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type UserActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    update: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivityCreateWithoutUserInput, UserActivityUncheckedCreateWithoutUserInput>
  }

  export type UserActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivityWhereUniqueInput
    data: XOR<UserActivityUpdateWithoutUserInput, UserActivityUncheckedUpdateWithoutUserInput>
  }

  export type UserActivityUpdateManyWithWhereWithoutUserInput = {
    where: UserActivityScalarWhereInput
    data: XOR<UserActivityUpdateManyMutationInput, UserActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActivityScalarWhereInput = {
    AND?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    OR?: UserActivityScalarWhereInput[]
    NOT?: UserActivityScalarWhereInput | UserActivityScalarWhereInput[]
    id?: StringFilter<"UserActivity"> | string
    userId?: StringFilter<"UserActivity"> | string
    type?: EnumActivityTypeFilter<"UserActivity"> | $Enums.ActivityType
    points?: IntFilter<"UserActivity"> | number
    metadata?: JsonNullableFilter<"UserActivity">
    createdAt?: DateTimeFilter<"UserActivity"> | Date | string
  }

  export type CommitteeVoteUpsertWithWhereUniqueWithoutVoterInput = {
    where: CommitteeVoteWhereUniqueInput
    update: XOR<CommitteeVoteUpdateWithoutVoterInput, CommitteeVoteUncheckedUpdateWithoutVoterInput>
    create: XOR<CommitteeVoteCreateWithoutVoterInput, CommitteeVoteUncheckedCreateWithoutVoterInput>
  }

  export type CommitteeVoteUpdateWithWhereUniqueWithoutVoterInput = {
    where: CommitteeVoteWhereUniqueInput
    data: XOR<CommitteeVoteUpdateWithoutVoterInput, CommitteeVoteUncheckedUpdateWithoutVoterInput>
  }

  export type CommitteeVoteUpdateManyWithWhereWithoutVoterInput = {
    where: CommitteeVoteScalarWhereInput
    data: XOR<CommitteeVoteUpdateManyMutationInput, CommitteeVoteUncheckedUpdateManyWithoutVoterInput>
  }

  export type CommitteeVoteScalarWhereInput = {
    AND?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
    OR?: CommitteeVoteScalarWhereInput[]
    NOT?: CommitteeVoteScalarWhereInput | CommitteeVoteScalarWhereInput[]
    id?: StringFilter<"CommitteeVote"> | string
    conflictReviewId?: StringFilter<"CommitteeVote"> | string
    voterId?: StringFilter<"CommitteeVote"> | string
    translationId?: StringNullableFilter<"CommitteeVote"> | string | null
    voteType?: EnumVoteTypeFilter<"CommitteeVote"> | $Enums.VoteType
    comment?: StringNullableFilter<"CommitteeVote"> | string | null
    votedAt?: DateTimeFilter<"CommitteeVote"> | Date | string
  }

  export type RejectionUpsertWithWhereUniqueWithoutAdminInput = {
    where: RejectionWhereUniqueInput
    update: XOR<RejectionUpdateWithoutAdminInput, RejectionUncheckedUpdateWithoutAdminInput>
    create: XOR<RejectionCreateWithoutAdminInput, RejectionUncheckedCreateWithoutAdminInput>
  }

  export type RejectionUpdateWithWhereUniqueWithoutAdminInput = {
    where: RejectionWhereUniqueInput
    data: XOR<RejectionUpdateWithoutAdminInput, RejectionUncheckedUpdateWithoutAdminInput>
  }

  export type RejectionUpdateManyWithWhereWithoutAdminInput = {
    where: RejectionScalarWhereInput
    data: XOR<RejectionUpdateManyMutationInput, RejectionUncheckedUpdateManyWithoutAdminInput>
  }

  export type RejectionScalarWhereInput = {
    AND?: RejectionScalarWhereInput | RejectionScalarWhereInput[]
    OR?: RejectionScalarWhereInput[]
    NOT?: RejectionScalarWhereInput | RejectionScalarWhereInput[]
    id?: StringFilter<"Rejection"> | string
    translationId?: StringFilter<"Rejection"> | string
    rejectedBy?: StringFilter<"Rejection"> | string
    reasonCode?: EnumRejectionReasonFilter<"Rejection"> | $Enums.RejectionReason
    detailedReason?: StringFilter<"Rejection"> | string
    suggestions?: StringNullableFilter<"Rejection"> | string | null
    canResubmit?: BoolFilter<"Rejection"> | boolean
    createdAt?: DateTimeFilter<"Rejection"> | Date | string
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: EnumAdminActionFilter<"AdminAuditLog"> | $Enums.AdminAction
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    changes?: JsonNullableFilter<"AdminAuditLog">
    reason?: StringNullableFilter<"AdminAuditLog"> | string | null
    details?: StringNullableFilter<"AdminAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AdminAuditLog"> | string | null
    userAgent?: StringNullableFilter<"AdminAuditLog"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type SyncLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: SyncLogWhereUniqueInput
    update: XOR<SyncLogUpdateWithoutAdminInput, SyncLogUncheckedUpdateWithoutAdminInput>
    create: XOR<SyncLogCreateWithoutAdminInput, SyncLogUncheckedCreateWithoutAdminInput>
  }

  export type SyncLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: SyncLogWhereUniqueInput
    data: XOR<SyncLogUpdateWithoutAdminInput, SyncLogUncheckedUpdateWithoutAdminInput>
  }

  export type SyncLogUpdateManyWithWhereWithoutAdminInput = {
    where: SyncLogScalarWhereInput
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type SyncLogScalarWhereInput = {
    AND?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    OR?: SyncLogScalarWhereInput[]
    NOT?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    syncDate?: DateTimeFilter<"SyncLog"> | Date | string
    initiatedBy?: StringFilter<"SyncLog"> | string
    translationsCount?: IntFilter<"SyncLog"> | number
    babelonFilePath?: StringNullableFilter<"SyncLog"> | string | null
    githubPrUrl?: StringNullableFilter<"SyncLog"> | string | null
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ConflictReviewUpsertWithWhereUniqueWithoutResolverInput = {
    where: ConflictReviewWhereUniqueInput
    update: XOR<ConflictReviewUpdateWithoutResolverInput, ConflictReviewUncheckedUpdateWithoutResolverInput>
    create: XOR<ConflictReviewCreateWithoutResolverInput, ConflictReviewUncheckedCreateWithoutResolverInput>
  }

  export type ConflictReviewUpdateWithWhereUniqueWithoutResolverInput = {
    where: ConflictReviewWhereUniqueInput
    data: XOR<ConflictReviewUpdateWithoutResolverInput, ConflictReviewUncheckedUpdateWithoutResolverInput>
  }

  export type ConflictReviewUpdateManyWithWhereWithoutResolverInput = {
    where: ConflictReviewScalarWhereInput
    data: XOR<ConflictReviewUpdateManyMutationInput, ConflictReviewUncheckedUpdateManyWithoutResolverInput>
  }

  export type ConflictReviewScalarWhereInput = {
    AND?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
    OR?: ConflictReviewScalarWhereInput[]
    NOT?: ConflictReviewScalarWhereInput | ConflictReviewScalarWhereInput[]
    id?: StringFilter<"ConflictReview"> | string
    hpoTermId?: StringFilter<"ConflictReview"> | string
    type?: EnumConflictTypeFilter<"ConflictReview"> | $Enums.ConflictType
    status?: EnumConflictStatusFilter<"ConflictReview"> | $Enums.ConflictStatus
    priority?: EnumPriorityFilter<"ConflictReview"> | $Enums.Priority
    winningTranslationId?: StringNullableFilter<"ConflictReview"> | string | null
    resolution?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedBy?: StringNullableFilter<"ConflictReview"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ConflictReview"> | Date | string | null
    createdAt?: DateTimeFilter<"ConflictReview"> | Date | string
    updatedAt?: DateTimeFilter<"ConflictReview"> | Date | string
  }

  export type StrikeUpsertWithWhereUniqueWithoutUserInput = {
    where: StrikeWhereUniqueInput
    update: XOR<StrikeUpdateWithoutUserInput, StrikeUncheckedUpdateWithoutUserInput>
    create: XOR<StrikeCreateWithoutUserInput, StrikeUncheckedCreateWithoutUserInput>
  }

  export type StrikeUpdateWithWhereUniqueWithoutUserInput = {
    where: StrikeWhereUniqueInput
    data: XOR<StrikeUpdateWithoutUserInput, StrikeUncheckedUpdateWithoutUserInput>
  }

  export type StrikeUpdateManyWithWhereWithoutUserInput = {
    where: StrikeScalarWhereInput
    data: XOR<StrikeUpdateManyMutationInput, StrikeUncheckedUpdateManyWithoutUserInput>
  }

  export type StrikeScalarWhereInput = {
    AND?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
    OR?: StrikeScalarWhereInput[]
    NOT?: StrikeScalarWhereInput | StrikeScalarWhereInput[]
    id?: StringFilter<"Strike"> | string
    userId?: StringFilter<"Strike"> | string
    adminId?: StringFilter<"Strike"> | string
    reason?: EnumStrikeReasonFilter<"Strike"> | $Enums.StrikeReason
    detailedReason?: StringFilter<"Strike"> | string
    translationId?: StringNullableFilter<"Strike"> | string | null
    severity?: IntFilter<"Strike"> | number
    isActive?: BoolFilter<"Strike"> | boolean
    expiresAt?: DateTimeNullableFilter<"Strike"> | Date | string | null
    createdAt?: DateTimeFilter<"Strike"> | Date | string
  }

  export type StrikeUpsertWithWhereUniqueWithoutAdminInput = {
    where: StrikeWhereUniqueInput
    update: XOR<StrikeUpdateWithoutAdminInput, StrikeUncheckedUpdateWithoutAdminInput>
    create: XOR<StrikeCreateWithoutAdminInput, StrikeUncheckedCreateWithoutAdminInput>
  }

  export type StrikeUpdateWithWhereUniqueWithoutAdminInput = {
    where: StrikeWhereUniqueInput
    data: XOR<StrikeUpdateWithoutAdminInput, StrikeUncheckedUpdateWithoutAdminInput>
  }

  export type StrikeUpdateManyWithWhereWithoutAdminInput = {
    where: StrikeScalarWhereInput
    data: XOR<StrikeUpdateManyMutationInput, StrikeUncheckedUpdateManyWithoutAdminInput>
  }

  export type SessionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    update: XOR<SessionLogUpdateWithoutUserInput, SessionLogUncheckedUpdateWithoutUserInput>
    create: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput>
  }

  export type SessionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    data: XOR<SessionLogUpdateWithoutUserInput, SessionLogUncheckedUpdateWithoutUserInput>
  }

  export type SessionLogUpdateManyWithWhereWithoutUserInput = {
    where: SessionLogScalarWhereInput
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionLogScalarWhereInput = {
    AND?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
    OR?: SessionLogScalarWhereInput[]
    NOT?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
    id?: StringFilter<"SessionLog"> | string
    userId?: StringNullableFilter<"SessionLog"> | string | null
    ipAddress?: StringFilter<"SessionLog"> | string
    country?: StringNullableFilter<"SessionLog"> | string | null
    city?: StringNullableFilter<"SessionLog"> | string | null
    region?: StringNullableFilter<"SessionLog"> | string | null
    latitude?: FloatNullableFilter<"SessionLog"> | number | null
    longitude?: FloatNullableFilter<"SessionLog"> | number | null
    userAgent?: StringFilter<"SessionLog"> | string
    browser?: StringNullableFilter<"SessionLog"> | string | null
    browserVersion?: StringNullableFilter<"SessionLog"> | string | null
    os?: StringNullableFilter<"SessionLog"> | string | null
    osVersion?: StringNullableFilter<"SessionLog"> | string | null
    device?: StringNullableFilter<"SessionLog"> | string | null
    isMobile?: BoolFilter<"SessionLog"> | boolean
    sessionStart?: DateTimeFilter<"SessionLog"> | Date | string
    sessionEnd?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    duration?: IntNullableFilter<"SessionLog"> | number | null
    pagesVisited?: StringNullableListFilter<"SessionLog">
    actionsCount?: IntFilter<"SessionLog"> | number
    avgResponseTime?: FloatNullableFilter<"SessionLog"> | number | null
    createdAt?: DateTimeFilter<"SessionLog"> | Date | string
    updatedAt?: DateTimeFilter<"SessionLog"> | Date | string
  }

  export type UserAnalyticsUpsertWithoutUserInput = {
    update: XOR<UserAnalyticsUpdateWithoutUserInput, UserAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<UserAnalyticsCreateWithoutUserInput, UserAnalyticsUncheckedCreateWithoutUserInput>
    where?: UserAnalyticsWhereInput
  }

  export type UserAnalyticsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAnalyticsWhereInput
    data: XOR<UserAnalyticsUpdateWithoutUserInput, UserAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type UserAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationsToday?: IntFieldUpdateOperationsInput | number
    validationsToday?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    lastActivityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalSessions?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredHours?: UserAnalyticsUpdatepreferredHoursInput | number[]
    preferredDays?: UserAnalyticsUpdatepreferredDaysInput | number[]
    mostUsedFeatures?: UserAnalyticsUpdatemostUsedFeaturesInput | string[]
    avgTranslationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    avgValidationTime?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgConfidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateWithoutTermInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutTermInput = {
    id?: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutTermInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput>
  }

  export type TranslationCreateManyTermInputEnvelope = {
    data: TranslationCreateManyTermInput | TranslationCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type HpoTermCreateWithoutChildrenInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutTermInput
    parent?: HpoTermCreateNestedOneWithoutChildrenInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermUncheckedCreateWithoutChildrenInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    parentId?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutTermInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermCreateOrConnectWithoutChildrenInput = {
    where: HpoTermWhereUniqueInput
    create: XOR<HpoTermCreateWithoutChildrenInput, HpoTermUncheckedCreateWithoutChildrenInput>
  }

  export type HpoTermCreateWithoutParentInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutTermInput
    children?: HpoTermCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermUncheckedCreateWithoutParentInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutTermInput
    children?: HpoTermUncheckedCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermCreateOrConnectWithoutParentInput = {
    where: HpoTermWhereUniqueInput
    create: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput>
  }

  export type HpoTermCreateManyParentInputEnvelope = {
    data: HpoTermCreateManyParentInput | HpoTermCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ConflictReviewCreateWithoutHpoTermInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutConflictReviewInput
    resolver?: UserCreateNestedOneWithoutConflictsResolvedInput
  }

  export type ConflictReviewUncheckedCreateWithoutHpoTermInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutConflictReviewInput
  }

  export type ConflictReviewCreateOrConnectWithoutHpoTermInput = {
    where: ConflictReviewWhereUniqueInput
    create: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput>
  }

  export type ConflictReviewCreateManyHpoTermInputEnvelope = {
    data: ConflictReviewCreateManyHpoTermInput | ConflictReviewCreateManyHpoTermInput[]
    skipDuplicates?: boolean
  }

  export type TranslationUpsertWithWhereUniqueWithoutTermInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutTermInput, TranslationUncheckedUpdateWithoutTermInput>
    create: XOR<TranslationCreateWithoutTermInput, TranslationUncheckedCreateWithoutTermInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutTermInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutTermInput, TranslationUncheckedUpdateWithoutTermInput>
  }

  export type TranslationUpdateManyWithWhereWithoutTermInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutTermInput>
  }

  export type HpoTermUpsertWithoutChildrenInput = {
    update: XOR<HpoTermUpdateWithoutChildrenInput, HpoTermUncheckedUpdateWithoutChildrenInput>
    create: XOR<HpoTermCreateWithoutChildrenInput, HpoTermUncheckedCreateWithoutChildrenInput>
    where?: HpoTermWhereInput
  }

  export type HpoTermUpdateToOneWithWhereWithoutChildrenInput = {
    where?: HpoTermWhereInput
    data: XOR<HpoTermUpdateWithoutChildrenInput, HpoTermUncheckedUpdateWithoutChildrenInput>
  }

  export type HpoTermUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutTermNestedInput
    parent?: HpoTermUpdateOneWithoutChildrenNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutTermNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUpsertWithWhereUniqueWithoutParentInput = {
    where: HpoTermWhereUniqueInput
    update: XOR<HpoTermUpdateWithoutParentInput, HpoTermUncheckedUpdateWithoutParentInput>
    create: XOR<HpoTermCreateWithoutParentInput, HpoTermUncheckedCreateWithoutParentInput>
  }

  export type HpoTermUpdateWithWhereUniqueWithoutParentInput = {
    where: HpoTermWhereUniqueInput
    data: XOR<HpoTermUpdateWithoutParentInput, HpoTermUncheckedUpdateWithoutParentInput>
  }

  export type HpoTermUpdateManyWithWhereWithoutParentInput = {
    where: HpoTermScalarWhereInput
    data: XOR<HpoTermUpdateManyMutationInput, HpoTermUncheckedUpdateManyWithoutParentInput>
  }

  export type HpoTermScalarWhereInput = {
    AND?: HpoTermScalarWhereInput | HpoTermScalarWhereInput[]
    OR?: HpoTermScalarWhereInput[]
    NOT?: HpoTermScalarWhereInput | HpoTermScalarWhereInput[]
    id?: StringFilter<"HpoTerm"> | string
    hpoId?: StringFilter<"HpoTerm"> | string
    labelEn?: StringFilter<"HpoTerm"> | string
    definitionEn?: StringNullableFilter<"HpoTerm"> | string | null
    synonymsEn?: StringNullableListFilter<"HpoTerm">
    category?: StringNullableFilter<"HpoTerm"> | string | null
    parentId?: StringNullableFilter<"HpoTerm"> | string | null
    difficulty?: IntFilter<"HpoTerm"> | number
    translationStatus?: EnumTranslationStatusFilter<"HpoTerm"> | $Enums.TranslationStatus
    hpoVersion?: StringNullableFilter<"HpoTerm"> | string | null
    isObsolete?: BoolFilter<"HpoTerm"> | boolean
    createdAt?: DateTimeFilter<"HpoTerm"> | Date | string
    updatedAt?: DateTimeFilter<"HpoTerm"> | Date | string
  }

  export type ConflictReviewUpsertWithWhereUniqueWithoutHpoTermInput = {
    where: ConflictReviewWhereUniqueInput
    update: XOR<ConflictReviewUpdateWithoutHpoTermInput, ConflictReviewUncheckedUpdateWithoutHpoTermInput>
    create: XOR<ConflictReviewCreateWithoutHpoTermInput, ConflictReviewUncheckedCreateWithoutHpoTermInput>
  }

  export type ConflictReviewUpdateWithWhereUniqueWithoutHpoTermInput = {
    where: ConflictReviewWhereUniqueInput
    data: XOR<ConflictReviewUpdateWithoutHpoTermInput, ConflictReviewUncheckedUpdateWithoutHpoTermInput>
  }

  export type ConflictReviewUpdateManyWithWhereWithoutHpoTermInput = {
    where: ConflictReviewScalarWhereInput
    data: XOR<ConflictReviewUpdateManyMutationInput, ConflictReviewUncheckedUpdateManyWithoutHpoTermInput>
  }

  export type HpoTermCreateWithoutTranslationsInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: HpoTermCreateNestedOneWithoutChildrenInput
    children?: HpoTermCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermUncheckedCreateWithoutTranslationsInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    parentId?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: HpoTermUncheckedCreateNestedManyWithoutParentInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutHpoTermInput
  }

  export type HpoTermCreateOrConnectWithoutTranslationsInput = {
    where: HpoTermWhereUniqueInput
    create: XOR<HpoTermCreateWithoutTranslationsInput, HpoTermUncheckedCreateWithoutTranslationsInput>
  }

  export type UserCreateWithoutTranslationsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTranslationsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTranslationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTranslationsInput, UserUncheckedCreateWithoutTranslationsInput>
  }

  export type ValidationCreateWithoutTranslationInput = {
    id?: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
    validator: UserCreateNestedOneWithoutValidationsInput
  }

  export type ValidationUncheckedCreateWithoutTranslationInput = {
    id?: string
    validatorId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type ValidationCreateOrConnectWithoutTranslationInput = {
    where: ValidationWhereUniqueInput
    create: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput>
  }

  export type ValidationCreateManyTranslationInputEnvelope = {
    data: ValidationCreateManyTranslationInput | ValidationCreateManyTranslationInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTranslationInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutTranslationInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutTranslationInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput>
  }

  export type CommentCreateManyTranslationInputEnvelope = {
    data: CommentCreateManyTranslationInput | CommentCreateManyTranslationInput[]
    skipDuplicates?: boolean
  }

  export type StrikeCreateWithoutTranslationInput = {
    id?: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStrikesInput
    admin: UserCreateNestedOneWithoutStrikesGivenInput
  }

  export type StrikeUncheckedCreateWithoutTranslationInput = {
    id?: string
    userId: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeCreateOrConnectWithoutTranslationInput = {
    where: StrikeWhereUniqueInput
    create: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput>
  }

  export type StrikeCreateManyTranslationInputEnvelope = {
    data: StrikeCreateManyTranslationInput | StrikeCreateManyTranslationInput[]
    skipDuplicates?: boolean
  }

  export type RejectionCreateWithoutTranslationInput = {
    id?: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutRejectionsMadeInput
  }

  export type RejectionUncheckedCreateWithoutTranslationInput = {
    id?: string
    rejectedBy: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
  }

  export type RejectionCreateOrConnectWithoutTranslationInput = {
    where: RejectionWhereUniqueInput
    create: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
  }

  export type ConflictReviewCreateWithoutTranslationsInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hpoTerm: HpoTermCreateNestedOneWithoutConflictReviewsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutConflictReviewInput
    resolver?: UserCreateNestedOneWithoutConflictsResolvedInput
  }

  export type ConflictReviewUncheckedCreateWithoutTranslationsInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutConflictReviewInput
  }

  export type ConflictReviewCreateOrConnectWithoutTranslationsInput = {
    where: ConflictReviewWhereUniqueInput
    create: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput>
  }

  export type CommitteeVoteCreateWithoutTranslationInput = {
    id?: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
    conflictReview: ConflictReviewCreateNestedOneWithoutCommitteeVotesInput
    voter: UserCreateNestedOneWithoutConflictVotesInput
  }

  export type CommitteeVoteUncheckedCreateWithoutTranslationInput = {
    id?: string
    conflictReviewId: string
    voterId: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type CommitteeVoteCreateOrConnectWithoutTranslationInput = {
    where: CommitteeVoteWhereUniqueInput
    create: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput>
  }

  export type CommitteeVoteCreateManyTranslationInputEnvelope = {
    data: CommitteeVoteCreateManyTranslationInput | CommitteeVoteCreateManyTranslationInput[]
    skipDuplicates?: boolean
  }

  export type HpoTermUpsertWithoutTranslationsInput = {
    update: XOR<HpoTermUpdateWithoutTranslationsInput, HpoTermUncheckedUpdateWithoutTranslationsInput>
    create: XOR<HpoTermCreateWithoutTranslationsInput, HpoTermUncheckedCreateWithoutTranslationsInput>
    where?: HpoTermWhereInput
  }

  export type HpoTermUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: HpoTermWhereInput
    data: XOR<HpoTermUpdateWithoutTranslationsInput, HpoTermUncheckedUpdateWithoutTranslationsInput>
  }

  export type HpoTermUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: HpoTermUpdateOneWithoutChildrenNestedInput
    children?: HpoTermUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: HpoTermUncheckedUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutHpoTermNestedInput
  }

  export type UserUpsertWithoutTranslationsInput = {
    update: XOR<UserUpdateWithoutTranslationsInput, UserUncheckedUpdateWithoutTranslationsInput>
    create: XOR<UserCreateWithoutTranslationsInput, UserUncheckedCreateWithoutTranslationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTranslationsInput, UserUncheckedUpdateWithoutTranslationsInput>
  }

  export type UserUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ValidationUpsertWithWhereUniqueWithoutTranslationInput = {
    where: ValidationWhereUniqueInput
    update: XOR<ValidationUpdateWithoutTranslationInput, ValidationUncheckedUpdateWithoutTranslationInput>
    create: XOR<ValidationCreateWithoutTranslationInput, ValidationUncheckedCreateWithoutTranslationInput>
  }

  export type ValidationUpdateWithWhereUniqueWithoutTranslationInput = {
    where: ValidationWhereUniqueInput
    data: XOR<ValidationUpdateWithoutTranslationInput, ValidationUncheckedUpdateWithoutTranslationInput>
  }

  export type ValidationUpdateManyWithWhereWithoutTranslationInput = {
    where: ValidationScalarWhereInput
    data: XOR<ValidationUpdateManyMutationInput, ValidationUncheckedUpdateManyWithoutTranslationInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTranslationInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTranslationInput, CommentUncheckedUpdateWithoutTranslationInput>
    create: XOR<CommentCreateWithoutTranslationInput, CommentUncheckedCreateWithoutTranslationInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTranslationInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTranslationInput, CommentUncheckedUpdateWithoutTranslationInput>
  }

  export type CommentUpdateManyWithWhereWithoutTranslationInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTranslationInput>
  }

  export type StrikeUpsertWithWhereUniqueWithoutTranslationInput = {
    where: StrikeWhereUniqueInput
    update: XOR<StrikeUpdateWithoutTranslationInput, StrikeUncheckedUpdateWithoutTranslationInput>
    create: XOR<StrikeCreateWithoutTranslationInput, StrikeUncheckedCreateWithoutTranslationInput>
  }

  export type StrikeUpdateWithWhereUniqueWithoutTranslationInput = {
    where: StrikeWhereUniqueInput
    data: XOR<StrikeUpdateWithoutTranslationInput, StrikeUncheckedUpdateWithoutTranslationInput>
  }

  export type StrikeUpdateManyWithWhereWithoutTranslationInput = {
    where: StrikeScalarWhereInput
    data: XOR<StrikeUpdateManyMutationInput, StrikeUncheckedUpdateManyWithoutTranslationInput>
  }

  export type RejectionUpsertWithoutTranslationInput = {
    update: XOR<RejectionUpdateWithoutTranslationInput, RejectionUncheckedUpdateWithoutTranslationInput>
    create: XOR<RejectionCreateWithoutTranslationInput, RejectionUncheckedCreateWithoutTranslationInput>
    where?: RejectionWhereInput
  }

  export type RejectionUpdateToOneWithWhereWithoutTranslationInput = {
    where?: RejectionWhereInput
    data: XOR<RejectionUpdateWithoutTranslationInput, RejectionUncheckedUpdateWithoutTranslationInput>
  }

  export type RejectionUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutRejectionsMadeNestedInput
  }

  export type RejectionUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectedBy?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewUpsertWithWhereUniqueWithoutTranslationsInput = {
    where: ConflictReviewWhereUniqueInput
    update: XOR<ConflictReviewUpdateWithoutTranslationsInput, ConflictReviewUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ConflictReviewCreateWithoutTranslationsInput, ConflictReviewUncheckedCreateWithoutTranslationsInput>
  }

  export type ConflictReviewUpdateWithWhereUniqueWithoutTranslationsInput = {
    where: ConflictReviewWhereUniqueInput
    data: XOR<ConflictReviewUpdateWithoutTranslationsInput, ConflictReviewUncheckedUpdateWithoutTranslationsInput>
  }

  export type ConflictReviewUpdateManyWithWhereWithoutTranslationsInput = {
    where: ConflictReviewScalarWhereInput
    data: XOR<ConflictReviewUpdateManyMutationInput, ConflictReviewUncheckedUpdateManyWithoutTranslationsInput>
  }

  export type CommitteeVoteUpsertWithWhereUniqueWithoutTranslationInput = {
    where: CommitteeVoteWhereUniqueInput
    update: XOR<CommitteeVoteUpdateWithoutTranslationInput, CommitteeVoteUncheckedUpdateWithoutTranslationInput>
    create: XOR<CommitteeVoteCreateWithoutTranslationInput, CommitteeVoteUncheckedCreateWithoutTranslationInput>
  }

  export type CommitteeVoteUpdateWithWhereUniqueWithoutTranslationInput = {
    where: CommitteeVoteWhereUniqueInput
    data: XOR<CommitteeVoteUpdateWithoutTranslationInput, CommitteeVoteUncheckedUpdateWithoutTranslationInput>
  }

  export type CommitteeVoteUpdateManyWithWhereWithoutTranslationInput = {
    where: CommitteeVoteScalarWhereInput
    data: XOR<CommitteeVoteUpdateManyMutationInput, CommitteeVoteUncheckedUpdateManyWithoutTranslationInput>
  }

  export type TranslationCreateWithoutValidationsInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutValidationsInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutValidationsInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutValidationsInput, TranslationUncheckedCreateWithoutValidationsInput>
  }

  export type UserCreateWithoutValidationsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutValidationsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutValidationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidationsInput, UserUncheckedCreateWithoutValidationsInput>
  }

  export type TranslationUpsertWithoutValidationsInput = {
    update: XOR<TranslationUpdateWithoutValidationsInput, TranslationUncheckedUpdateWithoutValidationsInput>
    create: XOR<TranslationCreateWithoutValidationsInput, TranslationUncheckedCreateWithoutValidationsInput>
    where?: TranslationWhereInput
  }

  export type TranslationUpdateToOneWithWhereWithoutValidationsInput = {
    where?: TranslationWhereInput
    data: XOR<TranslationUpdateWithoutValidationsInput, TranslationUncheckedUpdateWithoutValidationsInput>
  }

  export type TranslationUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type UserUpsertWithoutValidationsInput = {
    update: XOR<UserUpdateWithoutValidationsInput, UserUncheckedUpdateWithoutValidationsInput>
    create: XOR<UserCreateWithoutValidationsInput, UserUncheckedCreateWithoutValidationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidationsInput, UserUncheckedUpdateWithoutValidationsInput>
  }

  export type UserUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TranslationCreateWithoutCommentsInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutCommentsInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutCommentsInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutCommentsInput, TranslationUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translation: TranslationCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    translationId: string
    userId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    translation: TranslationCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    translationId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TranslationUpsertWithoutCommentsInput = {
    update: XOR<TranslationUpdateWithoutCommentsInput, TranslationUncheckedUpdateWithoutCommentsInput>
    create: XOR<TranslationCreateWithoutCommentsInput, TranslationUncheckedCreateWithoutCommentsInput>
    where?: TranslationWhereInput
  }

  export type TranslationUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TranslationWhereInput
    data: XOR<TranslationUpdateWithoutCommentsInput, TranslationUncheckedUpdateWithoutCommentsInput>
  }

  export type TranslationUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    description: string
    iconUrl?: string | null
    points?: number
    rarity?: $Enums.BadgeRarity
    createdAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    description: string
    iconUrl?: string | null
    points?: number
    rarity?: $Enums.BadgeRarity
    createdAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    rarity?: EnumBadgeRarityFieldUpdateOperationsInput | $Enums.BadgeRarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type HpoTermCreateWithoutConflictReviewsInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutTermInput
    parent?: HpoTermCreateNestedOneWithoutChildrenInput
    children?: HpoTermCreateNestedManyWithoutParentInput
  }

  export type HpoTermUncheckedCreateWithoutConflictReviewsInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    parentId?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutTermInput
    children?: HpoTermUncheckedCreateNestedManyWithoutParentInput
  }

  export type HpoTermCreateOrConnectWithoutConflictReviewsInput = {
    where: HpoTermWhereUniqueInput
    create: XOR<HpoTermCreateWithoutConflictReviewsInput, HpoTermUncheckedCreateWithoutConflictReviewsInput>
  }

  export type TranslationCreateWithoutConflictReviewsInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutConflictReviewsInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutConflictReviewsInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput>
  }

  export type CommitteeVoteCreateWithoutConflictReviewInput = {
    id?: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
    voter: UserCreateNestedOneWithoutConflictVotesInput
    translation?: TranslationCreateNestedOneWithoutCommitteeVotesInput
  }

  export type CommitteeVoteUncheckedCreateWithoutConflictReviewInput = {
    id?: string
    voterId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type CommitteeVoteCreateOrConnectWithoutConflictReviewInput = {
    where: CommitteeVoteWhereUniqueInput
    create: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput>
  }

  export type CommitteeVoteCreateManyConflictReviewInputEnvelope = {
    data: CommitteeVoteCreateManyConflictReviewInput | CommitteeVoteCreateManyConflictReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutConflictsResolvedInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConflictsResolvedInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConflictsResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConflictsResolvedInput, UserUncheckedCreateWithoutConflictsResolvedInput>
  }

  export type HpoTermUpsertWithoutConflictReviewsInput = {
    update: XOR<HpoTermUpdateWithoutConflictReviewsInput, HpoTermUncheckedUpdateWithoutConflictReviewsInput>
    create: XOR<HpoTermCreateWithoutConflictReviewsInput, HpoTermUncheckedCreateWithoutConflictReviewsInput>
    where?: HpoTermWhereInput
  }

  export type HpoTermUpdateToOneWithWhereWithoutConflictReviewsInput = {
    where?: HpoTermWhereInput
    data: XOR<HpoTermUpdateWithoutConflictReviewsInput, HpoTermUncheckedUpdateWithoutConflictReviewsInput>
  }

  export type HpoTermUpdateWithoutConflictReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutTermNestedInput
    parent?: HpoTermUpdateOneWithoutChildrenNestedInput
    children?: HpoTermUpdateManyWithoutParentNestedInput
  }

  export type HpoTermUncheckedUpdateWithoutConflictReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutTermNestedInput
    children?: HpoTermUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TranslationUpsertWithWhereUniqueWithoutConflictReviewsInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutConflictReviewsInput, TranslationUncheckedUpdateWithoutConflictReviewsInput>
    create: XOR<TranslationCreateWithoutConflictReviewsInput, TranslationUncheckedCreateWithoutConflictReviewsInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutConflictReviewsInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutConflictReviewsInput, TranslationUncheckedUpdateWithoutConflictReviewsInput>
  }

  export type TranslationUpdateManyWithWhereWithoutConflictReviewsInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutConflictReviewsInput>
  }

  export type CommitteeVoteUpsertWithWhereUniqueWithoutConflictReviewInput = {
    where: CommitteeVoteWhereUniqueInput
    update: XOR<CommitteeVoteUpdateWithoutConflictReviewInput, CommitteeVoteUncheckedUpdateWithoutConflictReviewInput>
    create: XOR<CommitteeVoteCreateWithoutConflictReviewInput, CommitteeVoteUncheckedCreateWithoutConflictReviewInput>
  }

  export type CommitteeVoteUpdateWithWhereUniqueWithoutConflictReviewInput = {
    where: CommitteeVoteWhereUniqueInput
    data: XOR<CommitteeVoteUpdateWithoutConflictReviewInput, CommitteeVoteUncheckedUpdateWithoutConflictReviewInput>
  }

  export type CommitteeVoteUpdateManyWithWhereWithoutConflictReviewInput = {
    where: CommitteeVoteScalarWhereInput
    data: XOR<CommitteeVoteUpdateManyMutationInput, CommitteeVoteUncheckedUpdateManyWithoutConflictReviewInput>
  }

  export type UserUpsertWithoutConflictsResolvedInput = {
    update: XOR<UserUpdateWithoutConflictsResolvedInput, UserUncheckedUpdateWithoutConflictsResolvedInput>
    create: XOR<UserCreateWithoutConflictsResolvedInput, UserUncheckedCreateWithoutConflictsResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConflictsResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConflictsResolvedInput, UserUncheckedUpdateWithoutConflictsResolvedInput>
  }

  export type UserUpdateWithoutConflictsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConflictsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConflictReviewCreateWithoutCommitteeVotesInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hpoTerm: HpoTermCreateNestedOneWithoutConflictReviewsInput
    translations?: TranslationCreateNestedManyWithoutConflictReviewsInput
    resolver?: UserCreateNestedOneWithoutConflictsResolvedInput
  }

  export type ConflictReviewUncheckedCreateWithoutCommitteeVotesInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutConflictReviewsInput
  }

  export type ConflictReviewCreateOrConnectWithoutCommitteeVotesInput = {
    where: ConflictReviewWhereUniqueInput
    create: XOR<ConflictReviewCreateWithoutCommitteeVotesInput, ConflictReviewUncheckedCreateWithoutCommitteeVotesInput>
  }

  export type UserCreateWithoutConflictVotesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConflictVotesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConflictVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConflictVotesInput, UserUncheckedCreateWithoutConflictVotesInput>
  }

  export type TranslationCreateWithoutCommitteeVotesInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
  }

  export type TranslationUncheckedCreateWithoutCommitteeVotesInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
  }

  export type TranslationCreateOrConnectWithoutCommitteeVotesInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutCommitteeVotesInput, TranslationUncheckedCreateWithoutCommitteeVotesInput>
  }

  export type ConflictReviewUpsertWithoutCommitteeVotesInput = {
    update: XOR<ConflictReviewUpdateWithoutCommitteeVotesInput, ConflictReviewUncheckedUpdateWithoutCommitteeVotesInput>
    create: XOR<ConflictReviewCreateWithoutCommitteeVotesInput, ConflictReviewUncheckedCreateWithoutCommitteeVotesInput>
    where?: ConflictReviewWhereInput
  }

  export type ConflictReviewUpdateToOneWithWhereWithoutCommitteeVotesInput = {
    where?: ConflictReviewWhereInput
    data: XOR<ConflictReviewUpdateWithoutCommitteeVotesInput, ConflictReviewUncheckedUpdateWithoutCommitteeVotesInput>
  }

  export type ConflictReviewUpdateWithoutCommitteeVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hpoTerm?: HpoTermUpdateOneRequiredWithoutConflictReviewsNestedInput
    translations?: TranslationUpdateManyWithoutConflictReviewsNestedInput
    resolver?: UserUpdateOneWithoutConflictsResolvedNestedInput
  }

  export type ConflictReviewUncheckedUpdateWithoutCommitteeVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutConflictReviewsNestedInput
  }

  export type UserUpsertWithoutConflictVotesInput = {
    update: XOR<UserUpdateWithoutConflictVotesInput, UserUncheckedUpdateWithoutConflictVotesInput>
    create: XOR<UserCreateWithoutConflictVotesInput, UserUncheckedCreateWithoutConflictVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConflictVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConflictVotesInput, UserUncheckedUpdateWithoutConflictVotesInput>
  }

  export type UserUpdateWithoutConflictVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConflictVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TranslationUpsertWithoutCommitteeVotesInput = {
    update: XOR<TranslationUpdateWithoutCommitteeVotesInput, TranslationUncheckedUpdateWithoutCommitteeVotesInput>
    create: XOR<TranslationCreateWithoutCommitteeVotesInput, TranslationUncheckedCreateWithoutCommitteeVotesInput>
    where?: TranslationWhereInput
  }

  export type TranslationUpdateToOneWithWhereWithoutCommitteeVotesInput = {
    where?: TranslationWhereInput
    data: XOR<TranslationUpdateWithoutCommitteeVotesInput, TranslationUncheckedUpdateWithoutCommitteeVotesInput>
  }

  export type TranslationUpdateWithoutCommitteeVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
  }

  export type TranslationUncheckedUpdateWithoutCommitteeVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
  }

  export type TranslationCreateWithoutRejectionInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    strikes?: StrikeCreateNestedManyWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutRejectionInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutRejectionInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutRejectionInput, TranslationUncheckedCreateWithoutRejectionInput>
  }

  export type UserCreateWithoutRejectionsMadeInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRejectionsMadeInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRejectionsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRejectionsMadeInput, UserUncheckedCreateWithoutRejectionsMadeInput>
  }

  export type TranslationUpsertWithoutRejectionInput = {
    update: XOR<TranslationUpdateWithoutRejectionInput, TranslationUncheckedUpdateWithoutRejectionInput>
    create: XOR<TranslationCreateWithoutRejectionInput, TranslationUncheckedCreateWithoutRejectionInput>
    where?: TranslationWhereInput
  }

  export type TranslationUpdateToOneWithWhereWithoutRejectionInput = {
    where?: TranslationWhereInput
    data: XOR<TranslationUpdateWithoutRejectionInput, TranslationUncheckedUpdateWithoutRejectionInput>
  }

  export type TranslationUpdateWithoutRejectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutRejectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type UserUpsertWithoutRejectionsMadeInput = {
    update: XOR<UserUpdateWithoutRejectionsMadeInput, UserUncheckedUpdateWithoutRejectionsMadeInput>
    create: XOR<UserCreateWithoutRejectionsMadeInput, UserUncheckedCreateWithoutRejectionsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRejectionsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRejectionsMadeInput, UserUncheckedUpdateWithoutRejectionsMadeInput>
  }

  export type UserUpdateWithoutRejectionsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRejectionsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSyncLogsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSyncLogsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSyncLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSyncLogsInput, UserUncheckedCreateWithoutSyncLogsInput>
  }

  export type UserUpsertWithoutSyncLogsInput = {
    update: XOR<UserUpdateWithoutSyncLogsInput, UserUncheckedUpdateWithoutSyncLogsInput>
    create: XOR<UserCreateWithoutSyncLogsInput, UserUncheckedCreateWithoutSyncLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSyncLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSyncLogsInput, UserUncheckedUpdateWithoutSyncLogsInput>
  }

  export type UserUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsSentInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsSentInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
  }

  export type UserUpsertWithoutNotificationsSentInput = {
    update: XOR<UserUpdateWithoutNotificationsSentInput, UserUncheckedUpdateWithoutNotificationsSentInput>
    create: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsSentInput, UserUncheckedUpdateWithoutNotificationsSentInput>
  }

  export type UserUpdateWithoutNotificationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutStrikesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStrikesInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStrikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStrikesInput, UserUncheckedCreateWithoutStrikesInput>
  }

  export type UserCreateWithoutStrikesGivenInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStrikesGivenInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStrikesGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStrikesGivenInput, UserUncheckedCreateWithoutStrikesGivenInput>
  }

  export type TranslationCreateWithoutStrikesInput = {
    id?: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    term: HpoTermCreateNestedOneWithoutTranslationsInput
    user: UserCreateNestedOneWithoutTranslationsInput
    validations?: ValidationCreateNestedManyWithoutTranslationInput
    comments?: CommentCreateNestedManyWithoutTranslationInput
    rejection?: RejectionCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteCreateNestedManyWithoutTranslationInput
  }

  export type TranslationUncheckedCreateWithoutStrikesInput = {
    id?: string
    termId: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
    validations?: ValidationUncheckedCreateNestedManyWithoutTranslationInput
    comments?: CommentUncheckedCreateNestedManyWithoutTranslationInput
    rejection?: RejectionUncheckedCreateNestedOneWithoutTranslationInput
    conflictReviews?: ConflictReviewUncheckedCreateNestedManyWithoutTranslationsInput
    committeeVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutTranslationInput
  }

  export type TranslationCreateOrConnectWithoutStrikesInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutStrikesInput, TranslationUncheckedCreateWithoutStrikesInput>
  }

  export type UserUpsertWithoutStrikesInput = {
    update: XOR<UserUpdateWithoutStrikesInput, UserUncheckedUpdateWithoutStrikesInput>
    create: XOR<UserCreateWithoutStrikesInput, UserUncheckedCreateWithoutStrikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStrikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStrikesInput, UserUncheckedUpdateWithoutStrikesInput>
  }

  export type UserUpdateWithoutStrikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStrikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutStrikesGivenInput = {
    update: XOR<UserUpdateWithoutStrikesGivenInput, UserUncheckedUpdateWithoutStrikesGivenInput>
    create: XOR<UserCreateWithoutStrikesGivenInput, UserUncheckedCreateWithoutStrikesGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStrikesGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStrikesGivenInput, UserUncheckedUpdateWithoutStrikesGivenInput>
  }

  export type UserUpdateWithoutStrikesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStrikesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TranslationUpsertWithoutStrikesInput = {
    update: XOR<TranslationUpdateWithoutStrikesInput, TranslationUncheckedUpdateWithoutStrikesInput>
    create: XOR<TranslationCreateWithoutStrikesInput, TranslationUncheckedCreateWithoutStrikesInput>
    where?: TranslationWhereInput
  }

  export type TranslationUpdateToOneWithWhereWithoutStrikesInput = {
    where?: TranslationWhereInput
    data: XOR<TranslationUpdateWithoutStrikesInput, TranslationUncheckedUpdateWithoutStrikesInput>
  }

  export type TranslationUpdateWithoutStrikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutStrikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    analytics?: UserAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    analytics?: UserAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    analytics?: UserAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    analytics?: UserAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutUserInput
    validations?: ValidationCreateNestedManyWithoutValidatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    activities?: UserActivityCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewCreateNestedManyWithoutResolverInput
    strikes?: StrikeCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeCreateNestedManyWithoutAdminInput
    sessions?: SessionLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    name: string
    username?: string | null
    password?: string | null
    orcidId?: string | null
    role?: $Enums.UserRole
    institution?: string | null
    specialty?: string | null
    country?: string | null
    bio?: string | null
    avatarUrl?: string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: number
    level?: number
    streak?: number
    lastActiveAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedCount?: number
    hasCompletedOnboarding?: boolean
    warningCount?: number
    lastWarningAt?: Date | string | null
    bannedBy?: string | null
    promotedAt?: Date | string | null
    isActive?: boolean
    isBanned?: boolean
    bannedAt?: Date | string | null
    bannedReason?: string | null
    isVerified?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutUserInput
    validations?: ValidationUncheckedCreateNestedManyWithoutValidatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    activities?: UserActivityUncheckedCreateNestedManyWithoutUserInput
    conflictVotes?: CommitteeVoteUncheckedCreateNestedManyWithoutVoterInput
    rejectionsMade?: RejectionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutAdminInput
    notificationsSent?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conflictsResolved?: ConflictReviewUncheckedCreateNestedManyWithoutResolverInput
    strikes?: StrikeUncheckedCreateNestedManyWithoutUserInput
    strikesGiven?: StrikeUncheckedCreateNestedManyWithoutAdminInput
    sessions?: SessionLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
  }

  export type UserUpsertWithoutAnalyticsInput = {
    update: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutUserNestedInput
    validations?: ValidationUpdateManyWithoutValidatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    activities?: UserActivityUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    orcidId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profileJson?: NullableJsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedCount?: IntFieldUpdateOperationsInput | number
    hasCompletedOnboarding?: BoolFieldUpdateOperationsInput | boolean
    warningCount?: IntFieldUpdateOperationsInput | number
    lastWarningAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedBy?: NullableStringFieldUpdateOperationsInput | string | null
    promotedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannedReason?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutUserNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutValidatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    activities?: UserActivityUncheckedUpdateManyWithoutUserNestedInput
    conflictVotes?: CommitteeVoteUncheckedUpdateManyWithoutVoterNestedInput
    rejectionsMade?: RejectionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutAdminNestedInput
    notificationsSent?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conflictsResolved?: ConflictReviewUncheckedUpdateManyWithoutResolverNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutUserNestedInput
    strikesGiven?: StrikeUncheckedUpdateManyWithoutAdminNestedInput
    sessions?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TranslationCreateManyUserInput = {
    id?: string
    termId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ValidationCreateManyValidatorInput = {
    id?: string
    translationId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    translationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserActivityCreateManyUserInput = {
    id?: string
    type: $Enums.ActivityType
    points?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CommitteeVoteCreateManyVoterInput = {
    id?: string
    conflictReviewId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type RejectionCreateManyAdminInput = {
    id?: string
    translationId: string
    reasonCode: $Enums.RejectionReason
    detailedReason: string
    suggestions?: string | null
    canResubmit?: boolean
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: $Enums.AdminAction
    targetType: string
    targetId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SyncLogCreateManyAdminInput = {
    id?: string
    syncDate?: Date | string
    translationsCount: number
    babelonFilePath?: string | null
    githubPrUrl?: string | null
    status: $Enums.SyncStatus
    errorMessage?: string | null
    completedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    link?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type ConflictReviewCreateManyResolverInput = {
    id?: string
    hpoTermId: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrikeCreateManyUserInput = {
    id?: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StrikeCreateManyAdminInput = {
    id?: string
    userId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    translationId?: string | null
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionLogCreateManyUserInput = {
    id?: string
    ipAddress: string
    country?: string | null
    city?: string | null
    region?: string | null
    latitude?: number | null
    longitude?: number | null
    userAgent: string
    browser?: string | null
    browserVersion?: string | null
    os?: string | null
    osVersion?: string | null
    device?: string | null
    isMobile?: boolean
    sessionStart?: Date | string
    sessionEnd?: Date | string | null
    duration?: number | null
    pagesVisited?: SessionLogCreatepagesVisitedInput | string[]
    actionsCount?: number
    avgResponseTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ValidationUpdateWithoutValidatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ValidationUncheckedUpdateWithoutValidatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationUncheckedUpdateManyWithoutValidatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conflictReview?: ConflictReviewUpdateOneRequiredWithoutCommitteeVotesNestedInput
    translation?: TranslationUpdateOneWithoutCommitteeVotesNestedInput
  }

  export type CommitteeVoteUncheckedUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RejectionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutRejectionNestedInput
  }

  export type RejectionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RejectionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    reasonCode?: EnumRejectionReasonFieldUpdateOperationsInput | $Enums.RejectionReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    canResubmit?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAdminActionFieldUpdateOperationsInput | $Enums.AdminAction
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncDate?: DateTimeFieldUpdateOperationsInput | Date | string
    translationsCount?: IntFieldUpdateOperationsInput | number
    babelonFilePath?: NullableStringFieldUpdateOperationsInput | string | null
    githubPrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewUpdateWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hpoTerm?: HpoTermUpdateOneRequiredWithoutConflictReviewsNestedInput
    translations?: TranslationUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutConflictReviewNestedInput
  }

  export type ConflictReviewUncheckedUpdateWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutConflictReviewNestedInput
  }

  export type ConflictReviewUncheckedUpdateManyWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutStrikesGivenNestedInput
    translation?: TranslationUpdateOneWithoutStrikesNestedInput
  }

  export type StrikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStrikesNestedInput
    translation?: TranslationUpdateOneWithoutStrikesNestedInput
  }

  export type StrikeUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    userAgent?: StringFieldUpdateOperationsInput | string
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    browserVersion?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    isMobile?: BoolFieldUpdateOperationsInput | boolean
    sessionStart?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    pagesVisited?: SessionLogUpdatepagesVisitedInput | string[]
    actionsCount?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyTermInput = {
    id?: string
    userId: string
    labelPt: string
    definitionPt?: string | null
    synonymsPt?: TranslationCreatesynonymsPtInput | string[]
    notes?: string | null
    status?: $Enums.TranslationStatus
    confidence?: number
    source?: $Enums.TranslationSource
    isLegacy?: boolean
    aiSuggestion?: string | null
    aiConfidence?: number | null
    approvalCount?: number
    rejectionCount?: number
    averageRating?: number | null
    syncedToHpo?: boolean
    syncedAt?: Date | string | null
    approvedBy?: string | null
    rejectedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type HpoTermCreateManyParentInput = {
    id?: string
    hpoId: string
    labelEn: string
    definitionEn?: string | null
    synonymsEn?: HpoTermCreatesynonymsEnInput | string[]
    category?: string | null
    difficulty?: number
    translationStatus?: $Enums.TranslationStatus
    hpoVersion?: string | null
    isObsolete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConflictReviewCreateManyHpoTermInput = {
    id?: string
    type: $Enums.ConflictType
    status?: $Enums.ConflictStatus
    priority?: $Enums.Priority
    winningTranslationId?: string | null
    resolution?: string | null
    resolvedBy?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutTranslationsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HpoTermUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutTermNestedInput
    children?: HpoTermUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutTermNestedInput
    children?: HpoTermUncheckedUpdateManyWithoutParentNestedInput
    conflictReviews?: ConflictReviewUncheckedUpdateManyWithoutHpoTermNestedInput
  }

  export type HpoTermUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoId?: StringFieldUpdateOperationsInput | string
    labelEn?: StringFieldUpdateOperationsInput | string
    definitionEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsEn?: HpoTermUpdatesynonymsEnInput | string[]
    category?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    translationStatus?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    hpoVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isObsolete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewUpdateWithoutHpoTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutConflictReviewNestedInput
    resolver?: UserUpdateOneWithoutConflictsResolvedNestedInput
  }

  export type ConflictReviewUncheckedUpdateWithoutHpoTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutConflictReviewNestedInput
  }

  export type ConflictReviewUncheckedUpdateManyWithoutHpoTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationCreateManyTranslationInput = {
    id?: string
    validatorId: string
    rating: number
    decision: $Enums.ValidationDecision
    comments?: string | null
    suggestions?: string | null
    accuracyScore?: number | null
    clarityScore?: number | null
    consistencyScore?: number | null
    timeSpentSeconds?: number | null
    createdAt?: Date | string
  }

  export type CommentCreateManyTranslationInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StrikeCreateManyTranslationInput = {
    id?: string
    userId: string
    adminId: string
    reason: $Enums.StrikeReason
    detailedReason: string
    severity?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CommitteeVoteCreateManyTranslationInput = {
    id?: string
    conflictReviewId: string
    voterId: string
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type ValidationUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validator?: UserUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ValidationUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    validatorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationUncheckedUpdateManyWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    validatorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    decision?: EnumValidationDecisionFieldUpdateOperationsInput | $Enums.ValidationDecision
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    accuracyScore?: NullableIntFieldUpdateOperationsInput | number | null
    clarityScore?: NullableIntFieldUpdateOperationsInput | number | null
    consistencyScore?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStrikesNestedInput
    admin?: UserUpdateOneRequiredWithoutStrikesGivenNestedInput
  }

  export type StrikeUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrikeUncheckedUpdateManyWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reason?: EnumStrikeReasonFieldUpdateOperationsInput | $Enums.StrikeReason
    detailedReason?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConflictReviewUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hpoTerm?: HpoTermUpdateOneRequiredWithoutConflictReviewsNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutConflictReviewNestedInput
    resolver?: UserUpdateOneWithoutConflictsResolvedNestedInput
  }

  export type ConflictReviewUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutConflictReviewNestedInput
  }

  export type ConflictReviewUncheckedUpdateManyWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hpoTermId?: StringFieldUpdateOperationsInput | string
    type?: EnumConflictTypeFieldUpdateOperationsInput | $Enums.ConflictType
    status?: EnumConflictStatusFieldUpdateOperationsInput | $Enums.ConflictStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    winningTranslationId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conflictReview?: ConflictReviewUpdateOneRequiredWithoutCommitteeVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutConflictVotesNestedInput
  }

  export type CommitteeVoteUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conflictReviewId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    translationId: string
    userId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translation?: TranslationUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteCreateManyConflictReviewInput = {
    id?: string
    voterId: string
    translationId?: string | null
    voteType: $Enums.VoteType
    comment?: string | null
    votedAt?: Date | string
  }

  export type TranslationUpdateWithoutConflictReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    term?: HpoTermUpdateOneRequiredWithoutTranslationsNestedInput
    user?: UserUpdateOneRequiredWithoutTranslationsNestedInput
    validations?: ValidationUpdateManyWithoutTranslationNestedInput
    comments?: CommentUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUpdateOneWithoutTranslationNestedInput
    committeeVotes?: CommitteeVoteUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateWithoutConflictReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validations?: ValidationUncheckedUpdateManyWithoutTranslationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTranslationNestedInput
    strikes?: StrikeUncheckedUpdateManyWithoutTranslationNestedInput
    rejection?: RejectionUncheckedUpdateOneWithoutTranslationNestedInput
    committeeVotes?: CommitteeVoteUncheckedUpdateManyWithoutTranslationNestedInput
  }

  export type TranslationUncheckedUpdateManyWithoutConflictReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    labelPt?: StringFieldUpdateOperationsInput | string
    definitionPt?: NullableStringFieldUpdateOperationsInput | string | null
    synonymsPt?: TranslationUpdatesynonymsPtInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranslationStatusFieldUpdateOperationsInput | $Enums.TranslationStatus
    confidence?: IntFieldUpdateOperationsInput | number
    source?: EnumTranslationSourceFieldUpdateOperationsInput | $Enums.TranslationSource
    isLegacy?: BoolFieldUpdateOperationsInput | boolean
    aiSuggestion?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    approvalCount?: IntFieldUpdateOperationsInput | number
    rejectionCount?: IntFieldUpdateOperationsInput | number
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    syncedToHpo?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommitteeVoteUpdateWithoutConflictReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voter?: UserUpdateOneRequiredWithoutConflictVotesNestedInput
    translation?: TranslationUpdateOneWithoutCommitteeVotesNestedInput
  }

  export type CommitteeVoteUncheckedUpdateWithoutConflictReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitteeVoteUncheckedUpdateManyWithoutConflictReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    translationId?: NullableStringFieldUpdateOperationsInput | string | null
    voteType?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    votedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HpoTermCountOutputTypeDefaultArgs instead
     */
    export type HpoTermCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HpoTermCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationCountOutputTypeDefaultArgs instead
     */
    export type TranslationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConflictReviewCountOutputTypeDefaultArgs instead
     */
    export type ConflictReviewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConflictReviewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HpoTermDefaultArgs instead
     */
    export type HpoTermArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HpoTermDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationDefaultArgs instead
     */
    export type TranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ValidationDefaultArgs instead
     */
    export type ValidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ValidationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserActivityDefaultArgs instead
     */
    export type UserActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConflictReviewDefaultArgs instead
     */
    export type ConflictReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConflictReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommitteeVoteDefaultArgs instead
     */
    export type CommitteeVoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommitteeVoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RejectionDefaultArgs instead
     */
    export type RejectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RejectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminAuditLogDefaultArgs instead
     */
    export type AdminAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminAuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncLogDefaultArgs instead
     */
    export type SyncLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrikeDefaultArgs instead
     */
    export type StrikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionLogDefaultArgs instead
     */
    export type SessionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAnalyticsDefaultArgs instead
     */
    export type UserAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiMetricsDefaultArgs instead
     */
    export type ApiMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiMetricsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}